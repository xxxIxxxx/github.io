<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用 hexo 和 github 搭建自己的博客</title>
    <url>/2020/12/18/000/</url>
    <content><![CDATA[<h1 id="博客迁移自本人简书"><a href="#博客迁移自本人简书" class="headerlink" title="博客迁移自本人简书"></a><a class="link"   href="https://www.jianshu.com/u/192abcc5117c" >博客迁移自本人简书<i class="fas fa-external-link-alt"></i></a></h1><blockquote>
<p>迁移的文章时间未同步。为了防止每次发布，时间跟着改变。随机给了一个时间。</p>
</blockquote>
<h1 id="Hexo-教程"><a href="#Hexo-教程" class="headerlink" title="Hexo 教程"></a><a class="link"   href="https://hexo.io/zh-cn/" >Hexo 教程<i class="fas fa-external-link-alt"></i></a></h1><h1 id="Hexo-主题-Keep"><a href="#Hexo-主题-Keep" class="headerlink" title="Hexo 主题 Keep"></a><a class="link"   href="https://keep.xpoet.cn/" >Hexo 主题 Keep<i class="fas fa-external-link-alt"></i></a></h1><blockquote>
<p>Keep主题 精简好看 就是我用的这套主题</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Swift GCD barrier</title>
    <url>/2020/11/02/100-Swift-GCD-barrier/</url>
    <content><![CDATA[<h1 id="异步读写造成数组越界"><a href="#异步读写造成数组越界" class="headerlink" title="异步读写造成数组越界"></a>异步读写造成数组越界</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let count &#x3D; 100000</span><br><span class="line">var array &#x3D; Array(0 ... count)</span><br><span class="line"></span><br><span class="line">func getLast() -&gt; Int &#123;</span><br><span class="line">&#x2F;&#x2F; ⚠️⚠️ 这里加了判断看似安全，但在异步操作时 判断 array.count &gt; 0 的同时可能就有一个异步的操作改变了数组</span><br><span class="line">    if array.count &gt; 0 &#123;</span><br><span class="line">        return array[array.count - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func removeLast() &#123;</span><br><span class="line">    array.removeLast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        print(getLast())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-barrier"><a href="#使用-barrier" class="headerlink" title="使用 barrier"></a>使用 barrier</h1><blockquote>
<p>会保证在同一个队列中 .barrier 执行完之后才会去做其他线程操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let count &#x3D; 100000</span><br><span class="line">var array &#x3D; Array(0 ... count)</span><br><span class="line">let arrayQueue &#x3D; DispatchQueue(label: &quot;arrayQueue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line"></span><br><span class="line">func getLast() -&gt; Int &#123;</span><br><span class="line">    arrayQueue.sync &#123; () -&gt; Int in</span><br><span class="line">        if array.count &gt; 0 &#123;</span><br><span class="line">            return array[array.count - 1]</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func removeLast() &#123;</span><br><span class="line">&#x2F;&#x2F;⚠️⚠️ 这里使用 barrier </span><br><span class="line">    let workItem &#x3D; DispatchWorkItem(qos: DispatchQoS.default, flags: DispatchWorkItemFlags.barrier) &#123;</span><br><span class="line">        array.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    arrayQueue.async(execute: workItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        print(getLast())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift GCD 的串行队列与并行队列</title>
    <url>/2020/11/07/100-Swift-GCD-%E7%9A%84%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97%E4%B8%8E%E5%B9%B6%E8%A1%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>队列</th>
<th>异步是否阻塞当前线程</th>
<th>同步是否阻塞当前线程</th>
<th>执行顺序</th>
</tr>
</thead>
<tbody><tr>
<td>串行队列</td>
<td>否</td>
<td>是</td>
<td>按添加顺序</td>
</tr>
<tr>
<td>并行队列</td>
<td>否</td>
<td>是</td>
<td>同时执行，但会被同步阻塞</td>
</tr>
</tbody></table>
<h1 id="串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序"><a href="#串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序" class="headerlink" title="串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序"></a>串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序</h1><h1 id="并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞"><a href="#并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞" class="headerlink" title="并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞"></a>并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞</h1><hr>
<h1 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;queue&quot;)</span><br><span class="line">print(&quot;------ 开始 -------&quot;)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 3)</span><br><span class="line">    print(&quot;------ async 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ async 1 不阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 2 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 3)</span><br><span class="line">    print(&quot;------ sync 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ 被 sync 1 阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 3 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------ 开始 -------</span><br><span class="line">------ async 1 不阻塞 -------</span><br><span class="line">------ async 1 -------</span><br><span class="line">------ async 2 -------</span><br><span class="line">------ sync 1 -------</span><br><span class="line">------ 被 sync 1 阻塞 -------</span><br><span class="line">------ async 3 -------</span><br></pre></td></tr></table></figure>
<h1 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;queue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line">print(&quot;------ 开始 -------&quot;)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 3)</span><br><span class="line">    print(&quot;------ async 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ async 1 不阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 2 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 5)</span><br><span class="line">    print(&quot;------ sync 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ 被 sync 1 阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 3 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------ 开始 -------</span><br><span class="line">------ async 1 不阻塞 -------</span><br><span class="line">------ async 2 -------</span><br><span class="line">------ async 1 -------</span><br><span class="line">------ sync 1 -------</span><br><span class="line">------ 被 sync 1 阻塞 -------</span><br><span class="line">------ async 3 -------</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift GCD 死锁</title>
    <url>/2020/11/04/100-Swift-GCD-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="1-串行队列中，在异步任务中添加同步任务"><a href="#1-串行队列中，在异步任务中添加同步任务" class="headerlink" title="1. 串行队列中，在异步任务中添加同步任务"></a>1. 串行队列中，在异步任务中添加同步任务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 由于没有定义 attributes 所以是串行队列</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;----- task 1 -------&quot;)</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        print(&quot;----- task 2 -------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⚠️解决方法</span><br><span class="line">&#x2F;&#x2F;&#x2F; 解决方法将串行改为并行</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="2-主线程同步"><a href="#2-主线程同步" class="headerlink" title="2. 主线程同步"></a>2. 主线程同步</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue.main</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    print(&quot;----- task 1 -------&quot;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift String 截取字符串，String 转 NSString</title>
    <url>/2020/11/09/100-Swift-String-%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C-String-%E8%BD%AC-NSString/</url>
    <content><![CDATA[<h1 id="String-转-NSString，转为-NSString-后-OC-的方法就能使用了"><a href="#String-转-NSString，转为-NSString-后-OC-的方法就能使用了" class="headerlink" title="String 转 NSString，转为 NSString 后 OC 的方法就能使用了"></a>String 转 NSString，转为 NSString 后 OC 的方法就能使用了</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 转为 NSString</span><br><span class="line"> (&quot;ABCD&quot; as NSString)</span><br><span class="line">&#x2F;&#x2F; 调用 NSString 的方法</span><br><span class="line"> (&quot;ABCD&quot; as NSString).substring(to: 1)</span><br></pre></td></tr></table></figure>

<h1 id="Swift-中-String-的字符串截取"><a href="#Swift-中-String-的字符串截取" class="headerlink" title="Swift 中 String 的字符串截取"></a>Swift 中 String 的字符串截取</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let str &#x3D; &quot;ABCDEFGHIGK&quot;</span><br><span class="line"></span><br><span class="line">       print(&quot;前5个&quot; + &quot;\(str.prefix(5))&quot;)</span><br><span class="line">       &#x2F;&#x2F; 前5个ABCDE</span><br><span class="line"></span><br><span class="line">       print(&quot;前150个&quot; + str.prefix(150))</span><br><span class="line">       &#x2F;&#x2F; 前150个ABCDEFGHIGK</span><br><span class="line"></span><br><span class="line">       print(&quot;后3个&quot; + &quot;\(str.suffix(3))&quot;)</span><br><span class="line">       &#x2F;&#x2F; 后3个IGK</span><br><span class="line"></span><br><span class="line">       print(&quot;后150个&quot; + &quot;\(str.suffix(150))&quot;)</span><br><span class="line">       &#x2F;&#x2F; 后150个ABCDEFGHIGK</span><br><span class="line"></span><br><span class="line">       let startIndex &#x3D; str.index(str.startIndex, offsetBy: 2)</span><br><span class="line">       let endIndex &#x3D; str.index(str.startIndex, offsetBy: 5)</span><br><span class="line"></span><br><span class="line">       print(&quot;2-5是&quot; + str[startIndex ..&lt; endIndex])</span><br><span class="line">       &#x2F;&#x2F; 2-5是CDE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 多线程</title>
    <url>/2020/11/10/100-Swift-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-Thread"><a href="#1-Thread" class="headerlink" title="1. Thread"></a>1. Thread</h1><h4 id="闭包内直接执行代码"><a href="#闭包内直接执行代码" class="headerlink" title="闭包内直接执行代码"></a>闭包内直接执行代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 闭包内直接执行代码</span><br><span class="line">Thread.detachNewThread &#123;</span><br><span class="line">                print(&quot;111&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建一个方法-开启子线程后去调用"><a href="#创建一个方法-开启子线程后去调用" class="headerlink" title="创建一个方法 开启子线程后去调用"></a>创建一个方法 开启子线程后去调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个方法 开启子线程后去调用</span><br><span class="line">let tr &#x3D; Thread(target: self, selector: #selector(threadTest), object: nil)</span><br><span class="line">&#x2F;&#x2F;开启</span><br><span class="line">tr.start()</span><br><span class="line"></span><br><span class="line">@objc func threadTest () &#123;</span><br><span class="line">        print(&quot;777&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Operation"><a href="#2-Operation" class="headerlink" title="2. Operation"></a>2. Operation</h1><h4 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; BlockOperation</span><br><span class="line">let operation &#x3D; BlockOperation &#123;</span><br><span class="line">      print(&quot; ----- BlockOperation  -----&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let queue &#x3D; OperationQueue()</span><br><span class="line">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>

<h4 id="继承自-Operation"><a href="#继承自-Operation" class="headerlink" title="继承自 Operation"></a>继承自 Operation</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 继承自 Operation</span><br><span class="line">class MyOperation: Operation &#123;</span><br><span class="line">            override func main() &#123;</span><br><span class="line">                print(&quot;--- MyOperation do ... ----&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">let operation &#x3D; MyOperation()</span><br><span class="line">&#x2F;&#x2F;&#x2F; 当 operation 执行完 会执行这个</span><br><span class="line">operation.completionBlock &#x3D; &#123;</span><br><span class="line">            print(&quot;----- completionBlock  ------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let queue &#x3D; OperationQueue()</span><br><span class="line">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>

<h1 id="3-GCD"><a href="#3-GCD" class="headerlink" title="3. GCD"></a>3. GCD</h1><h4 id="队列-Queue-常用的"><a href="#队列-Queue-常用的" class="headerlink" title="队列 Queue 常用的"></a>队列 Queue 常用的</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 异步 并行</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F; 回到主线程异步</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F; 异步延时</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 1) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><blockquote>
<p>label：名字标签<br>qos：优先级<br>attributes：串行队列、并行队列 concurrent<br>autoreleaseFrequency：频率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;, qos: DispatchQoS.default, attributes: DispatchQueue.Attributes.concurrent, autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit, target: nil)</span><br><span class="line">        </span><br><span class="line">queue.async &#123;</span><br><span class="line">            print(&quot; --- 异步 ---&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">queue.sync &#123;</span><br><span class="line">            print(&quot;--- 同步 -----&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">queue.asyncAfter(deadline: .now() + 5) &#123;</span><br><span class="line">            print(&quot;---- 5s ------&quot;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><blockquote>
<p>同步会等待他上一个进入的线程执行完才会开始(无论上一个线程是同步还是异步)，并且阻挡线程等待自己执行完毕才会继续往下执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 串行队列</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;)</span><br><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line"></span><br><span class="line">print(&quot;------- 开始 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(3)</span><br><span class="line">    print(&quot;------- 异步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    print(&quot;------- 同步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 A 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    print(&quot;------- 同步 B -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 B 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;------- 异步 B -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------- 等待 -------&quot;)</span><br><span class="line">&#x2F;&#x2F; wait 会阻塞线程</span><br><span class="line">group.wait()</span><br><span class="line">print(&quot;------- 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; notify 不会阻塞</span><br><span class="line">&#x2F;&#x2F;group.notify(queue: queue) &#123;</span><br><span class="line">&#x2F;&#x2F;print(&quot;------- 结束 -------&quot;)</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">------- 开始 -------</span><br><span class="line">------- 异步 A -------</span><br><span class="line">------- 同步 A -------</span><br><span class="line">------- 同步 A 结束 -------</span><br><span class="line">------- 同步 B -------</span><br><span class="line">------- 同步 B 结束 -------</span><br><span class="line">------- 等待 -------</span><br><span class="line">------- 异步 B -------</span><br><span class="line">------- 结束 -------</span><br></pre></td></tr></table></figure>

<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><blockquote>
<p>同步会阻塞后面的线程执行，且同步不受前边异步的影响</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line"></span><br><span class="line">print(&quot;------- 开始 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;------- 异步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;------- 同步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 A 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    sleep(3)</span><br><span class="line">    print(&quot;------- 同步 B -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 B 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(2)</span><br><span class="line">    print(&quot;------- 异步 B 耗时操作 -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: queue) &#123;</span><br><span class="line">    print(&quot;------- 全部结束 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 未被耗时操作阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">------- 开始 -------</span><br><span class="line">------- 同步 A -------</span><br><span class="line">------- 同步 A 结束 -------</span><br><span class="line">------- 异步 A -------</span><br><span class="line">------- 同步 B -------</span><br><span class="line">------- 同步 B 结束 -------</span><br><span class="line">------- 未被耗时操作阻塞 -------</span><br><span class="line">------- 异步 B 耗时操作 -------</span><br><span class="line">------- 全部结束 -------</span><br></pre></td></tr></table></figure>
<h4 id="DispatchSource-定时器例子"><a href="#DispatchSource-定时器例子" class="headerlink" title="DispatchSource 定时器例子"></a>DispatchSource 定时器例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var time &#x3D; 7</span><br><span class="line">let timer &#x3D; DispatchSource.makeTimerSource(flags: [], queue: .global())</span><br><span class="line">&#x2F;&#x2F;每秒执行一次</span><br><span class="line">timer.schedule(deadline: .now(), repeating: 1)</span><br><span class="line">timer.setEventHandler &#123;</span><br><span class="line">&#x2F;&#x2F;  由于使用的 queue 是  .global()   这里不是主线程 </span><br><span class="line">    time -&#x3D; 1</span><br><span class="line">    print(&quot;----- \(time)&quot;)</span><br><span class="line">    if time &#x3D;&#x3D; 1 &#123;</span><br><span class="line">        timer.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">timer.resume()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 数组</title>
    <url>/2020/11/22/100-Swift-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list &#x3D; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line">list.removeAll&#123; $0 &#x3D;&#x3D; &quot;2&quot; &#125;</span><br><span class="line">&#x2F;&#x2F;[&quot;1&quot;,&quot;3&quot;,&quot;4&quot;]</span><br></pre></td></tr></table></figure>


<h1 id="Swift-数组遍历的几种方式"><a href="#Swift-数组遍历的几种方式" class="headerlink" title="Swift 数组遍历的几种方式"></a>Swift 数组遍历的几种方式</h1><h3 id="1-for-in-不带索引"><a href="#1-for-in-不带索引" class="headerlink" title="1. for-in 不带索引"></a>1. for-in 不带索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 不带索引</span><br><span class="line">for obj in arr &#123;</span><br><span class="line">    print(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-forEach-不能使用-break-continue-，只能使用-return"><a href="#2-forEach-不能使用-break-continue-，只能使用-return" class="headerlink" title="2. forEach 不能使用 break continue ，只能使用 return"></a>2. forEach 不能使用 break continue ，只能使用 return</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 不带索引</span><br><span class="line">arr.forEach &#123; obj in</span><br><span class="line">    &#x2F;&#x2F; 不能使用 break continue ，只能使用 return</span><br><span class="line">    print(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-enumerated-带索引-和-值"><a href="#3-enumerated-带索引-和-值" class="headerlink" title="3. enumerated() 带索引 和 值"></a>3. enumerated() 带索引 和 值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 带索引 和 值</span><br><span class="line">for (index, obj) in arr.enumerated() &#123;</span><br><span class="line">    print(&quot;位置：\(index)&quot; + &quot;值：\(obj)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-while"><a href="#4-while" class="headerlink" title="4. while"></a>4. while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 迭代器</span><br><span class="line">var arrIterator &#x3D; arr.makeIterator()</span><br><span class="line">while let obj &#x3D; arrIterator.next() &#123;</span><br><span class="line">    print(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-indices-下标索引-遍历下标"><a href="#5-indices-下标索引-遍历下标" class="headerlink" title="5. indices 下标索引 遍历下标"></a>5. indices 下标索引 遍历下标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 下标索引 遍历下标</span><br><span class="line">for index in arr.indices &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间-for-in-区间-for-循环"><a href="#区间-for-in-区间-for-循环" class="headerlink" title="区间 for-in 区间 for 循环"></a>区间 for-in 区间 for 循环</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s &#x3D; 5</span><br><span class="line">&#x2F;&#x2F;&#x2F; 开区间不包含 50 ， 5 个一输出</span><br><span class="line">for i in stride(from: 0, to: 50, by: s) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 闭区间包含 50， 5 个一输出</span><br><span class="line">for i in stride(from: 0, through: 50, by: s) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组的一些查找操作"><a href="#数组的一些查找操作" class="headerlink" title="数组的一些查找操作"></a>数组的一些查找操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array &#x3D; [Int](7 ..&lt; 117)</span><br><span class="line"></span><br><span class="line">let a &#x3D; array.contains(100)</span><br><span class="line">print(&quot;\(a ? &quot;包含&quot; : &quot;不包含&quot;)&quot; + &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">let b &#x3D; array.contains(where: &#123; $0 &gt; 8 &#125;)</span><br><span class="line">print(&quot;\(b ? &quot;含有大于8的数字&quot; : &quot;不含有大于8的数字&quot;)&quot;)</span><br><span class="line"></span><br><span class="line">let c &#x3D; array.allSatisfy &#123; $0 &gt;&#x3D; 6 &#125;</span><br><span class="line">print(&quot;\(c ? &quot;所有数字都大于等于6&quot; : &quot;有数字小于6&quot;)&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;数组中第一个元素是&quot; + &quot;\(String(describing: array.first))&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;数组中最后一个元素是&quot; + &quot;\(String(describing: array.last))&quot;)</span><br><span class="line"></span><br><span class="line">let first &#x3D; array.first(where: &#123; $0 &gt; 8 &#125;)</span><br><span class="line">if let first &#x3D; first &#123;</span><br><span class="line">    print(&quot;第一个大于8的数字是&quot; + &quot;\(first)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let last &#x3D; array.last(where: &#123; $0 &gt; 8 &#125;)</span><br><span class="line">if let last &#x3D; last &#123;</span><br><span class="line">    print(&quot;最后一个大于8的数字是&quot; + &quot;\(last)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 10 在数组中第一次出现的位置</span><br><span class="line">array.firstIndex(of: 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 17 在数组中最后一次出现的位置</span><br><span class="line">array.lastIndex(of: 17)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift 的一些高阶函数 map、filter、reduce、flatMap、compactMap</title>
    <url>/2020/11/17/100-Swift-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-map-filter-reduce-flatMap-compactMap/</url>
    <content><![CDATA[<h1 id="map-对集合里的每一个元素进行操作，然后返回个新的集合"><a href="#map-对集合里的每一个元素进行操作，然后返回个新的集合" class="headerlink" title="map 对集合里的每一个元素进行操作，然后返回个新的集合"></a>map 对集合里的每一个元素进行操作，然后返回个新的集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers &#x3D; [1, 3, 5, 7, 9]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 对集合里的每一个元素进行操作，然后返回个新的集合</span><br><span class="line">print(numbers.map &#123; $0 * 10 &#125;)</span><br><span class="line">&#x2F;&#x2F; [10, 30, 50, 70, 90]</span><br></pre></td></tr></table></figure>

<h1 id="filter-过滤集合里面的每一个元素，返回一个满足条件的新的集合"><a href="#filter-过滤集合里面的每一个元素，返回一个满足条件的新的集合" class="headerlink" title="filter 过滤集合里面的每一个元素，返回一个满足条件的新的集合"></a>filter 过滤集合里面的每一个元素，返回一个满足条件的新的集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers &#x3D; [1, 3, 5, 7, 9]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 过滤集合里面的每一个元素，返回一个满足条件的新的集合</span><br><span class="line">print(numbers.filter &#123; $0 &gt; 5 &#125;)</span><br><span class="line">&#x2F;&#x2F; [7, 9]</span><br></pre></td></tr></table></figure>

<h1 id="reduce-对集合里面的每一个元素-作用在当前累计的结果上"><a href="#reduce-对集合里面的每一个元素-作用在当前累计的结果上" class="headerlink" title="reduce  对集合里面的每一个元素 作用在当前累计的结果上"></a>reduce  对集合里面的每一个元素 作用在当前累计的结果上</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 对集合里面的每一个元素 作用在当前累计的结果上</span><br><span class="line">let abc &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">print(abc.reduce(&quot;100&quot;) &#123; $0 + ($1 + &quot;kk&quot;) &#125;)</span><br><span class="line">&#x2F;&#x2F; 100akkbkkckk</span><br></pre></td></tr></table></figure>

<h1 id="flatMap-集合内的元素全是集合，那么把元素拆成同一级-放在一个新的集合里"><a href="#flatMap-集合内的元素全是集合，那么把元素拆成同一级-放在一个新的集合里" class="headerlink" title="flatMap 集合内的元素全是集合，那么把元素拆成同一级 放在一个新的集合里"></a>flatMap 集合内的元素全是集合，那么把元素拆成同一级 放在一个新的集合里</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [[1, 2, 3], [4, 5], [7]]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 集合内的元素全是集合，那么把元素拆成同一级 放在一个新的集合里</span><br><span class="line">print(list.flatMap &#123; $0 &#125;)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5, 7]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 只会拆一层</span><br><span class="line">let list1 &#x3D; [[1, 2, 3], [4, 5], [7], [[8], [9]]]</span><br><span class="line">print(list1.flatMap &#123; $0 &#125;)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5, 7, [8], [9]]</span><br></pre></td></tr></table></figure>

<h1 id="compactMap-过滤空值"><a href="#compactMap-过滤空值" class="headerlink" title="compactMap 过滤空值"></a>compactMap 过滤空值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let names: [String?] &#x3D; [&quot;am&quot;,nil,&quot;qw&quot;,&quot;er&quot;,nil]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 过滤空值</span><br><span class="line">print(names.compactMap&#123; $0 &#125;)</span><br><span class="line">&#x2F;&#x2F;[&quot;am&quot;, &quot;qw&quot;, &quot;er&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 添加下标 subscript</title>
    <url>/2020/11/23/100-Swift-%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87-subscript/</url>
    <content><![CDATA[<h1 id="关键子-subscript"><a href="#关键子-subscript" class="headerlink" title="关键子 subscript "></a>关键子 <code>subscript </code></h1><p>参数和返回值可以是任意类型（<code>inout</code>输入输出除外）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct People &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;, age &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给实例添加下标</span><br><span class="line">    subscript(n: String) -&gt; Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return age</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            age &#x3D; newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给结构体添加下标</span><br><span class="line">    static subscript(name: String, age: Int) -&gt; People &#123;</span><br><span class="line">        People(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; People(name: &quot;哈哈哈&quot;, age: 18)</span><br><span class="line">print(a[&quot;哈哈哈&quot;])&#x2F;&#x2F;18</span><br><span class="line">a[&quot;哈哈哈&quot;] &#x3D; 20</span><br><span class="line">print(a[&quot;哈哈哈&quot;])&#x2F;&#x2F;20</span><br><span class="line">let p &#x3D; People[&quot;哈喽&quot;, 20]</span><br><span class="line">print(p)&#x2F;&#x2F;People(name: &quot;哈喽&quot;, age: 20)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 类型转换</title>
    <url>/2020/12/21/100-Swift-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="Swift-类型转换-as-的使用"><a href="#Swift-类型转换-as-的使用" class="headerlink" title="Swift 类型转换 as 的使用"></a>Swift 类型转换 as 的使用</h1><h2 id="if-let-as"><a href="#if-let-as" class="headerlink" title="if let as"></a>if let as</h2><p> 类型转换，此时 <code>btn</code> 是 <code>Any</code> 类型，使用 <code>as?</code> 将他尝试转为 <code>UIButton</code>类型。并赋值给 <code>a</code>。 实际开发中建议 <code>a</code> 与 <code>btn</code> 命名一致，这里为了便于区分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if let a &#x3D; btn as? UIButton &#123;</span><br><span class="line">    print(a)</span><br><span class="line">    &#x2F;&#x2F; 这里 a 为真</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="guard-let-as"><a href="#guard-let-as" class="headerlink" title="guard let as"></a>guard let as</h2><p>和 <code>if let as</code> 基本一致，只是当转换失败时提前退出。适用于一些异步回调里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let btn &#x3D; btn as? UIButton else &#123; return &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift 协议与扩展</title>
    <url>/2020/12/25/100-Swift%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议 Protocol"></a>协议 Protocol</h1><h2 id="使用-Protocol-关键字创建一个协议"><a href="#使用-Protocol-关键字创建一个协议" class="headerlink" title="使用 Protocol 关键字创建一个协议"></a>使用 Protocol 关键字创建一个协议</h2><blockquote>
<p>让遵守该协议的 class 与 struct 实现约定一些方法与属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol PageNumberProtocol &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例属性</span><br><span class="line">    var pageNumber: Int &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例方法</span><br><span class="line">    func add()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类属性</span><br><span class="line">    static var name: String? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类方法</span><br><span class="line">    static func logName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遵守协议"><a href="#遵守协议" class="headerlink" title="遵守协议"></a>遵守协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Person: PageNumberProtocol &#123;</span><br><span class="line">    var pageNumber: Int</span><br><span class="line"></span><br><span class="line">    func add() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static var name: String?</span><br><span class="line"></span><br><span class="line">    static func logName() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car: PageNumberProtocol &#123;</span><br><span class="line">    var pageNumber: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">    func add() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static var name: String?</span><br><span class="line"></span><br><span class="line">    static func logName() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展-extension"><a href="#扩展-extension" class="headerlink" title="扩展 extension"></a>扩展 extension</h1><h2 id="扩展使用的很多应该都很熟悉"><a href="#扩展使用的很多应该都很熟悉" class="headerlink" title="扩展使用的很多应该都很熟悉"></a>扩展使用的很多应该都很熟悉</h2><blockquote>
<p>分散代码实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Car &#123;</span><br><span class="line">    func dididi() &#123;</span><br><span class="line">        print(&quot;滴滴滴&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car().dididi()</span><br></pre></td></tr></table></figure>

<h1 id="Protocl-Extension"><a href="#Protocl-Extension" class="headerlink" title="Protocl + Extension"></a>Protocl + Extension</h1><blockquote>
<p>给出协议并实现协议，这样遵守协议的 class 和 struct 就能直接使用协议方法。</p>
</blockquote>
<h2 id="runtime-添加属性"><a href="#runtime-添加属性" class="headerlink" title="runtime 添加属性"></a>runtime 添加属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getAssociatedObject&lt;T&gt;(_ object: Any, _ key: UnsafeRawPointer) -&gt; T? &#123;</span><br><span class="line">    return objc_getAssociatedObject(object, key) as? T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func setRetainedAssociatedObject&lt;T&gt;(_ object: Any, _ key: UnsafeRawPointer, _ value: T) &#123;</span><br><span class="line">    objc_setAssociatedObject(object, key, value, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protocol PageNumberProtocol &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例属性</span><br><span class="line">    var pageNumber: Int &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例方法</span><br><span class="line">    func add()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类属性</span><br><span class="line">    static var name: String? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类方法</span><br><span class="line">    static func logName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展遵守协议"><a href="#扩展遵守协议" class="headerlink" title="扩展遵守协议"></a>扩展遵守协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private var pageNumberKey: Void?</span><br><span class="line"></span><br><span class="line">private var nameKey: Void?</span><br><span class="line"></span><br><span class="line">extension UIViewController: PageNumberProtocol &#123;</span><br><span class="line">    static func logName() &#123;</span><br><span class="line">        debugPrint(name ?? &quot;无名&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static var name: String? &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            getAssociatedObject(self, &amp;nameKey)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            setRetainedAssociatedObject(self, &amp;nameKey, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func add() &#123;</span><br><span class="line">        pageNumber +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var pageNumber: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            getAssociatedObject(self, &amp;pageNumberKey) ?? 0</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            setRetainedAssociatedObject(self, &amp;pageNumberKey, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样所有遵守 PageNumberProtocol 协议的 UIViewController 就都有了协议要求的属性与方法且已经实现了。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Protocol</tag>
        <tag>Extension</tag>
      </tags>
  </entry>
  <entry>
    <title>第三方库提示</title>
    <url>/2020/11/11/100-Swift%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E3%80%81%E4%BB%A3%E7%A0%81%E4%B8%8D%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<h4 id="1-像OC的pch文件一样导入第三方库"><a href="#1-像OC的pch文件一样导入第三方库" class="headerlink" title="1.像OC的pch文件一样导入第三方库"></a>1.像OC的pch文件一样导入第三方库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个Swift文件，在导入的库前添加 @_exported</span><br><span class="line">🌰</span><br><span class="line"></span><br><span class="line">@_exported import Alamofire</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-Swift导入的第三方库代码没提示"><a href="#2-Swift导入的第三方库代码没提示" class="headerlink" title="2.Swift导入的第三方库代码没提示"></a>2.Swift导入的第三方库代码没提示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.选择target </span><br><span class="line">2.选择Build Settings </span><br><span class="line">3.搜索 User Header Search Paths</span><br><span class="line">4.填写 $(PODS_ROOT)，并设置为“recursive”  </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift获取值的类型</title>
    <url>/2020/11/19/100-Swift%E8%8E%B7%E5%8F%96%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>使用 <code>type(of:)</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let a &#x3D; type(of:&quot;😄&quot;)</span><br><span class="line"></span><br><span class="line">print(a) &#x2F;&#x2F;String</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://developer.apple.com/documentation/swift/2885064-type" >直达文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>在Swift中使用 NSClassFromString</title>
    <url>/2020/11/02/100-%E5%9C%A8Swift%E4%B8%AD%E4%BD%BF%E7%94%A8-NSClassFromString/</url>
    <content><![CDATA[<p>在Swift中使用 NSClassFromString</p>
<p>需要 <code>工程名</code> + <code> .</code>  +  <code>string</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSClassFromString(Bundle.main.object(forInfoDictionaryKey: &quot;CFBundleName&quot;)! + &quot;.&quot; + &quot;CustomCell&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="每次写这些很麻烦-所以简单封装下"><a href="#每次写这些很麻烦-所以简单封装下" class="headerlink" title="每次写这些很麻烦,所以简单封装下"></a>每次写这些很麻烦,所以简单封装下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func GetClassFromString(_ classString: String) -&gt; AnyClass? &#123;</span><br><span class="line">    </span><br><span class="line">    guard let bundleName: String &#x3D; Bundle.main.object(forInfoDictionaryKey: &quot;CFBundleName&quot;) as? String else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    var anyClass: AnyClass? &#x3D; NSClassFromString(bundleName + &quot;.&quot; + classString)</span><br><span class="line">    if (anyClass &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        anyClass &#x3D; NSClassFromString(classString)</span><br><span class="line">    &#125;</span><br><span class="line">    return anyClass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以后就可以直接调用"><a href="#以后就可以直接调用" class="headerlink" title="以后就可以直接调用"></a>以后就可以直接调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetClassFromString(&quot;cellName&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 怎么保证可靠传输？</title>
    <url>/2021/02/04/1000-001TCP%20%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="1-TCP-怎么保证可靠传输？"><a href="#1-TCP-怎么保证可靠传输？" class="headerlink" title="1. TCP 怎么保证可靠传输？"></a>1. TCP 怎么保证可靠传输？</h1><blockquote>
<p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。</p>
</blockquote>
<p>TCP协议保证数据传输可靠性的方式主要有：</p>
<ol>
<li><strong>数据分割</strong> 应用数据被分割成 TCP 认为最合适发送的数据块。</li>
<li><strong>编号</strong> TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>检验和</strong> TTCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制</strong>  TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h1 id="2-ARQ-协议"><a href="#2-ARQ-协议" class="headerlink" title="2. ARQ 协议"></a>2. ARQ 协议</h1><p> <strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h2 id="2-1-停止等待ARQ协议"><a href="#2-1-停止等待ARQ协议" class="headerlink" title="2.1 停止等待ARQ协议"></a>2.1 停止等待ARQ协议</h2><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>优点：</strong> 简单<br><strong>缺点：</strong> 信道利用率低，等待时间长</p>
<h3 id="2-1-1-无差错情况"><a href="#2-1-1-无差错情况" class="headerlink" title="2.1.1 无差错情况"></a>2.1.1 无差错情况</h3><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<h3 id="2-1-2-出现差错情况（超时重传）"><a href="#2-1-2-出现差错情况（超时重传）" class="headerlink" title="2.1.2 出现差错情况（超时重传）"></a>2.1.2 出现差错情况（超时重传）</h3><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。 <strong>这种自动重传方式常称为 自动重传请求 ARQ 。</strong></p>
<p>另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<h3 id="2-1-3-确认丢失和确认迟到"><a href="#2-1-3-确认丢失和确认迟到" class="headerlink" title="2.1.3 确认丢失和确认迟到"></a>2.1.3 确认丢失和确认迟到</h3><ul>
<li><strong>确认丢失：</strong> 确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> 确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h2 id="2-2-连续ARQ协议"><a href="#2-2-连续ARQ协议" class="headerlink" title="2.2 连续ARQ协议"></a>2.2 连续ARQ协议</h2><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h1 id="3-滑动窗口和流量控制"><a href="#3-滑动窗口和流量控制" class="headerlink" title="3. 滑动窗口和流量控制"></a>3. 滑动窗口和流量控制</h1><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h1 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个<strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</p>
</li>
<li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p>
</li>
<li><p><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
</li>
</ul>
<blockquote>
<p>摘录于 <a class="link"   href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E5%9B%9B-tcp-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93" >https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=四-tcp-协议如何保证可靠传输<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>ARQ协议</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 中常见的拥塞控制算法有哪些？</title>
    <url>/2021/02/05/1000-002TCP%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h1><h1 id="TCP-Tahoe-Reno"><a href="#TCP-Tahoe-Reno" class="headerlink" title="TCP Tahoe/Reno"></a>TCP Tahoe/Reno</h1><p>最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout/RTO）和重复确认为条件判断是否发生了丢包。两者的区别在于：Tahoe算法下如果收到三次重复确认，就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；而Reno算法如果收到三次重复确认，就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。<br>而Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。</p>
<h1 id="TCP-Vegas"><a href="#TCP-Vegas" class="headerlink" title="TCP Vegas"></a>TCP Vegas</h1><p>TCP Vegas算法由 Lawrence Brakmo 和 Larry L. Peterson 在1994年提出，它和其他拥塞控制算法的不同之处在于Vegas算法并不急于丢包来判断是否发生了拥塞，而是通过数据包延迟来判断。Vegas通过RTT（roundtrip time）来决定增加或者减小拥塞窗口，它能够将拥塞要发生时就避免拥塞，而不是等到拥塞已经发生之后再减小发送速度，因此能够减小重传和超时的几率。Vegas算法与其他算法（比如Reno）共存时，会由于比其他算法更先降低发送速率而出现公平性问题。</p>
<h1 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h1><p> TCP New Reno主要改进了TCP Reno中快速恢复阶段的重传。<br>在Reno的快恢复中，一旦出现3次重复确认，TCP发送方会重发数据包并设置定时器等待该重发数据包被确认。当重发的数据包被确认后，就立即退出快速恢复阶段，进入拥塞控制阶段。但如果一次拥塞中出现多个丢包，Reno会误以为发生了多次拥塞而重复减小拥塞窗口导致发送速率下降。<br>而在New Reno的快速恢复中，一旦出现3次重复确认，会记下出现重复确认时未确认的数据包的最大序列号，然后重发重复确认的数据包。如果有多个数据包丢失，则继续重发丢失的数据包，直到最大序列号的数据包被确认才推出快恢复阶段。<br>New Reno在低错误率时运行效率和“选择确认”（Selective ACKnowledgement，SACK）相当，在高错误率仍优于Reno。</p>
<h1 id="TCP-BIC-CUBIC"><a href="#TCP-BIC-CUBIC" class="headerlink" title="TCP BIC/CUBIC"></a>TCP BIC/CUBIC</h1><p>TCP BIC（Binary Increase Congestion control）旨在优化高速高延迟网络（即“长肥网络”（long fat network，LFN））的拥塞控制，其拥塞窗口算法使用二分搜索算法尝试找到能长时间保持拥塞窗口最大值的值。Linux内核在2.6.8至2.6.18使用该算法作为默认TCP拥塞算法。<br>BIC算法采用二分查找的方式来确定最大的窗口大小：如果发生丢包时窗口大小是W1，那么最大窗口Wmax应该小于W1；这时将窗口缩小到W2（乘以一个系数，也就是乘法减小），那么可以预期W1&gt;Wmax&gt;W2；这时再将窗口大小设置为(W1+W2)2（也就是二分查找），即每收到一个ACK就把窗口大小设置为两个界限的中点。<br>如果窗口大小已经无限逼近W1，说明网络状况又变好了（可用带宽增加了），这时BIC会尝试往上寻找更大的Wmax。而在往上寻找时，BIC会镜像的利用逼近当前Wmax的路径去搜寻，也就是前面是如何先快后慢慢地靠近当前Wmax的，后面就反过来先慢后快地增长。<br>而CUBIC则是比BIC更温和和系统化的分支版本，其使用三次函数代替二分算法作为其拥塞窗口算法（因为实际上BIC的搜索曲线看起来就像一个三次函数，所以干脆就写一个三次函数来模拟曲线），并且使用函数拐点作为拥塞窗口的设置值。Linux内核在2.6.19后使用该算法作为默认TCP拥塞算法。</p>
<h1 id="TCP-Westwood-Westwood"><a href="#TCP-Westwood-Westwood" class="headerlink" title="TCP Westwood/Westwood+"></a>TCP Westwood/Westwood+</h1><p>TCP Westwood改良自New Reno，不同于以往其他拥塞控制算法使用丢失来测量，其通过对确认包测量来确定一个“合适的发送速度”，并以此调整拥塞窗口和慢启动阈值。Westwood改良了慢启动阶段算法为“敏捷探测（Agile Probing）”，并且设计了一种持续探测拥塞窗口的方法来控制进入“敏捷探测”，使连接尽可能地使用更多的带宽。Westwood+使用更长的带宽估计间隔和优化的滤波器来修正Westwood对ACK压缩场景对带宽估计过高的问题。通过以上改良，TCP Westwood系列算法在有线网络和无线网络的拥塞控制上取得平衡，尤其研究中针对于无线通信网络上。</p>
<h1 id="Compound-TCP"><a href="#Compound-TCP" class="headerlink" title="Compound TCP"></a>Compound TCP</h1><p>Compound TCP是微软自己实现的TCP拥塞控制算法，通过同时维护两个拥塞窗口，来实现在长肥网络有较好的性能而又不损失公平性。CTCP维护两个拥塞窗口：一个常规的AIMD（英语：Additive increase/multiplicative decrease）窗口，以及一个基于延迟的窗口，最终实际使用的滑动窗口大小是这两个窗口的和。AIMD窗口与Reno的增加方式相同；如果延迟小，基于延迟的窗口将迅速增加以提高网络的利用率。一旦经历了排队，延迟窗口将逐渐减小以补偿增加的AIMD窗口。这样的目的是保持两者的总和大致恒定，使算法估计带宽时延积的路径。</p>
<h1 id="TCP-PRR"><a href="#TCP-PRR" class="headerlink" title="TCP PRR"></a>TCP PRR</h1><p>TCP PRR（TCP Proportional Rate Reduction ）是旨在恢复期间提高发送数据的准确性。该算法确保恢复后的拥塞窗口大小尽可能接近慢启动阈值</p>
<h1 id="TCP-BBR"><a href="#TCP-BBR" class="headerlink" title="TCP BBR"></a>TCP BBR</h1><p>TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由Google设计，于2016年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://juejin.cn/post/6844904003654926350" >https://juejin.cn/post/6844904003654926350<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 HTTPS 的加密与认证过程</title>
    <url>/2021/02/06/1000-003%E7%AE%80%E8%BF%B0%20HTTPS%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><ul>
<li><p>共享/对称密钥加密：客户端和服务端使用相同的密钥加密，缺陷：发送密钥有被窃听的风险，但不发送，对方就不能解密。如果密钥能够安全发送，那么数据也能安全送达，就无需加密。</p>
</li>
<li><p> 公开密钥加密：非对称加密，一把私钥，一把公钥，成对。首先，发送公钥给加密方，发送密文一方使用对方的公钥进行加密，对方收到密文后，使用自己的私钥进行解密。</p>
</li>
<li><p>混合加密：使用公开密钥加密方式传递共享密钥，再使用共享密钥加密传递的数据</p>
</li>
</ul>
<h1 id="证书的正确性：CA（数字认证机构）颁发的公开密钥证书"><a href="#证书的正确性：CA（数字认证机构）颁发的公开密钥证书" class="headerlink" title="证书的正确性：CA（数字认证机构）颁发的公开密钥证书"></a>证书的正确性：CA（数字认证机构）颁发的公开密钥证书</h1><ul>
<li>服务器把自己的公钥登录至CA进行认证；</li>
<li>CA机构使用自己的私钥给服务器的公钥署数字签名并颁发公钥证书；</li>
<li>客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥（事先植入到浏览器客户端），向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性；</li>
<li>使用服务器的公开密钥对报文加密并发送</li>
</ul>
<h1 id="SSL-TLS握手协议"><a href="#SSL-TLS握手协议" class="headerlink" title="SSL/TLS握手协议"></a>SSL/TLS握手协议</h1><ul>
<li>客户端给出协议版本号，一个随机数（client random），以及客户端支持的加密方式；</li>
<li>服务端确认双方使用的加密方式，并给出数字证书，以及一个服务器生成的随机数（server random）；</li>
<li>客户端确认证书有效，然后生成一个新的随机数（premaster secret），并使用数字证书的公钥加密这个随机数，发送给服务端；</li>
<li>服务端使用自己的私钥，获得客户端发送的随机数（premaster secret）;</li>
<li>客户端和服务端，根据约定的加密方式，使用前面的三个随机数，生成一个对话密钥（session key）,及共享密钥，然后使用该密钥加密整个数据交互过程。</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</title>
    <url>/2021/02/07/1000-004%E7%AE%80%E8%BF%B0%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><blockquote>
<p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p>
</blockquote>
<p><strong>第一次握手：</strong> 客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p><strong>第二次握手：</strong> 服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p><strong>第三次握手：</strong> 客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><blockquote>
<p>关闭时，发包顺序不一定。一般来说是客户端主动发起的关闭，过程如下。</p>
</blockquote>
<p><strong>第一次挥手：</strong> 当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p><strong>第二次挥手：</strong> 主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p><strong>第三次挥手：</strong> 主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p><strong>第四次挥手：</strong> 主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p>
<h1 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h1><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 与 HTTPS 有哪些区别？</title>
    <url>/2021/02/08/1000-005HTTP%20%E4%B8%8E%20HTTPS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1><ol>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ol>
<li>HyperText Transfer Protocol：超文本传输协议。</li>
<li>是一种用于分布式、协作式和超媒体信息系统的应用层协议。</li>
<li>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</li>
<li>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><ol>
<li>Hypertext Transfer Protocol Secure：安全的超文本传输协议。</li>
<li>是一种透过计算机网络进行安全通信的传输协议。</li>
<li>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。</li>
<li>HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</li>
<li>HTTPS 默认工作在 TCP 协议443端口</li>
</ol>
<h1 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h1><p><strong>1. 客户端发起 HTTPS 请求</strong><br><strong>2. 服务端的配置</strong><br>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>
<p><strong>3. 传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>
<p><strong>4. 客户端解析证书</strong><br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<p><strong>5. 传送加密信息</strong><br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p><strong>6. 服务端解密信息</strong><br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<p><strong>7. 传输加密后的信息</strong><br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<p><strong>8. 客户端解密信息</strong><br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://www.runoob.com/w3cnote/http-vs-https.html" >https://www.runoob.com/w3cnote/http-vs-https.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是跨域，什么情况下会发生跨域请求？</title>
    <url>/2021/02/09/1000-006%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h1><p>在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是跨域请求。</p>
<p>跨域的情况有：<br>同一域名不同端口<br>同一域名不同协议<br>域名不同 ip 相同<br>主域相同子域不同<br>不同域名</p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><ol>
<li>通过jsonp跨域</li>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ol>
<blockquote>
<p>摘录于 <a class="link"   href="https://cloud.tencent.com/developer/article/1175899" >https://cloud.tencent.com/developer/article/1175899<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>简述常见的 HTTP 状态码的含义（301，304，401，403）</title>
    <url>/2021/02/10/1000-007%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%20HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88301%EF%BC%8C304%EF%BC%8C401%EF%BC%8C403%EF%BC%89/</url>
    <content><![CDATA[<h1 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3** 重定向"></a>3** 重定向</h1><p><strong>300 Multiple Choice</strong><br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p><strong>301 Moved Permanently</strong><br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>
<p><strong>304 Not Modified</strong><br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p>
<p><strong>302 Found</strong><br>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>
<p><strong>303 See Other</strong><br>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</p>
<h1 id="4-客户端响应"><a href="#4-客户端响应" class="headerlink" title="4** 客户端响应"></a>4** 客户端响应</h1><p><strong>400 Bad Request</strong><br>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。</p>
<p><strong>401 Unauthorized</strong><br>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</p>
<p><strong>403 Forbidden</strong><br>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</p>
<p><strong>404 Not Found</strong><br>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<p><strong>405 Method Not Allowed</strong><br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<h1 id="5-服务端响应"><a href="#5-服务端响应" class="headerlink" title="5** 服务端响应"></a>5** 服务端响应</h1><p><strong>500 Internal Server Error</strong><br>服务器遇到了不知道如何处理的情况。</p>
<p><strong>501 Not Implemented</strong><br>此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。</p>
<p><strong>502 Bad Gateway</strong><br>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</p>
<p><strong>503 Service Unavailable</strong><br>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</p>
<h1 id="2-成功响应"><a href="#2-成功响应" class="headerlink" title="2** 成功响应"></a>2** 成功响应</h1><p><strong>200 OK</strong><br>请求成功。成功的含义取决于 HTTP 方法：<br>GET：资源已被提取并在消息正文中传输。<br>HEAD：实体标头位于消息正文中。<br>POST：描述动作结果的资源在消息体中传输。<br>TRACE：消息正文包含服务器收到的请求消息</p>
<p><strong>201 Created</strong><br>该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</p>
<p><strong>202 Accepted</strong><br>请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</p>
<p><strong>203 Non-Authoritative Information</strong><br>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。</p>
<h1 id="1-信息响应"><a href="#1-信息响应" class="headerlink" title="1** 信息响应"></a>1** 信息响应</h1><p><strong>100 Continue</strong><br>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p>
<p><strong>101 Switching Protocol</strong><br>该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。<br><strong>102 Processing (WebDAV)</strong><br>此代码表示服务器已收到并正在处理该请求，但没有响应可用。<br><strong>103 Early Hints</strong><br>此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 </p>
<blockquote>
<p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP 有拥塞控制吗？</title>
    <url>/2021/02/11/1000-008UDP/</url>
    <content><![CDATA[<h1 id="UDP-有拥塞控制吗？"><a href="#UDP-有拥塞控制吗？" class="headerlink" title="UDP 有拥塞控制吗？"></a>UDP 有拥塞控制吗？</h1><ol>
<li><strong>UDP 没有拥塞控制</strong>，网络出现拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。</li>
<li>UDP 支持一对一、一对多和多对的的交互通信。</li>
<li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<h1 id="TCP-与-UDP-的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。"><a href="#TCP-与-UDP-的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。" class="headerlink" title="TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。"></a>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</h1><h1 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h1><p>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及查错检测的功能。</p>
<h1 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h1><ol>
<li>UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表</li>
<li>UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li>
</ol>
<h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><ol>
<li>某些实时应用需要使用没有拥塞控制的 UDP，但很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，导致大家都无法正常接收。</li>
<li>还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠传输进行适当的改进，以减少数据的丢失。应用进程可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文</li>
</ol>
<blockquote>
<p><a class="link"   href="https://developer.aliyun.com/article/699136" >https://developer.aliyun.com/article/699136<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.runoob.com/w3cnote/summary-of-network.html#_label7" >https://www.runoob.com/w3cnote/summary-of-network.html#_label7<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</title>
    <url>/2021/02/12/1000-009DNS%20%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDNS%20%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="DNS-查询服务器的基本流程"><a href="#DNS-查询服务器的基本流程" class="headerlink" title="DNS 查询服务器的基本流程"></a>DNS 查询服务器的基本流程</h1><p><strong>查询顺序：</strong>浏览器缓存–&gt; 操作系统缓存–&gt; 本地 host 文件 –&gt; 路由器缓存–&gt; ISP DNS 缓存 –&gt; 顶级 DNS 服务器/根 DNS 服务器</p>
<p><strong>1. 浏览器缓存：</strong> 首先会向浏览器的缓存中读取上一次访问的记录，在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看缓存的当前状态 。</p>
<p><strong>2. 操作系统缓存：</strong> 查找存储在系统运行内存中的缓存。在 mac 中可以通过下面的命令清除系统中的 DNS 缓存。<br><code>dscacheutil -flushcache</code></p>
<p><strong>3. 本地 host 文件：</strong> 查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
<p><strong>4. 路由器缓存：</strong> 有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</p>
<p><strong>5. ISP DNS 缓存：</strong> 互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</p>
<p><strong>6. 顶级 DNS 服务器 / 根 DNS 服务器：</strong> 根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（baidu.com），本机继续查找，直到服务器找到(<a class="link"   href="http://www.baidu.com)的主机./" >www.baidu.com)的主机。<i class="fas fa-external-link-alt"></i></a><br>最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/t5awpd.png"
                      alt="过程图"
                ></p>
<p>上述图片是查找 <a class="link"   href="http://www.google.com/" >www.google.com<i class="fas fa-external-link-alt"></i></a> 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是</a> <a class="link"   href="http://www.google.com.,并不是我多打了一个.,这个.对应的就是根域名服务器,默认情况下所有的网址的最后一位都是.,既然是默认情况下,为了方便用户,通常都会省略,浏览器在请求/" >www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求<i class="fas fa-external-link-alt"></i></a> DNS 的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; <a class="link"   href="http://www.google.com../" >www.google.com.。<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="什么是-DNS-劫持？"><a href="#什么是-DNS-劫持？" class="headerlink" title="什么是 DNS 劫持？"></a>什么是 DNS 劫持？</h1><p>在 DNS 的解析中返回了一个假的 IP 地址给客户端，从而促使用户访问了错误的网站。</p>
<h1 id="DNS-劫持的方法"><a href="#DNS-劫持的方法" class="headerlink" title="DNS 劫持的方法"></a>DNS 劫持的方法</h1><p><strong>1. 本机 DNS 劫持</strong><br>攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地 DNS 配置，比如修改本地 hosts 文件，缓存等<br><strong>2. 路由 DNS 劫持</strong><br>很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置<br><strong>3.攻击 DNS 服务器</strong><br>直接攻击 DNS 服务器，例如对 DNS 服务器进行 DDOS 攻击，可以是 DNS 服务器宕机，出现异常请求，还可以利用某些手段感染 dns 服务器的缓存，使给用户返回来的是恶意的 ip 地址</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 OSI 七层模型，TCP，IP 属于哪一层？</title>
    <url>/2021/02/13/1000-010%E7%AE%80%E8%BF%B0%20OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8CTCP%EF%BC%8CIP%20%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.rruu.net/image/6027a373e47f9"
                     
                ></p>
<h1 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h1><p>1.应用层 2.传输层 3.网络层 4.网络接口层</p>
<h1 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h1><p>1.应用层 2.传输层 3.网络层 4.数据链路层 5.物理层</p>
<h1 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h1><p>1.物理层 2.数据链路层 3.网络层 4.传输层 5.会话层 6.表示层 7.应用层</p>
<h1 id="IP-协议属于网络层"><a href="#IP-协议属于网络层" class="headerlink" title="IP 协议属于网络层"></a>IP 协议属于网络层</h1><h1 id="TCP-协议属于传输层"><a href="#TCP-协议属于传输层" class="headerlink" title="TCP 协议属于传输层"></a>TCP 协议属于传输层</h1><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h2><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p>
<h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h2><p>最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</p>
<ol>
<li>基本数据单位为帧；</li>
<li>主要的协议：以太网协议；</li>
<li>两个重要设备名称：网桥和交换机。</li>
</ol>
<h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h2><p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是”路径选择、路由及逻辑寻址”。<br>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。</p>
<ol>
<li>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</li>
<li>基本数据单位为IP数据报；</li>
<li>包含的主要协议：<br>　　IP协议（Internet Protocol，因特网互联协议）;<br>　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;<br>　　ARP协议（Address Resolution Protocol，地址解析协议）;<br>　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</li>
<li>重要的设备：路由器。</li>
</ol>
<h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h2><p>传输层要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p>
<ol>
<li>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题</li>
<li>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）</li>
<li>重要设备：网关</li>
</ol>
<h2 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h2><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h2 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h2><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h2 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h2><p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>七层模型</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 TCP 粘包和拆包？</title>
    <url>/2021/02/14/1000-011%E4%BB%80%E4%B9%88%E6%98%AF%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="TCP-粘包和拆包"><a href="#TCP-粘包和拆包" class="headerlink" title="TCP 粘包和拆包"></a>TCP 粘包和拆包</h1><p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况。</p>
<ol>
<li><p>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，<strong>没有粘包和拆包</strong>；</p>
</li>
<li><p>服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，<strong>被称为 TCP 粘包</strong>；</p>
</li>
<li><p>服务端分两次读取到了两个数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，<strong>这被称为 TCP 拆包</strong>；</p>
</li>
<li><p>服务端分两次读取到了两个数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。<br>如果此时服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2 比较大，很有可能会发生第五种可能，即<strong>服务端分多次才能将 D1 和 D2 包接收完全，期间发生多次拆包</strong>。</p>
</li>
</ol>
<h1 id="TCP粘包-拆包发生的原因"><a href="#TCP粘包-拆包发生的原因" class="headerlink" title="TCP粘包/拆包发生的原因"></a>TCP粘包/拆包发生的原因</h1><ol>
<li><p>应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</p>
</li>
<li><p>进行 MSS 大小的 TCP 分段；</p>
</li>
<li><p>以太网帧的 payload 大于 MTU 进行 IP 分片。</p>
</li>
</ol>
<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>泛指通讯协议中的最大传输单元。一般用来说明TCP/IP四层协议中数据链路层的最大传输单元，不同类型的网络MTU也会不同，我们普遍使用的以太网的MTU是1500，即最大只能传输1500字节的数据帧。可以通过ifconfig命令查看电脑各个网卡的MTU。</p>
<h1 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h1><p>指TCP建立连接后双方约定的可传输的最大TCP报文长度，是TCP用来限制应用层可发送的最大字节数。如果底层的MTU是1500byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 的方法有哪些？</title>
    <url>/2021/02/17/1000-013HTTP%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h1><p>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p>
<h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p>
<h1 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h1><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </p>
<h1 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h1><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p>
<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>DELETE方法删除指定的资源。</p>
<h1 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h1><p>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p>
<h1 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h1><p>OPTIONS方法用于描述目标资源的通信选项。</p>
<h1 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h1><p>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</p>
<h1 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h1><p>PATCH方法用于对资源应用部分修改。</p>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为HTTP动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享：: 例如一个请求方法可以是 safe(安全), idempotent(幂等), 或 cacheable(可缓存).</p>
<h2 id="safe-安全"><a href="#safe-安全" class="headerlink" title="safe(安全)"></a>safe(安全)</h2><p>如果说一个 HTTP 方法是安全的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD 和 OPTIONS。所有安全的方法都是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是。</p>
<h2 id="idempotent-幂等"><a href="#idempotent-幂等" class="headerlink" title="idempotent(幂等)"></a>idempotent(幂等)</h2><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p>
<h2 id="cacheable-可缓存"><a href="#cacheable-可缓存" class="headerlink" title="cacheable(可缓存)"></a>cacheable(可缓存)</h2><p>可缓存的响应是可被缓存的HTTP 响应，它被存储以供稍后检索和使用，从而将新的请求保存在伺服器。不是所有的 HTTP 响应都可以被缓存，可以被缓存的 HTTP 响应需满足如下列条件:</p>
<ul>
<li>请求中使用的方法本身是可以被缓存的，如 GET 或 HEAD 方法。如果下达了新的指示，响应 POST 方法也可以被缓存，但这种实施方式极为罕见。其他方法，如： PUT 或 DELETE 都不可以被缓存，同样他们的处理结果也不可以。</li>
<li>应用程式是会缓存已知的响应的状态码，并且被认为是可缓存的。这些可缓存的状态码如下： 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 和 501.</li>
<li>响应中没有指定的头部，如 Cache-Control，它可以阻止缓存。<br>请注意一些不缓存请求/响应到指定的 URI 可能会导致相同 URI 上以前的缓存响应失效。例如，  PUT 到 pageX.html 将使相同 URI 下所有的 GET 或 HEAD 请求缓存失效。</li>
</ul>
<blockquote>
<p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述对称与非对称加密的概念</title>
    <url>/2021/02/16/1000-012%E7%AE%80%E8%BF%B0%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密是最快速、最简单的一种加密方式，加密与解密用的是同样的密钥。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<p><strong>密钥交换的发送过程中有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</strong></p>
<h2 id="对称加密常用算法"><a href="#对称加密常用算法" class="headerlink" title="对称加密常用算法"></a>对称加密常用算法</h2><ol>
<li><strong>DES（Data Encryption Standard）</strong>：数据加密标准，速度较快，适用于加密大量数据的场合；</li>
<li><strong>3DES（Triple DES）</strong>：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li>
<li><strong>AES（Advanced Encryption Standard）</strong>：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密；</li>
</ol>
<h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><ol>
<li>加密方和解密方使用同一个密钥；</li>
<li>加密解密的速度比较快，适合数据比较长时的使用；</li>
<li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</li>
</ol>
<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p>
<h2 id="非对称加密常用算法"><a href="#非对称加密常用算法" class="headerlink" title="非对称加密常用算法"></a>非对称加密常用算法</h2><p>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。</p>
<p>使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。</p>
<h1 id="MD5-单向加密算法不可解密，属于散列算法。"><a href="#MD5-单向加密算法不可解密，属于散列算法。" class="headerlink" title="MD5 单向加密算法不可解密，属于散列算法。"></a>MD5 单向加密算法不可解密，属于散列算法。</h1><h1 id="Base64-是编码。"><a href="#Base64-是编码。" class="headerlink" title="Base64 是编码。"></a>Base64 是编码。</h1><blockquote>
<p>对称加密与非对称加密 <a class="link"   href="https://zhuanlan.zhihu.com/p/30573146" >https://zhuanlan.zhihu.com/p/30573146<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" >https://baike.baidu.com/item/对称加密<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie 和 Session 的关系和区别是什么？</title>
    <url>/2021/02/18/1000-015Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="Cookie-和-Session-的关系和区别"><a href="#Cookie-和-Session-的关系和区别" class="headerlink" title="Cookie 和 Session 的关系和区别"></a>Cookie 和 Session 的关系和区别</h1><ol>
<li>Cookie 在客户端（浏览器），Session 在服务器端。 </li>
<li>Cookie 的安全性一般，他人可通过分析存放在本地的 Cookie 并进行 Cookie 欺骗。在安全性第一的前提下，选择 Session 更优。重要交互信息比如权限等就要放在 Session 中，一般的信息记录放 Cookie 就好了。 </li>
<li>单个 Cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 Cookie。 </li>
<li>Session 可以放在文件、数据库或内存中，比如在使用 Node 时将 Session 保存在 redis 中。由于一定时间内它是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用 Cookie。 </li>
<li>Session 的运行依赖 Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID）。 </li>
<li>用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即 Session ID。</li>
</ol>
<p>题外话，那么话说 Session Cookie 能被篡改么？ 理论上可以，只要改变了连接时的 Session ID 就可以了~</p>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息。如何识别特定的客户呢？cookie 就可以做到。每次 HTTP 请求时，客户端都会发送相应的 Cookie 信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。<br>既然它是存储在客户端的，换句话说通过某些手法我就可以篡改本地存储的信息来欺骗服务端的某些策略。</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session 是在无状态的 HTTP 协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。在浏览器关闭后这次的 Session 就消失了，下次打开就不再拥有这个 Session。其实并不是 Session 消失了，而是 Session ID 变了，服务器端可能还是存着你上次的 Session ID 及其 Session 信息，只是他们是无主状态，也许一段时间后会被删除。</p>
<hr>
<p>实际上 Cookie 与 Session 都是会话的一种方式。它们的典型使用场景比如 “购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建 Cookie/Session 来获取这些信息。</p>
<p>如果你的站点是多节点部署，使用 Nginx 做负载均衡，那么有可能会出现 Session 丢失的情况（比如，忽然就处于未登录状态）。这时可以使用 IP 负载均衡（IP 绑定 ip_hash，每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 Session 的问题），或者将 Session 信息存储在集群中。在大型的网站中，一般会有专门的 Session 服务器集群，用来保存用户会话，这时可以使用缓存服务比如 Memcached 或者 Redis 之类的来存放 Session。</p>
<p>目前大多数的应用都是用 Cookie 实现 Session 跟踪的。第一次创建 Session 时，服务端会通过在 HTTP 协议中反馈到客户端，需要在 Cookie 中记录一个 Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用 URL 重写技术进行会话跟踪，即每次 HTTP 交互，URL 后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://ruby-china.org/topics/33313" >https://ruby-china.org/topics/33313<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 JWT 的原理和校验机制</title>
    <url>/2021/02/17/1000-014%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。"><a href="#JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。" class="headerlink" title="JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。"></a>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。</h1><h1 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h1 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGcio1JIUZIINiIsInR5CCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIioiIxMiMONTY30DkwIiwibmFtZSI6IkpvaG4</span><br><span class="line">gRG9IIiwiaXNTb2NpYWwiOnRydWv9.</span><br><span class="line">4pcPyMD09oIPSyXnrXCjTwXyr4BsezdI1AVTmud2fU4</span><br></pre></td></tr></table></figure>
<p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>
<p>JWT 的三个部分依次如下。</p>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
<p>写成一行，就是下面的样子。<br><code>Header.Payload.Signature</code></p>
<h2 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h2 id="Payload（负载）"><a href="#Payload（负载）" class="headerlink" title="Payload（负载）"></a>Payload（负载）</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h2 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。<br><code>Authorization: Bearer &lt;token&gt;</code><br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。<br>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" >https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</title>
    <url>/2021/02/21/1000-016TCP%20%E4%B8%8E%20UDP%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="TCP-与-UDP-在网络协议中的哪一层？"><a href="#TCP-与-UDP-在网络协议中的哪一层？" class="headerlink" title="TCP 与 UDP 在网络协议中的哪一层？"></a>TCP 与 UDP 在网络协议中的哪一层？</h1><p><strong>属于传输层协议</strong></p>
<h1 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h1><ol>
<li><p><strong>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。</strong></p>
</li>
<li><p><strong>TCP注重数据安全性，UDP数据传输快。</strong>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
</li>
<li><p><strong>UDP具有较好的实时性，工作效率比TCP高，</strong>适用于对高速传输和实时性有较高的通信或广播通信。</p>
</li>
<li><p><strong>TCP 一对一， UDP 一对一、一对多、多对一、多对多。</strong> 每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li><p><strong>TCP对系统资源要求较多，UDP对系统资源要求较少。</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 TCP 滑动窗口以及重传机制</title>
    <url>/2021/02/21/1000-017%E7%AE%80%E8%BF%B0%20TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h1><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。（TCP 会在以下两种情况发生超时重传：数据包丢失，确认应答丢失）</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 http 1.0，1.1，2.0 的主要区别</title>
    <url>/2021/02/22/1000-018%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>http1.0 到 http1.1 的主要区别，就是从无连接到长连接。<br>http2.0 对比 1.X 版本主要区别就是多路复用。</p>
<h1 id="http-1-0-特性"><a href="#http-1-0-特性" class="headerlink" title="http 1.0 特性"></a>http 1.0 特性</h1><h2 id="1-无状态"><a href="#1-无状态" class="headerlink" title="1. 无状态"></a>1. 无状态</h2><p>服务器不跟踪不记录请求过的状态<br>对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录</p>
<h2 id="2-无连接"><a href="#2-无连接" class="headerlink" title="2. 无连接"></a>2. 无连接</h2><p>浏览器每次请求都需要建立 tcp 连接</p>
<p>无连接导致的性能缺陷有两种：</p>
<ol>
<li>无法复用连接<br>每次发送请求，都需要进行一次 tcp 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低</li>
<li>队头阻塞<br>http1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li>
</ol>
<h1 id="http-1-1-特性"><a href="#http-1-1-特性" class="headerlink" title="http 1.1 特性"></a>http 1.1 特性</h1><p>为了解决 http1.0 的性能缺陷，http1.1 出现了</p>
<h2 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1. 长连接"></a>1. 长连接</h2><p>http1.1 默认保持长连接，数据传输完成保持 tcp 连接不断开,继续用这个通道传输数据。<br>新增 Connection 字段，可以设置 keep-alive 值保持连接不断开。</p>
<h2 id="2-管道化"><a href="#2-管道化" class="headerlink" title="2. 管道化"></a>2. 管道化</h2><p>基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p>
<p>基于长连接的基础，我们先看没有管道化请求响应：<br>tcp 没有断开，用的同一个通道<br><code>请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></p>
<p>管道化的请求响应：<br><code>请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</code><br>即使服务器先准备好响应 2,也是按照请求顺序先返回响应 1<br>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h2 id="3-缓存处理"><a href="#3-缓存处理" class="headerlink" title="3. 缓存处理"></a>3. 缓存处理</h2><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。<br>新增字段 cache-control 来控制</p>
<h2 id="4-断点传输"><a href="#4-断点传输" class="headerlink" title="4. 断点传输"></a>4. 断点传输</h2><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率<br>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p>
<h1 id="http-2-0-特性"><a href="#http-2-0-特性" class="headerlink" title="http 2.0 特性"></a>http 2.0 特性</h1><h2 id="1-二进制分帧"><a href="#1-二进制分帧" class="headerlink" title="1. 二进制分帧"></a>1. 二进制分帧</h2><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p>
<h2 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2. 多路复用"></a>2. 多路复用</h2><p>在共享 TCP 链接的基础上同时发送请求和响应<br>一个 Tcp 中多个 http 请求是并行的</p>
<h2 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h2><p>http2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<h2 id="4-服务器推送"><a href="#4-服务器推送" class="headerlink" title="4. 服务器推送"></a>4. 服务器推送</h2><p>服务器可以额外的向客户端推送资源，而无需客户端明确的请求</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 TCP 的 TIME_WAIT</title>
    <url>/2021/02/22/1000-019%E7%AE%80%E8%BF%B0%20TCP%20%E7%9A%84%20TIME_WAIT/</url>
    <content><![CDATA[<h1 id="为什么-TIME-WAIT"><a href="#为什么-TIME-WAIT" class="headerlink" title="为什么 TIME_WAIT"></a>为什么 TIME_WAIT</h1><p>主动关闭连接的一方最终进入 <code>TIME_WAIT</code> 状态等待一段才真正的释放内核中的连接记录，在释放记录之前这个连接使用的本地端口将一直被占用。<br>保持一段时间的 <code>TIME_WAIT</code> 的理由是：担心 <code>ack N+1</code> 没有送达，导致被动方重传 <code>FIN N</code>，那么主动方应当再次响应 <code>ack N+1</code>。<br>如果没有 <code>TIME_WAIT</code> 就直接复用该连接占用的端口，那么万一被动方重传<code>FIN N</code>，那么使用相同端口的新连接就会被错误关闭。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/m8c6bs.png"
                      alt="四次挥手"
                ></p>
<h1 id="优化-TIME-WAIT"><a href="#优化-TIME-WAIT" class="headerlink" title="优化 TIME_WAIT"></a>优化 TIME_WAIT</h1><p>谁主动关闭 <code>socket</code>，谁<code>TIME_WAIT</code>。<br>如果双方响应正常，TIME_WAIT 应该只是瞬间状态。</p>
<h1 id="服务端主动关闭"><a href="#服务端主动关闭" class="headerlink" title="服务端主动关闭"></a>服务端主动关闭</h1><p>无论有多少连接，服务端都只有一个端口，那就是监听端口，大量连接之间的差异仅仅是 TCP 4 元祖的客户端 ip 和 port 不同而已。</p>
<p>因此服务端<code>TIME_WAIT</code>压根不会耗尽端口，因为它就一个端口。</p>
<p>那么服务端就不需要优化了吗？对，没必要优化，一个<code>TIME_WAIT</code>的 4 元祖当遇到新的 SYN 时会复用，不需要特殊配置。</p>
<p>另外，当<code>TIME_WAIT</code>数量超过内核选项 net.ipv4.tcp_max_tw_buckets 的限制时，多余的<code>TIME_WAIT</code>连接将被立即关闭，然后在 netstat -s 中留下如下的溢出统计指标：</p>
<h1 id="客户端主动关闭"><a href="#客户端主动关闭" class="headerlink" title="客户端主动关闭"></a>客户端主动关闭</h1><p>客户端每个连接都会随机选择一个本地端口，所以最终会导致客户端大量端口处于 TIME_WAIT 状态，这和服务端主动关闭是最大的不同。<br>所以我们通常所说的 TIME_WAIT 问题都是针对客户端的，只是好像很少有人提及这一点。<br>网上有一种优化手段是把 net.ipv4.tcp_max_tw_buckets 调低，这样 TIME_WAIT 连接就会被删除，但是这不是一个最佳手段哈。</p>
<p>目前唯一安全的选项就是同时开启如下 2 个选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;1（连接发起方和接收方都需要开启）</span><br><span class="line">net.ipv4.tcp_tw_reuse&#x3D;1（只影响连接发起方）</span><br></pre></td></tr></table></figure>

<p>上述配置只影响连接发起方，也就是客户端，对服务端是无效的。<br>它的作用是向外发起连接的时候，可以复用 TIME_WAIT 的端口，但是有一个前提<br>该端口最后一次通讯时间距离当前系统时间&gt;1 秒</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://yuerblog.cc/2020/03/09/%E5%85%B3%E4%BA%8Etime_wait%E9%97%AE%E9%A2%98%E7%AE%80%E8%BF%B0%E4%B8%8E%E4%BC%98%E5%8C%96/" >https://yuerblog.cc/2020/03/09/关于time_wait问题简述与优化/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是中间人攻击？如何防止攻击？</title>
    <url>/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h1><p>A &lt;—-&gt; B<br>A &lt;—-&gt; C &lt;—-&gt; B<br>正常是 A 和 B 通信，这时 C 截获了 A 发给 B 的消息，然后假装成 A 给 B 发送消息。</p>
<p>中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。<br>在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL 协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p>
<h1 id="如何防止中间人攻击？"><a href="#如何防止中间人攻击？" class="headerlink" title="如何防止中间人攻击？"></a>如何防止中间人攻击？</h1><p>使用由 CA (数字证书认证机构 Certificate Authority)签发或签名的数子证书 来提供认证和加密。证书必须放入服务器和客户端中。</p>
<p>要信任某个证书真实有效，该证书必须通过属于可信认证中心 (CA) 的根证书进行数字签名。操作系统和浏览器维护有可信 CA 根证书的列表，以便可以轻松验证 CA 签发和签名的证书。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" >https://zh.wikipedia.org/wiki/中间人攻击<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN" >https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>RxSwift-Observable订阅、监听</title>
    <url>/2020/11/12/200-RxSwift-Observable%E8%AE%A2%E9%98%85%E3%80%81%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 直接订阅所有的</span><br><span class="line">ob.subscribe &#123; event in</span><br><span class="line">    print(&quot;事件&quot;, event)</span><br><span class="line">&#x2F;&#x2F; 通过 event.element 可以获取值</span><br><span class="line">    print(&quot;值是&quot;, event.element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;分开订阅</span><br><span class="line">ob.subscribe &#123; element in</span><br><span class="line">    print(&quot;onNext&quot;, element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(&quot;onError&quot;, error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125; onDisposed: &#123;</span><br><span class="line">    print(&quot;onDisposed&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;仅订阅 onNext</span><br><span class="line">ob.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="监听-do"><a href="#监听-do" class="headerlink" title="监听 do"></a>监听 do</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">ob.do &#123; element in</span><br><span class="line">    print(&quot;onNext&quot;, element)</span><br><span class="line">&#125; afterNext: &#123; element in</span><br><span class="line">    print(&quot;afterNext&quot;, element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(&quot;onError&quot;, error)</span><br><span class="line">&#125; afterError: &#123; error in</span><br><span class="line">    print(&quot;afterError&quot;, error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125; afterCompleted: &#123;</span><br><span class="line">    print(&quot;afterCompleted&quot;)</span><br><span class="line">&#125; onSubscribe: &#123;</span><br><span class="line">    print(&quot;onSubscribe&quot;)</span><br><span class="line">&#125; onSubscribed: &#123;</span><br><span class="line">    print(&quot;onSubscribed&quot;)</span><br><span class="line">&#125; onDispose: &#123;</span><br><span class="line">    print(&quot;onDispose&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 这里是订阅部分</span><br><span class="line">.subscribe &#123; element in</span><br><span class="line">    print(&quot;onNext&quot;, element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(&quot;onError&quot;, error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125; onDisposed: &#123;</span><br><span class="line">    print(&quot;onDisposed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-Single、Completab、Maybe</title>
    <url>/2020/11/22/200-RxSwift-Single%E3%80%81Completab%E3%80%81Maybe/</url>
    <content><![CDATA[<h1 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h1><p>只发出一次事件，常用于网络请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum DataError: Error &#123;</span><br><span class="line">    case error1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData() -&gt; Single&lt;[String: Any]&gt; &#123;</span><br><span class="line">    return Single&lt;[String: Any]&gt;.create &#123; (single) -&gt; Disposable in</span><br><span class="line">        single(.success([&quot;&quot;: 1]))</span><br><span class="line">&#x2F;&#x2F;                single(.error(DataError.error1))</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData().subscribe &#123; req in</span><br><span class="line">    switch req &#123;</span><br><span class="line">    case .success(let value):</span><br><span class="line">        print(value)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h1><p>只会发出<code>completed</code>或<code>error</code> 事件，用于只关心操作结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func cancel() -&gt; Completable &#123;</span><br><span class="line">    return Completable.create &#123; (comp) -&gt; Disposable in</span><br><span class="line">        comp(.completed)</span><br><span class="line">&#x2F;&#x2F;                comp(.error(ObError.error1))</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancel().subscribe &#123; rep in</span><br><span class="line">    switch rep &#123;</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;成功&quot;)</span><br><span class="line">    case let .error(error):</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h1><p>也是只能发出一个事件，正常的<code>event</code>或<code>completed </code>或<code>error</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func test() -&gt; Maybe&lt;String&gt; &#123;</span><br><span class="line">    return Maybe&lt;String&gt;.create &#123; (mayBe) -&gt; Disposable in</span><br><span class="line">        mayBe(.success(&quot;成功&quot;))</span><br><span class="line">&#x2F;&#x2F;                mayBe(.completed)</span><br><span class="line">&#x2F;&#x2F;                mayBe(.error(ObError.error1))</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().subscribe &#123; event in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .success(let value):</span><br><span class="line">        print(value)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-创建可观察序列</title>
    <url>/2020/11/11/200-RxSwift-%E5%88%9B%E5%BB%BA%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="empty-方法初始化"><a href="#empty-方法初始化" class="headerlink" title="empty() 方法初始化"></a>empty() 方法初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建了一个空内容的 Observable</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.empty()</span><br><span class="line">&#x2F;&#x2F; 先简单的写一种订阅的方法</span><br><span class="line">ob.subscribe &#123; print(&quot;执行了&quot;) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="just-方法-传入默认值初始化"><a href="#just-方法-传入默认值初始化" class="headerlink" title="just() 方法 传入默认值初始化"></a>just() 方法 传入默认值初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里不用给定泛型，会根据 just 自动推倒出</span><br><span class="line">let ob &#x3D; Observable.just(&quot;初始化默认值&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="of-方法-传入可变数量的值，但必须是同一类型"><a href="#of-方法-传入可变数量的值，但必须是同一类型" class="headerlink" title="of() 方法 传入可变数量的值，但必须是同一类型"></a>of() 方法 传入可变数量的值，但必须是同一类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(&quot;可&quot;, &quot;变&quot;, &quot;数&quot;, &quot;量&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="from-传入数组初始化"><a href="#from-传入数组初始化" class="headerlink" title="from() 传入数组初始化"></a>from() 传入数组初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.from([&quot;数&quot;, &quot;组&quot;])</span><br></pre></td></tr></table></figure>

<h3 id="never-永远不会发出-event-的-Observable-序列"><a href="#never-永远不会发出-event-的-Observable-序列" class="headerlink" title="never() 永远不会发出 event 的 Observable 序列"></a>never() 永远不会发出 event 的 Observable 序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Any&gt;.never()</span><br></pre></td></tr></table></figure>

<h3 id="error-直接发送一个错误"><a href="#error-直接发送一个错误" class="headerlink" title="error() 直接发送一个错误"></a>error() 直接发送一个错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum OBError: Error &#123;</span><br><span class="line">    case abc</span><br><span class="line">&#125;</span><br><span class="line">let ob &#x3D; Observable&lt;OBError&gt;.error(OBError.abc)</span><br></pre></td></tr></table></figure>

<h3 id="interval-每一秒发送一次"><a href="#interval-每一秒发送一次" class="headerlink" title="interval() 每一秒发送一次"></a>interval() 每一秒发送一次</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br></pre></td></tr></table></figure>

<h3 id="timer-定时发送"><a href="#timer-定时发送" class="headerlink" title="timer() 定时发送"></a>timer() 定时发送</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3 秒后，仅发送一次</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.timer(3, scheduler: MainScheduler.instance)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3 秒后，每 2 秒发送一次</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.timer(3, period: 2, scheduler: MainScheduler.asyncInstance)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-发送、订阅-Subjects、Variables</title>
    <url>/2020/11/15/200-RxSwift-%E5%8F%91%E9%80%81%E3%80%81%E8%AE%A2%E9%98%85-Subjects%E3%80%81Variables/</url>
    <content><![CDATA[<h1 id="Subjects-介绍"><a href="#Subjects-介绍" class="headerlink" title="Subjects 介绍"></a>Subjects 介绍</h1><h3 id="1-Subjects-是订阅者，也是Observable"><a href="#1-Subjects-是订阅者，也是Observable" class="headerlink" title="1. Subjects 是订阅者，也是Observable"></a>1. <code>Subjects</code> 是订阅者，也是<code>Observable</code></h3><ul>
<li>订阅者：它能动态的接收新的值。</li>
<li><code>Observable</code>： 当<code>Subjects</code>有了新值后会通过<code>Event</code>将新值发出给他的所有订阅者。</li>
</ul>
<hr>
<h3 id="2-常用的方法"><a href="#2-常用的方法" class="headerlink" title="2. 常用的方法"></a>2. 常用的方法</h3><p><code>onNext(:)：</code>是<code> on(.next(:))</code> 的简便写法。该方法相当于 <code>subject</code> 接收到一个<code>.next</code> 事件。<br><code>onError(:)：</code>是<code>on(.error(:))</code>的简便写法。该方法相当于 <code>subject</code> 接收到一个<code> .error</code> 事件。<br><code>onCompleted()：</code>是 <code>on(.completed)</code>的简便写法。该方法相当于 <code>subject</code> 接收到一个 <code>.completed</code>事件。</p>
<hr>
<h3 id="3-Subjects-有四种PublishSubject、BehaviorSubject、ReplaySubject、Variable"><a href="#3-Subjects-有四种PublishSubject、BehaviorSubject、ReplaySubject、Variable" class="headerlink" title="3. Subjects 有四种PublishSubject、BehaviorSubject、ReplaySubject、Variable"></a>3. <code>Subjects</code> 有四种<code>PublishSubject</code>、<code>BehaviorSubject</code>、<code>ReplaySubject</code>、<code>Variable</code></h3><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>都是<code>Observable</code>，他们的订阅者都能接收他们发出的新的<code>Event</code></li>
<li>直到 <code>Subject</code> 发出 <code>.complete</code> 或者 <code>.error</code> 的 <code>Event</code> 后，该 <code>Subject</code> 便终结了，同时它也就不会再发出<code>.next</code>事件。</li>
<li>对于那些在<code> Subject</code> 终结后再订阅他的订阅者，也能收到 <code>subject</code>发出的一条<code> .complete</code> 或<code> .error</code>的<code> event</code>，告诉这个新的订阅者它已经终结了。<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5></li>
<li> <code>PublishSubject</code><br>最普通的<code>Subject</code>，不需要初始值就能初始化。<br>他的订阅者只能收到他们订阅后的 <code>Event</code>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;订阅之前的不能接收到&quot;)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(event.element)</span><br><span class="line">&#x2F;&#x2F;Optional(&quot;订阅之后的可以接收到&quot;)</span><br><span class="line">&#x2F;&#x2F;nil</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;订阅之后的可以接收到&quot;)</span><br><span class="line">&#x2F;&#x2F;结束</span><br><span class="line">sub.onCompleted()</span><br><span class="line">&#x2F;&#x2F;&#x2F; 结束之后添加的订阅能收到 completed</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;结束后发的都收不到&quot;)</span><br></pre></td></tr></table></figure></li>
<li><code>BehaviorSubject</code><br>需要一个默认值初始化<br>当一个订阅者订阅之后会立马收到上一个<code>Event</code>，之后就是正常情况发一个收一个。<br><code>onCompleted()</code>之后的订阅者也只能收到<code>Completed</code>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; BehaviorSubject(value: &quot;默认值&quot;)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅1&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onNext(&quot;发送1&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅2&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onCompleted()</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅3&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">订阅1 next(默认值)</span><br><span class="line">订阅1 next(发送1)</span><br><span class="line">订阅2 next(发送1)</span><br><span class="line">订阅1 completed</span><br><span class="line">订阅2 completed</span><br><span class="line">订阅3 completed</span><br></pre></td></tr></table></figure></li>
<li><code>ReplaySubject</code><br>创建的时候需要一个参数<code>bufferSize</code>设置记录个数<br>新添加的订阅会接收到之前发送的两个  <code>Event</code>，如果不足两个就只接收一个。<br>如果超过两个只接收最新的两个。<br>如果订阅时已经结束除了会接收到最新的两个<code>Event</code>外还有结束的<code>complete </code>或<code>error </code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; ReplaySubject&lt;String&gt;.create(bufferSize: 2)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅1&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onNext(&quot;发送1&quot;)</span><br><span class="line">print(&quot;-------&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅2&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;发送2&quot;)</span><br><span class="line">sub.onNext(&quot;发送3&quot;)</span><br><span class="line">sub.onNext(&quot;发送4&quot;)</span><br><span class="line">print(&quot;-------&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅3&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onCompleted()</span><br><span class="line">print(&quot;-------&quot;)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 不仅会收到最后的两个 event 还有 Completed</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅4&quot;, event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">订阅1 next(发送1)</span><br><span class="line">-------</span><br><span class="line">订阅2 next(发送1)</span><br><span class="line">订阅1 next(发送2)</span><br><span class="line">订阅2 next(发送2)</span><br><span class="line">订阅1 next(发送3)</span><br><span class="line">订阅2 next(发送3)</span><br><span class="line">订阅1 next(发送4)</span><br><span class="line">订阅2 next(发送4)</span><br><span class="line">-------</span><br><span class="line">订阅3 next(发送3)</span><br><span class="line">订阅3 next(发送4)</span><br><span class="line">订阅1 completed</span><br><span class="line">订阅2 completed</span><br><span class="line">订阅3 completed</span><br><span class="line">-------</span><br><span class="line">订阅4 next(发送3)</span><br><span class="line">订阅4 next(发送4)</span><br><span class="line">订阅4 completed</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BehaviorRelay </code><br>基本同 <code>BehaviorSubject </code>功能一样，但是不能主动调用<code>onCompleted</code>和<code>error </code>，会在<code>BehaviorRelay </code>释放前调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; BehaviorRelay(value: &quot;初始值&quot;)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;第一次订阅&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.accept(&quot;新值1&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;第二次订阅&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>









</li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-延迟、超时、delay、timeout</title>
    <url>/2020/11/20/200-RxSwift-%E5%BB%B6%E8%BF%9F%E3%80%81%E8%B6%85%E6%97%B6%E3%80%81delay%E3%80%81timeout/</url>
    <content><![CDATA[<h1 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h1><p>对所有发送事件(包括<code>onCompleted</code>)后延迟 n 秒接收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.delay(RxTimeInterval.seconds(2), scheduler: MainScheduler.asyncInstance).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;发送了&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h1><p> 设置超时时间，超过规定时间的事件将发送  <code>error</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.timeout(RxTimeInterval.seconds(3), scheduler: MainScheduler.instance).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;发送1&quot;)</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 4) &#123;</span><br><span class="line">    ob.onNext(&quot;超时发送&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;next(发送1)</span><br><span class="line">&#x2F;&#x2F;error(Sequence timeout.)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-插入发送合并压缩-startWith、merge、zipignoreElement</title>
    <url>/2020/11/18/200-RxSwift-%E6%8F%92%E5%85%A5%E5%8F%91%E9%80%81%E5%90%88%E5%B9%B6%E5%8E%8B%E7%BC%A9-startWith%E3%80%81merge%E3%80%81zip/</url>
    <content><![CDATA[<h1 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h1><p>在订阅的时候插入发送事件，后加入的先发送。完成事件发送时不会插入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.startWith(&quot;插入1&quot;).startWith(&quot;插入2&quot;).subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;发送1&quot;)</span><br><span class="line">插入2</span><br><span class="line">插入1</span><br><span class="line">发送1</span><br></pre></td></tr></table></figure>

<h1 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h1><p>合并操作，将多个 <code>Observable</code> 合并成一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let ob2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.of(ob1,ob2).merge().subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob1.onNext(&quot;ob1 发1&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2 发1&quot;)</span><br><span class="line">ob1.onNext(&quot;ob1 发2&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2 发2&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><p>将 n 个<code>Observable</code>压缩成一个发送事件，必须每个都参与的发送完才会发送一次事件。参与的成对发送完</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let ob2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.zip(ob1,ob2).subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob1.onNext(&quot;ob1  2&quot;)</span><br><span class="line">ob1.onNext(&quot;ob1  3&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2  A&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2  B&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2  C&quot;)</span><br><span class="line">ob1.onNext(&quot;ob1  1&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;next((&quot;ob1  2&quot;, &quot;ob2  A&quot;))</span><br><span class="line">&#x2F;&#x2F;next((&quot;ob1  3&quot;, &quot;ob2  B&quot;))</span><br><span class="line">&#x2F;&#x2F;next((&quot;ob1  1&quot;, &quot;ob2  C&quot;))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-绑定-bind、bindTo、Binder</title>
    <url>/2020/11/13/200-RxSwift-%E7%BB%91%E5%AE%9A-bind%E3%80%81bindTo%E3%80%81Binder/</url>
    <content><![CDATA[<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br><span class="line"></span><br><span class="line">ob.map &#123;</span><br><span class="line">&#x2F;&#x2F; 对值进一步处理然后返回</span><br><span class="line">    &quot;count &quot; + &quot;\($0)&quot;</span><br><span class="line">&#125;</span><br><span class="line">.bind &#123; text in</span><br><span class="line">    countLab.text &#x3D; text</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">ob.bind &#123; x in</span><br><span class="line">    print(x)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h3 id="Binder-bindTo"><a href="#Binder-bindTo" class="headerlink" title="Binder + bindTo"></a>Binder + bindTo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br><span class="line">let observer: Binder&lt;String&gt; &#x3D; Binder(countLab) &#123; lab, text in</span><br><span class="line">    lab.text &#x3D; text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob.map &#123;</span><br><span class="line">    &quot;c&quot; + &quot;\($0)&quot;</span><br><span class="line">&#125;</span><br><span class="line">.bind(to: observer)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-自定义可绑属性</title>
    <url>/2020/11/14/200-RxSwift-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E7%BB%91%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="对-Reactive-进行扩展"><a href="#对-Reactive-进行扩展" class="headerlink" title="对 Reactive 进行扩展"></a>对 Reactive 进行扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 给 UILabel 增加了 fontSize 可绑属性</span><br><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(base) &#123; lab, size in</span><br><span class="line">            lab.font &#x3D; UIFont.systemFont(ofSize: size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br><span class="line">ob.map &#123; CGFloat($0) + 10.0 &#125;</span><br><span class="line">    .bind(to: lab.rx.fontSize) &#x2F;&#x2F; 这里要使用 .rx</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-订阅操作过滤1-map、buffer、filter</title>
    <url>/2020/11/16/200-RxSwift-%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C%E8%BF%87%E6%BB%A41-map%E3%80%81buffer%E3%80%81filter/</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>同 <code>Swift</code>中 <code>map</code> 用法一样，对值进行处理并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">sub.map &#123; $0 + &quot;mmmmm&quot; &#125;</span><br><span class="line">    .subscribe &#123; event in</span><br><span class="line">        print(event.element)</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">sub.onNext(&quot;a&quot;)</span><br><span class="line">&#x2F;&#x2F;Optional(&quot;ammmmm&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h1><p><code>timeSpan </code> 缓存间隔时间、              <code>count </code>缓存个数 、  <code>scheduler </code>线程<br>发送两个<code>event</code>后会触发订阅。满 2 秒也会触发订阅 ，如果<code>event</code> 没有发送空数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">sub.buffer(timeSpan: 2, count: 2, scheduler: MainScheduler.asyncInstance)</span><br><span class="line">    .subscribe &#123; event in</span><br><span class="line">        print(&quot;订阅1&quot;, event)</span><br><span class="line">    &#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;发送1&quot;)</span><br><span class="line">sub.onNext(&quot;发送2&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p>过滤 同<code>Swift</code>中<code>filter</code>一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(10, 11, 12, 99, 33, 55, 77)</span><br><span class="line">ob.filter &#123; $0 &gt; 20</span><br><span class="line">&#125;.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-订阅操作过滤2-distinctUntilChanged、single、elementAt、ignoreElement</title>
    <url>/2020/11/17/200-RxSwift-%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C%E8%BF%87%E6%BB%A42-distinctUntilChanged%E3%80%81single%E3%80%81elementAt%E3%80%81ignoreElement/</url>
    <content><![CDATA[<h1 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h1><p>过滤连续重复的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(1, 1, 1, 3, 5, 7, 9, 9)</span><br><span class="line">ob.distinctUntilChanged().subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#x2F;&#x2F;1 3 5 7 9</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="single"><a href="#single" class="headerlink" title="single"></a>single</h1><p>只发送一次正常事件，如果没有或者超过 1 个会发送 <code>error</code> 事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(1,2)</span><br><span class="line">ob.single().subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(&quot;错误&quot;,error)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;        1</span><br><span class="line">&#x2F;&#x2F;        错误 Sequence contains more than one element.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;----- single 增加过滤</span><br><span class="line">let ob &#x3D; Observable.of(1, 2, 1)</span><br><span class="line">ob.single &#123; $0 &#x3D;&#x3D; 2 &#125;.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(&quot;错误&quot;, error)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;        2</span><br></pre></td></tr></table></figure>

<h1 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h1><p>获取指定位置的事件，0 开始。 如果没有发生该指定位置事件 会发送错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0, 1, 2, 3, 4)</span><br><span class="line">ob.elementAt(2).subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>

<h1 id="ignoreElements"><a href="#ignoreElements" class="headerlink" title="ignoreElements"></a>ignoreElements</h1><p>会忽略所有主动发送的<code>event</code>事件，只保留 <code>error</code> 事件和 <code>Completed</code>事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0,1,2,3,4)</span><br><span class="line">ob.ignoreElements().subscribe &#123;</span><br><span class="line">    print(&quot;Completed&quot;)</span><br><span class="line">&#125; onError: &#123; (error) in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h1 id="take"><a href="#take" class="headerlink" title="take"></a>take</h1><p>只取前 n 个事件，数量达到或不足会发送 <code>Completed</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0, 1, 2, 3)</span><br><span class="line">ob.take(2).subscribe &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h1><p>只取后 n 个事件，数量达到或不足会发送 <code>Completed</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0, 1, 2, 3, 4)</span><br><span class="line">ob.takeLast(12).subscribe &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h1><p>跳过前 n 个事件，发送完剩下的事件后会发送<code>onCompleted</code>。不足 n 个直接发送<code>onCompleted</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0,1,2,3,4,5)</span><br><span class="line">ob.skip(4).subscribe &#123; (element) in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; (error) in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><p>当两个事件的发送间隔大于约定时间时才会收到该事件，常用的例子是搜索时延迟搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.debounce(RxTimeInterval.seconds(1), scheduler: MainScheduler.instance).subscribe(onNext: &#123; element in</span><br><span class="line">    print(&quot;收&quot;, element, CFAbsoluteTimeGetCurrent())</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">print(&quot;发&quot;, &quot;aaa&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">ob.onNext(&quot;aaa&quot;)</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 0.5) &#123;</span><br><span class="line">    print(&quot;发&quot;, &quot;bbb&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">    ob.onNext(&quot;bbb&quot;)</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 1.5) &#123;</span><br><span class="line">    print(&quot;发&quot;, &quot;ccc&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">    ob.onNext(&quot;ccc&quot;)</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 3.5) &#123;</span><br><span class="line">    print(&quot;发&quot;, &quot;ddd&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">    ob.onNext(&quot;ddd&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发 aaa 627481044.719082</span><br><span class="line">&#x2F;&#x2F;发 bbb 627481045.241852</span><br><span class="line">&#x2F;&#x2F;发 ccc 627481046.231139</span><br><span class="line">&#x2F;&#x2F;收 ccc 627481047.233378</span><br><span class="line">&#x2F;&#x2F;发 ddd 627481048.552644</span><br><span class="line">&#x2F;&#x2F;收 ddd 627481049.55595</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-转数组、累计操作-toArray、reduce</title>
    <url>/2020/11/19/200-RxSwift-%E8%BD%AC%E6%95%B0%E7%BB%84%E3%80%81%E7%B4%AF%E8%AE%A1%E6%93%8D%E4%BD%9C-toArray%E3%80%81reduce/</url>
    <content><![CDATA[<h1 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h1><p>将所有的事件集合在一起作为一个数组发出，需要发送<code>onCompleted</code>事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.toArray().subscribe &#123; strArr in</span><br><span class="line">    print(strArr)</span><br><span class="line">&#125; onError: &#123; _ in</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;1&quot;)</span><br><span class="line">ob.onNext(&quot;2&quot;)</span><br><span class="line">ob.onNext(&quot;3&quot;)</span><br><span class="line">ob.onCompleted()</span><br></pre></td></tr></table></figure>

<h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><p>累计操作，将每一次的事件都累积在一起在发送<code>onCompleted</code>时统一发送。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.reduce(&quot;初始值&quot;, accumulator: +).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;1&quot;)</span><br><span class="line">ob.onNext(&quot;2&quot;)</span><br><span class="line">ob.onNext(&quot;3&quot;)</span><br><span class="line">ob.onCompleted()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-错误处理、重试-catchError、retry</title>
    <url>/2020/11/21/200-RxSwift-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81%E9%87%8D%E8%AF%95-catchError%E3%80%81retry/</url>
    <content><![CDATA[<h1 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a>catchError</h1><p>当发送了<code>error</code>事件后可以返回一个新的序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ObError: Error &#123;</span><br><span class="line">    case error1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ob1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let ob2 &#x3D; PublishSubject.of(&quot;A&quot;, &quot;B&quot;)</span><br><span class="line"></span><br><span class="line">ob1.catchError &#123; (error) -&gt; Observable&lt;String&gt; in</span><br><span class="line">    print(error)</span><br><span class="line">    return ob2</span><br><span class="line">&#125;.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob1.onNext(&quot;111&quot;)</span><br><span class="line">ob1.onError(ObError.error1)</span><br><span class="line">&#x2F;&#x2F;next(111)</span><br><span class="line">&#x2F;&#x2F;error1</span><br><span class="line">&#x2F;&#x2F;next(A)</span><br><span class="line">&#x2F;&#x2F;next(B)</span><br><span class="line">&#x2F;&#x2F;completed</span><br></pre></td></tr></table></figure>
<h1 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h1><p>当发送了<code>error</code>后可以重新发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isFail &#x3D; true</span><br><span class="line">let obs &#x3D; Observable&lt;String&gt;.create &#123; (ob) -&gt; Disposable in</span><br><span class="line">    ob.onNext(&quot;成功1&quot;)</span><br><span class="line">    if isFail &#123;</span><br><span class="line">        ob.onError(ObError.error1)</span><br><span class="line">        isFail &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    ob.onNext(&quot;重试成功&quot;)</span><br><span class="line">    ob.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obs.retry(2).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">next(成功1)</span><br><span class="line">next(成功1)</span><br><span class="line">next(重试成功)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>674. 最长连续递增序列</title>
    <url>/2021/02/21/2000-001-674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a class="link"   href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" >674. 最长连续递增序列<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/a0hi84.png"
                      alt="题目描述"
                ></p>
<h1 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func findLengthOfLCIS(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        var start &#x3D; 0</span><br><span class="line">        var maxCount &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for (index, _) in nums.enumerated() &#123;</span><br><span class="line">            if index &gt; 0, nums[index] &lt;&#x3D; nums[index - 1] &#123;</span><br><span class="line">                start &#x3D; index</span><br><span class="line">            &#125;</span><br><span class="line">            let currentCount &#x3D; index - start + 1</span><br><span class="line">            maxCount &#x3D; (maxCount &gt; currentCount) ? maxCount : currentCount</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func findLengthOfLCIS(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        if nums.count &lt; 2 &#123;</span><br><span class="line">            return nums.count</span><br><span class="line">        &#125;</span><br><span class="line">        var maxCount &#x3D; 0</span><br><span class="line">        var preNumber &#x3D; nums.first</span><br><span class="line">        var tempCount &#x3D; 0</span><br><span class="line">        for item in nums &#123;</span><br><span class="line">            let isAdd &#x3D; item &gt; preNumber!</span><br><span class="line">            if isAdd &#123;</span><br><span class="line">                tempCount +&#x3D; 1</span><br><span class="line">                maxCount &#x3D; (maxCount &gt; tempCount) ? maxCount : tempCount</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tempCount &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">            preNumber &#x3D; item</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount + 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2021/02/21/2000-002-108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a class="link"   href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" >108. 将有序数组转换为二叉搜索树<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/hq8ztg.png"
                      alt="108. 将有序数组转换为二叉搜索树"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func sortedArrayToBST(_ nums: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">    return sortTree(nums, 0, nums.count - 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sortTree(_ nums: [Int], _ left: Int, _ right: Int) -&gt; TreeNode? &#123;</span><br><span class="line">    if left &gt; right &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    let mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">    let root &#x3D; TreeNode(nums[mid])</span><br><span class="line">    root.left &#x3D; sortTree(nums, left, mid - 1)</span><br><span class="line">    root.right &#x3D; sortTree(nums, mid + 1, right)</span><br><span class="line"></span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <url>/2021/02/21/2000-003-1382.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382. 将二叉搜索树变平衡"></a><a class="link"   href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" >1382. 将二叉搜索树变平衡<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/qm12q4.png"
                      alt="1382. 将二叉搜索树变平衡"
                ></p>
<h1 id="先变为有序递增数组，再平衡"><a href="#先变为有序递增数组，再平衡" class="headerlink" title="先变为有序递增数组，再平衡"></a>先变为有序递增数组，再平衡</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    func balanceBST(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        getList(root)</span><br><span class="line">        return buildTree(list, 0, list.count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func buildTree(_ nums: [Int], _ left: Int, _ right: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if left &gt; right &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">        let root &#x3D; TreeNode(nums[mid])</span><br><span class="line">        root.left &#x3D; buildTree(nums, left, mid - 1)</span><br><span class="line">        root.right &#x3D; buildTree(nums, mid + 1, right)</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉搜索树</span><br><span class="line">&#x2F;&#x2F;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； </span><br><span class="line">&#x2F;&#x2F; 所以采用中序遍历  先左 再根 最后右  刚好是递增数组</span><br><span class="line">    func getList(_ root: TreeNode?) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        getList(root.left)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        getList(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/2021/02/21/2000-004-33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" >33. 搜索旋转排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/8z9prz.png"
                      alt="33. 搜索旋转排序数组"
                ></p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func search(_ nums: [Int], _ target: Int) -&gt; Int &#123;</span><br><span class="line">        if nums.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return (nums[0] &#x3D;&#x3D; target) ? 0 : -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; nums.count - 1</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; left &lt;&#x3D; right 说明相遇了 在变就错过</span><br><span class="line">        while left &lt;&#x3D; right &#123; </span><br><span class="line">            &#x2F;&#x2F; 确定中间值</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; nums[mid] &lt; nums[right] 说明 mid 右边是有序递增的</span><br><span class="line">            if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">                &#x2F;&#x2F;如果 target 值在这个有序递增的范围内那就能确定 left 了，这里包含了右边等于 target 值的情况</span><br><span class="line">                if target &gt; nums[mid], target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right &#x3D; mid - 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; nums[mid] &gt; nums[right]  说明突变值（最小值）在 mid 右边，则 mid 左边是有序递增的</span><br><span class="line">                if target &gt;&#x3D; nums[left], target &lt; nums[mid] &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果 target 值在这个有序递增的范围内那就能确定 right 了，这里包含了左边等于 target 值的情况</span><br><span class="line">                    right &#x3D; mid - 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2021/02/21/2000-005-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a class="link"   href="https://leetcode-cn.com/problems/linked-list-cycle/" >141. 环形链表<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/3k71ua.png"
                      alt="141. 环形链表"
                ></p>
<h1 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        var slowTree &#x3D; head</span><br><span class="line">        var fastTree &#x3D; head?.next</span><br><span class="line"></span><br><span class="line">        while slowTree !&#x3D; nil || fastTree !&#x3D; nil &#123;</span><br><span class="line">            if slowTree &#x3D;&#x3D;&#x3D; fastTree &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            slowTree &#x3D; slowTree?.next</span><br><span class="line">            fastTree &#x3D; fastTree?.next?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        &#x2F;&#x2F; 注意这里使用 Set, 使用 Array 会超时</span><br><span class="line">        &#x2F;&#x2F; ListNode 需要实现 Equatable, Hashable 协议</span><br><span class="line">        var list: Set&lt;ListNode&gt; &#x3D; []</span><br><span class="line">        var head &#x3D; head</span><br><span class="line"></span><br><span class="line">        while head !&#x3D; nil &#123;</span><br><span class="line">            if list.contains(head!) &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            list.insert(head!)</span><br><span class="line">            head &#x3D; head?.next</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swift-链表-及-实现协议"><a href="#Swift-链表-及-实现协议" class="headerlink" title="Swift 链表 及 实现协议"></a>Swift 链表 及 实现协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    public var val: Int</span><br><span class="line">    public var next: ListNode?</span><br><span class="line">    public init() &#123; self.val &#x3D; 0; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int) &#123; self.val &#x3D; val; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int, _ next: ListNode?) &#123; self.val &#x3D; val; self.next &#x3D; next &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Equatable &#123;</span><br><span class="line">    public static func &#x3D;&#x3D; (l: ListNode, r: ListNode) -&gt; Bool &#123;</span><br><span class="line">        return l &#x3D;&#x3D;&#x3D; r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Hashable &#123;</span><br><span class="line">    public func hash(into hasher: inout Hasher) &#123;</span><br><span class="line">        hasher.combine(ObjectIdentifier(self))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>912. 排序数组</title>
    <url>/2021/02/22/2000-006-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/sort-an-array/" >912. 排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/stmaiz.png"
                      alt="912. 排序数组"
                ></p>
<h1 id="快速排序-递归解法"><a href="#快速排序-递归解法" class="headerlink" title="快速排序 递归解法"></a>快速排序 递归解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">        var nums &#x3D; nums</span><br><span class="line">        sort2(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort2(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        if left &lt; right &#123;</span><br><span class="line">            let p &#x3D; partition(&amp;nums, left, right)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值左边的数据 分界值的位置已经确定 所以传入 right &#x3D; p - 1</span><br><span class="line">            sort2(&amp;nums, left, p - 1)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值右边的数据 分界值的位置已经确定 所以传入 left &#x3D; p + 1</span><br><span class="line">            sort2(&amp;nums, p + 1, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func partition(_ nums: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 直接以 nums[right] 为分界值</span><br><span class="line">        let p &#x3D; nums[right]</span><br><span class="line">        &#x2F;&#x2F; 记录下一个 比分界值小的值 应该移动到哪个位置， 默认为最左边</span><br><span class="line">        var minL &#x3D; left</span><br><span class="line">        for i in left ..&lt; right &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前值 小于等于分界值，那么交换 i 和 minL 的值。否则不做处理</span><br><span class="line">            if nums[i] &lt;&#x3D; p &#123;</span><br><span class="line">                swap(&amp;nums, minL, i)</span><br><span class="line">                &#x2F;&#x2F; minL 已经被小于等于分界值的值占用，那么 +&#x3D; 1</span><br><span class="line">                minL +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 到这里，在 minL 索引 前的值都是小于等于 分界值的，在 minL 到 right - 1，包括 minL 的值都是大于 分界值的。 分界值一直在最后</span><br><span class="line">        &#x2F;&#x2F; 所以 把分界值 和 nums[minL] 交换位置</span><br><span class="line">        swap(&amp;nums, minL, right)</span><br><span class="line">        &#x2F;&#x2F; 返回分界值所在的 位置</span><br><span class="line">        return minL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func swap(_ nums: inout [Int], _ a: Int, _ b: Int) &#123;</span><br><span class="line">        let temp &#x3D; nums[a]</span><br><span class="line">        nums[a] &#x3D; nums[b]</span><br><span class="line">        nums[b] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序-迭代解法"><a href="#快速排序-迭代解法" class="headerlink" title="快速排序 迭代解法"></a>快速排序 迭代解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">         var nums &#x3D; nums</span><br><span class="line">        sort(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        &#x2F;&#x2F; 取中间值 做为当前的 分界值</span><br><span class="line">        let pivot &#x3D; nums[(right - left) &#x2F; 2 + left]</span><br><span class="line">        var L &#x3D; left</span><br><span class="line">        var R &#x3D; right</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; L &lt; R 说明 L 和 R 没相遇</span><br><span class="line">        while L &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 左边的数小于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从左往右  所以 L +&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数大于 pivot ， 那么跳出这个循环 且这个数的索引位 L</span><br><span class="line"></span><br><span class="line">            while nums[L] &lt; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 右边的数大于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从右往左 所以 R -&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数小于 pivot ， 那么跳出这个循环 且这个数的索引位 R</span><br><span class="line"></span><br><span class="line">            while nums[R] &gt; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; L &gt;&#x3D; R 说明 pivot 左边已经是 全部小于等于 pivot ，右边 全部是 大于等于 pivot。 可以提前退出</span><br><span class="line">            if L &gt;&#x3D; R &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 跳出了上边的两个循环之后 说明 分别找到了</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 左边，但大于等于 pivot 的数，它的索引为 L</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 右边，但小于等于 pivot 的数，它的索引位 R</span><br><span class="line">            &#x2F;&#x2F; 那么交换这两个数的位置</span><br><span class="line"></span><br><span class="line">            let temp &#x3D; nums[L]</span><br><span class="line">            nums[L] &#x3D; nums[R]</span><br><span class="line">            nums[R] &#x3D; temp</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 交换完后 nums[L] 是小于等于 pivot, nums[R] 是大于等于 pivot</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[L] &#x3D;&#x3D; pivot 了,要让 R -&#x3D; 1，</span><br><span class="line">            if nums[L] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[R] &#x3D;&#x3D; pivot 了,要让 L +&#x3D; 1</span><br><span class="line">            if nums[R] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果不处理 交换完后 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 的情况，</span><br><span class="line">            &#x2F;&#x2F; 当 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 都是 true 时，</span><br><span class="line">            &#x2F;&#x2F; 上边的两个 while 也不会在执行了， 那么 L 和 R 的数值也不会再发生变化 就卡死在这里了</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 到这里 L &gt;&#x3D; R 说明相遇了</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 左边的数都是 小于等于 pivot 的</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 右边的数都是 大于等于 pivot 的</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这一步是防止对 pivot 左右分别操作时越界</span><br><span class="line">        if L &#x3D;&#x3D; R &#123;</span><br><span class="line">            L +&#x3D; 1</span><br><span class="line">            R -&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if left &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 左边的数据</span><br><span class="line">            sort(&amp;nums, left, R)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if right &gt; L &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 右边的数据</span><br><span class="line">            sort(&amp;nums, L, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子序和-简单</title>
    <url>/2021/02/23/2000-007-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a class="link"   href="https://leetcode-cn.com/problems/maximum-subarray/" >53. 最大子序和<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/o6raa6.png"
                      alt="53. 最大子序和"
                ></p>
<h1 id="动态规划-解法"><a href="#动态规划-解法" class="headerlink" title="动态规划 解法"></a>动态规划 解法</h1><ul>
<li>时间复杂度 O(n)<br>一次遍历，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li>
<li>空间复杂度 O(1)<br>只开辟了两个额外的空间，即只需要常数空间存放若干变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func maxSubArray(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为和</span><br><span class="line">        var sum &#x3D; nums[0]</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为当前最大值</span><br><span class="line">        var ans &#x3D; nums[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 因为已经把 nums[0] 计算了，所以从 nums[1] 开始</span><br><span class="line">        for i in 1 ..&lt; nums.count &#123;</span><br><span class="line">            if sum &lt; 0 &#123; &#x2F;&#x2F; 如果 sum 小于 0 ，那么 sum + nums[i] 只会让 nums[i] 更小</span><br><span class="line">                sum &#x3D; nums[i] &#x2F;&#x2F; 所以接把 num[i] 赋值给 sum</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; sum &gt;&#x3D; 0 那么就直接加 nums[i] 不用考虑 nums[i] 是大于零 还是小于零</span><br><span class="line">                sum &#x3D; sum + nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; (sum &gt; ans) ? sum : ans</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>144. 二叉树的前序遍历 - 中等</title>
    <url>/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" >144. 二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p>
<p>二叉树的前序遍历 根 左 右</p>
<p>当根节点不为空时,直接把 root.val add list</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        preorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func preorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        preorder(root.left, &amp;list)</span><br><span class="line">        preorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>94. 二叉树的中序遍历 - 中等</title>
    <url>/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p>
<p>二叉树中序遍历顺序为 左 根 右<br>当根节点的左子树为空时添加该根节点，即在 root.left = nil, 后 add root.val</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度 O(n)<br>空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        inorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func inorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 中序遍历 左 中 右</span><br><span class="line">        &#x2F;&#x2F; 即中序遍历，左根右。当根结点的左子树为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即前序遍历，根左右。当根节点不为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即后序遍历，左右根。当根节点的左右子树均为空时，那么 add root.val</span><br><span class="line">        inorder(root.left, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        inorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul>
<li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度 O(n)<br>空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var tempList: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line"></span><br><span class="line">        while root !&#x3D; nil || !tempList.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                tempList.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; tempList.popLast()</span><br><span class="line">            list.append(root!.val)</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>145. 二叉树的后序遍历 - 中等</title>
    <url>/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" >145. 二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p>
<p>二叉树的后序遍历 左 右 根</p>
<p>当根节点的左右子树均为空的时候 add root.val</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func postorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        postorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func postorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        postorder(root.left, &amp;list)</span><br><span class="line">        postorder(root.right, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="真迭代解法"><a href="#真迭代解法" class="headerlink" title="真迭代解法"></a>真迭代解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func postorderTraversal1(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 用来记录回退的根节点 在回退的时候 要判断这个是不是刚刚回退的节点 如果不加判断会死循环</span><br><span class="line">        var lastTree: TreeNode?</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; root.right &#x3D;&#x3D; nil 时做下列操作很容易理解</span><br><span class="line">            if root?.right &#x3D;&#x3D; nil || root?.right &#x3D;&#x3D;&#x3D; lastTree &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                &#x2F;&#x2F; 这个时候要回退了，所以先记录当前的这个节点</span><br><span class="line">                lastTree &#x3D; root</span><br><span class="line">                &#x2F;&#x2F; 要把 root 置 nil 进行回退， 否则又是死循环</span><br><span class="line">                root &#x3D; nil</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="假后序解法"><a href="#假后序解法" class="headerlink" title="假后序解法"></a>假后序解法</h1><ul>
<li>时间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。 一个 n 是所有节点的遍历，另一个是最后的反转</li>
<li>空间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。一个 n 是迭代栈的开销，一个是最后反转的开销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func postorderTraversal2(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 后序遍历的顺序是  左右根</span><br><span class="line">        &#x2F;&#x2F; 反转后是 根右左，和前序遍历的 根左右 很像</span><br><span class="line">        &#x2F;&#x2F; 所以来用前序遍历的变形写法，然后把得的数据反转就行了</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.reversed()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>155. 最小栈 - 简单</title>
    <url>/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a class="link"   href="https://leetcode-cn.com/problems/min-stack/" >155. 最小栈<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/g135og.png"
                      alt="155. 最小栈"
                ></p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ul>
<li>时间复杂度<br>对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是<br>O(1)，我们定义的每个操作最多调用栈操作两次。</li>
<li>空间复杂度<br>其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;记录当前最小值</span><br><span class="line">    var minNum: Int?</span><br><span class="line">    &#x2F;&#x2F;只存最小值</span><br><span class="line">    var minNums: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    func push(_ x: Int) &#123;</span><br><span class="line">        list.append(x)</span><br><span class="line">        minNum &#x3D; min(minNum ?? .max, x)</span><br><span class="line">        if minNum &#x3D;&#x3D; x &#123;</span><br><span class="line">            minNums.append(minNum!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func pop() &#123;</span><br><span class="line">        let p &#x3D; list.removeLast()</span><br><span class="line">        if minNum &#x3D;&#x3D; p &#123;</span><br><span class="line">            minNum &#x3D; list.min()</span><br><span class="line">            minNums.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func top() -&gt; Int &#123;</span><br><span class="line">        return list.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getMin() -&gt; Int &#123;</span><br><span class="line">        return minNums.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>112. 路径总和 - 简单</title>
    <url>/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a class="link"   href="https://leetcode-cn.com/problems/path-sum/" >112. 路径总和<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/lxqfb4.png"
                      alt="112. 路径总和"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n),每个节点都要访问一次</li>
<li>空间复杂度<br>O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        if root.left &#x3D;&#x3D; nil, root.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">            return root.val &#x3D;&#x3D; targetSum</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 递归每次用当前的 sum - 当前 root.val</span><br><span class="line">        &#x2F;&#x2F; 一直 减减减 减到 叶子节点， 就判断当前的 sum 和 root.val 是否相等即可</span><br><span class="line">        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="广度优先解法"><a href="#广度优先解法" class="headerlink" title="广度优先解法"></a>广度优先解法</h1><ul>
<li>时间复杂度<br>O(n),每个节点都要访问一次</li>
<li>空间复杂度<br>O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; &#x2F;&#x2F; 如果 root &#x3D; nil 那么就一定不存在了</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var stackTree: [TreeNode] &#x3D; [root]</span><br><span class="line">        var treeVal: [Int] &#x3D; [root.val]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;           1</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;   \</span><br><span class="line">        &#x2F;&#x2F;        2     3</span><br><span class="line">        &#x2F;&#x2F;       &#x2F; \    &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;      4   5   6  7</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 1 添加 2 3,同时 treeVal 移除 1.val 添加 1+2.val ，1+3.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 2 添加 4 5,同时 treeVal 移除 2.val 添加 2+4.val ，2+5.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 3 添加 6 7,同时 treeVal 移除 3.val 添加 3+6.val ，3+7.val</span><br><span class="line">        while !stackTree.isEmpty &#123;</span><br><span class="line">            let tree: TreeNode &#x3D; stackTree.popLast()!</span><br><span class="line">            let sum &#x3D; treeVal.popLast()</span><br><span class="line">            if tree.left &#x3D;&#x3D; nil, tree.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">                if sum &#x3D;&#x3D; targetSum &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.left !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.left!)</span><br><span class="line">                treeVal.append(sum! + tree.left!.val)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.right !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.right!)</span><br><span class="line">                treeVal.append(sum! + tree.right!.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字 - 简单</title>
    <url>/2021/02/24/2000-013-%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a class="link"   href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" >剑指 Offer 11. 旋转数组的最小数字<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ftp.bmp.ovh/imgs/2021/02/f8daa4e0fade64f3.png"
                      alt="剑指 Offer 11. 旋转数组的最小数字"
                ></p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li>时间复杂度<br>O(log n) 在二分查找的过程中，大部分情况都会忽略一半的区间。</li>
<li>空间复杂度<br>O(1)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return numbers[0]</span><br><span class="line">        &#125;</span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; numbers.count - 1</span><br><span class="line">        while right &gt; left &#123;</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if numbers[mid] &gt; numbers[right] &#123;</span><br><span class="line">                &#x2F;&#x2F; numbers[mid] &gt; numbers[right] mid 已经大于 right 所以 mid 不应该包含在区间内  所以 mid + 1</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            &#125; else if numbers[mid] &lt; numbers[right] &#123;</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;  mid 和 left right 相等的情况， 就让right -&#x3D;1</span><br><span class="line">                right -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[left]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="一次遍历法"><a href="#一次遍历法" class="headerlink" title="一次遍历法"></a>一次遍历法</h1><ul>
<li>时间复杂度<br>O(n)</li>
<li>空间复杂度<br>O(1)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        var ans &#x3D; numbers[0]</span><br><span class="line">        for item in numbers &#123;</span><br><span class="line">            ans &#x3D; min(ans, item)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>81. 搜索旋转排序数组 II - 中等</title>
    <url>/2021/02/24/2000-014-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    <content><![CDATA[<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" >81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/pwhsby.png"
                      alt="81. 搜索旋转排序数组 II"
                ></p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li><p>时间复杂度<br>O(n) 大多情况下每次都减少一般的数据</p>
</li>
<li><p>空间复杂度<br>O(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func search(_ nums: [Int], _ target: Int) -&gt; Bool &#123;</span><br><span class="line">      if nums.isEmpty &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">          return nums[0] &#x3D;&#x3D; target</span><br><span class="line">      &#125;</span><br><span class="line">      var left &#x3D; 0</span><br><span class="line">      var right &#x3D; nums.count - 1</span><br><span class="line">      &#x2F;&#x2F; [1, 2]</span><br><span class="line">      &#x2F;&#x2F; 必须是 &gt;&#x3D; 会存在 到最后左右指针相遇 才找到 目标值的情况</span><br><span class="line">      while right &gt;&#x3D; left &#123;</span><br><span class="line">          let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">          if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">              return true</span><br><span class="line">          &#125;</span><br><span class="line">          if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">              if nums[mid] &lt; target, target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if nums[mid] &gt; nums[right] &#123;</span><br><span class="line">              if nums[left] &lt;&#x3D; target, target &lt; nums[mid] &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              right -&#x3D; 1</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return false</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>236. 二叉树的最近公共祖先 - 中等</title>
    <url>/2021/02/24/2000-015-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" >236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/8s3kd1.png"
                      alt="236. 二叉树的最近公共祖先"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) 其中 N 是二叉树的节点数，所有节点都会被访问一次。</li>
<li>空间复杂度<br>O(n) 其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var commTree: TreeNode?</span><br><span class="line"></span><br><span class="line">    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        _ &#x3D; dfs(root, p, q)</span><br><span class="line">        return commTree</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfs(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        &#x2F;&#x2F; 左子树是否包含 q 或 q</span><br><span class="line">        let lson &#x3D; dfs(root.left, p, q)</span><br><span class="line">        &#x2F;&#x2F; 右子树是否包含 q 或 q</span><br><span class="line">        let rson &#x3D; dfs(root.right, p, q)</span><br><span class="line">        &#x2F;&#x2F; 左右子树包含pq || (左子树或右子树包含 且 当前root.val &#x3D;&#x3D; p.val 或 q.val)</span><br><span class="line">        if (lson &amp;&amp; rson) || ((lson || rson) &amp;&amp; (root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val)) &#123;</span><br><span class="line">            commTree &#x3D; root</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果包含 p q, 会先命中 root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val</span><br><span class="line">        &#x2F;&#x2F; 这时返回的值是 true, 后面 会命中 lson || rson</span><br><span class="line">        return root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val || lson || rson</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>70. 爬楼梯 - 简单</title>
    <url>/2021/02/24/2000-016-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a class="link"   href="https://leetcode-cn.com/problems/climbing-stairs/" >70. 爬楼梯<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/kmucz8.png"
                      alt="70. 爬楼梯"
                ></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li>时间复杂度<br>O(n) n 是输入的，循环执行 n 次</li>
<li>空间复杂度<br>O(1) 只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; n ans</span><br><span class="line">&#x2F;&#x2F; 1  1</span><br><span class="line">&#x2F;&#x2F; 2  2</span><br><span class="line">&#x2F;&#x2F; 3  3</span><br><span class="line">&#x2F;&#x2F; 4  5</span><br><span class="line">&#x2F;&#x2F;( n 的 ans) &#x3D; (n-1 的 ans) + (n-2 的 ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func climbStairs(_ n: Int) -&gt; Int &#123;</span><br><span class="line">        var b1 &#x3D; 0</span><br><span class="line">        var b2 &#x3D; 1</span><br><span class="line">        var ans &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for _ in 1 ... n &#123;</span><br><span class="line">            ans &#x3D; b1 + b2</span><br><span class="line">            b1 &#x3D; b2</span><br><span class="line">            b2 &#x3D; ans</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树 - 中等</title>
    <url>/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/zn7zcr.png"
                      alt="105. 从前序与中序遍历序列构造二叉树"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 是节点的个数，每个节点都访问一次</li>
<li>空间复杂度<br>O(n) 除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var inorderMap: [Int: Int] &#x3D; [:]</span><br><span class="line"></span><br><span class="line">    func buildTree(_ preorder: [Int], _ inorder: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">        let count &#x3D; preorder.count</span><br><span class="line">        &#x2F;&#x2F; 这一步是为了节省时间 但是增加了空间占用</span><br><span class="line">        for (index, val) in inorder.enumerated() &#123;</span><br><span class="line">            inorderMap[val] &#x3D; index</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, count - 1, 0, count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func myBuildTree(_ preorder: [Int], _ inorder: [Int], _ preorderLeft: Int, _ preorderRight: Int, _ inorderLeft: Int, _ inorderRight: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if preorderLeft &gt; preorderRight &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 前序遍历的第一个节点就是根节点</span><br><span class="line">        let preorderRoot &#x3D; preorderLeft</span><br><span class="line">        &#x2F;&#x2F; 找出中序遍历的根节点位置</span><br><span class="line">        let inorderRoot &#x3D; inorderMap[preorder[preorderRoot]]!</span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        let root &#x3D; TreeNode(preorder[preorderRoot])</span><br><span class="line">        &#x2F;&#x2F; 左子树的节点数目</span><br><span class="line">        let leftTreeCount &#x3D; inorderRoot - inorderLeft</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderLeft + 1 开始的 leftTreeCount 个元素就是 当前 root 左子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderLeft 开始到 inorderRoot - 1]  就是当前 root 左子树的 所有节点</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorderLeft + 1, preorderLeft + leftTreeCount, inorderLeft, inorderRoot - 1)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderRoot + 1(这个1是根节点的长度) + leftTreeCount 到 preorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderRoot + 1 到 inorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorderRoot + 1 + leftTreeCount, preorderRight, inorderRoot + 1, inorderRight)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>226. 翻转二叉树 - 简单</title>
    <url>/2021/02/24/2000-017-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/invert-binary-tree/" >226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/spum89.png"
                      alt="226. 翻转二叉树"
                ></p>
<h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul>
<li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从根节点开始反转的</span><br><span class="line">    func invertTree2(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">        var treeRoot &#x3D; root</span><br><span class="line">        let ansRoot &#x3D; root</span><br><span class="line">        var list: [TreeNode] &#x3D; [treeRoot]</span><br><span class="line">        while !list.isEmpty &#123;</span><br><span class="line">            treeRoot &#x3D; list.popLast()!</span><br><span class="line">            let temp &#x3D; treeRoot.right</span><br><span class="line">            treeRoot.right &#x3D; treeRoot.left</span><br><span class="line">            treeRoot.left &#x3D; temp</span><br><span class="line">            if treeRoot.left !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.left!)</span><br><span class="line">            &#125;</span><br><span class="line">            if treeRoot.right !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.right!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ansRoot</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从叶子节点开始反转的</span><br><span class="line">    func invertTree(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        let left &#x3D; invertTree(root.left)</span><br><span class="line">        let right &#x3D; invertTree(root.right)</span><br><span class="line">        root.left &#x3D; right</span><br><span class="line">        root.right &#x3D; left</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <url>/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var treeList: [TreeNode] &#x3D; [root]</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempList: [TreeNode] &#x3D; []</span><br><span class="line">            for tree in treeList &#123;</span><br><span class="line">                valList.append(tree.val)</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(valList)</span><br><span class="line">            treeList &#x3D; tempList</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <url>/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a class="link"   href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line">        var listTree: [TreeNode] &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        var isLR &#x3D; false</span><br><span class="line">        while !listTree.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempTree: [TreeNode] &#x3D; []</span><br><span class="line">            isLR &#x3D; !isLR</span><br><span class="line">            for tree in listTree &#123;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">                if isLR &#123;</span><br><span class="line">                    valList.append(tree.val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    valList.insert(tree.val, at: 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listTree &#x3D; tempTree</span><br><span class="line">            ans.append(valList)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>199. 二叉树的右视图</title>
    <url>/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >199. 二叉树的右视图<i class="fas fa-external-link-alt"></i></a></h1><h1 id="解法一-BFS-广度优先-层序遍历"><a href="#解法一-BFS-广度优先-层序遍历" class="headerlink" title="解法一 BFS 广度优先 层序遍历"></a>解法一 BFS 广度优先 层序遍历</h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [Int] &#x3D; []</span><br><span class="line">        var treeList &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            let count &#x3D; treeList.count</span><br><span class="line">            for i in 0 ..&lt; count &#123;</span><br><span class="line">                let tree &#x3D; treeList.remove(at: 0)</span><br><span class="line">                if i &#x3D;&#x3D; count - 1 &#123;</span><br><span class="line">                    ans.append(tree.val)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="解法二-DFS-深度优先-前序遍历-变形"><a href="#解法二-DFS-深度优先-前序遍历-变形" class="headerlink" title="解法二 DFS 深度优先 前序遍历 变形"></a>解法二 DFS 深度优先 前序遍历 变形</h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ans: [Int] &#x3D; []</span><br><span class="line">    func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        dfsSlideView(root, 0)</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfsSlideView(_ root: TreeNode?, _ depth: Int) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        if depth &#x3D;&#x3D; ans.count &#123;</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        let d &#x3D; depth + 1</span><br><span class="line">        dfsSlideView(root.right, d)</span><br><span class="line">        dfsSlideView(root.left, d)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>树、二叉树、二叉搜索树</title>
    <url>/2021/02/06/2000-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树-LeetCode"><a href="#二叉树-LeetCode" class="headerlink" title="二叉树 LeetCode"></a><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树 LeetCode<i class="fas fa-external-link-alt"></i></a></h1><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote>
<p>是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图</p>
</blockquote>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><blockquote>
<p>是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
</blockquote>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><blockquote>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
</blockquote>
<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>二叉树</tag>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算 &lt;&lt;"></a>左移运算 &lt;&lt;</h1><p>3 &lt;&lt; 2，则是将数字 3 左移 2 位</p>
<h2 id="计算过程："><a href="#计算过程：" class="headerlink" title="计算过程："></a>计算过程：</h2><p>3 &lt;&lt; 2 首先把 3 转换为二进制数字 0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移 2 位，最后在低位(右侧)的两个空位补零。则得到的最终结果是 0000 1100，则转换为十进制是 12。</p>
<h2 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义:"></a>数学意义:</h2><p>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。</p>
<h1 id="amp-与运算"><a href="#amp-与运算" class="headerlink" title="&amp; 与运算"></a>&amp; 与运算</h1><p>参加运算的两个数据，按二进制位进行“与”运算。<br>运算规则：0&amp;0=0;0&amp;1=0;1&amp;0=0;1&amp;1=1;<br>即：两位同时为“1”，结果才为“1”，否则为 0<br>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3&amp;5 的值得 1。</p>
<h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>用 2 整除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为小于 1 时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p>
<blockquote>
<p><a class="link"   href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6" >https://baike.baidu.com/item/二进制<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 基础之 类、set、get、构造函数、方法</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h1 id="类、属性、方法"><a href="#类、属性、方法" class="headerlink" title="类、属性、方法"></a>类、属性、方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;名字:$name 年龄:$age&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="默认构造函数、初始化列表"><a href="#默认构造函数、初始化列表" class="headerlink" title="默认构造函数、初始化列表"></a>默认构造函数、初始化列表</h1><blockquote>
<p>存在初始化列表就不能存在默认构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F;默认构造函数 简写</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认构造函数 全写</span><br><span class="line">  Person(String name, int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化列表</span><br><span class="line">  Person()</span><br><span class="line">      : name &#x3D; &#39;李华&#39;,</span><br><span class="line">        age &#x3D; 22 &#123;</span><br><span class="line">    print(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="匿名构造函数"><a href="#匿名构造函数" class="headerlink" title="匿名构造函数"></a>匿名构造函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  Person.newPeople() &#123;</span><br><span class="line">    name &#x3D; &quot;李四&quot;;</span><br><span class="line">    age &#x3D; 33;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 带参数匿名构造函数</span><br><span class="line">  Person.new2(String name, int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="私有属性、私有方法、set方法、get方法"><a href="#私有属性、私有方法、set方法、get方法" class="headerlink" title="私有属性、私有方法、set方法、get方法"></a>私有属性、私有方法、set方法、get方法</h1><blockquote>
<p>私有属性、私有方法  这个类必须单独在一个文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  var _money &#x3D; 999999;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK:set 方法</span><br><span class="line">  set gongzi(int value) &#123;</span><br><span class="line">    _money &#x3D; _money + value;</span><br><span class="line">    _printMoney();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK:get方法</span><br><span class="line">  int get money &#123;</span><br><span class="line">    return _money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK:   私有方法 这个类必须单独在一个文件</span><br><span class="line">  _printMoney() &#123;</span><br><span class="line">    print(money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 静态属性、静态方法</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F;MARK: 静态属性</span><br><span class="line">  static String name &#x3D; &#39;张三&#39;;</span><br><span class="line">  int age &#x3D; 20;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;MARK:静态方法</span><br><span class="line">  static getInfo() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">    &#x2F;&#x2F; print(age);  静态方法内部不能反问非静态属性</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printInfo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 非静态方法 可以访问静态成员与非静态 包括方法</span><br><span class="line">    getInfo();</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart ？可选操作 类型判断、类型转换、联缀</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%803/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;名字：$name  年龄：$age&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="？-可选操作符"><a href="#？-可选操作符" class="headerlink" title="？ 可选操作符"></a>？ 可选操作符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p2;</span><br><span class="line">&#x2F;&#x2F; p2.getInfo();  p2 未初始化  可使用 ？ 可选符操作</span><br><span class="line">&#x2F;&#x2F;MARK:     可选操作符</span><br><span class="line">p2?.getInfo();</span><br></pre></td></tr></table></figure>

<h1 id="is-操作符-类型判断"><a href="#is-操作符-类型判断" class="headerlink" title="is 操作符 类型判断"></a>is 操作符 类型判断</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 &#x3D; Person();</span><br><span class="line">&#x2F;&#x2F;MARK: is  操作符    类型判断</span><br><span class="line">  if (p1 is Person) &#123;</span><br><span class="line">    print(&#39;p1 是 person&#39;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="as-操作符-类型转换"><a href="#as-操作符-类型转换" class="headerlink" title="as 操作符 类型转换"></a>as 操作符 类型转换</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p3;</span><br><span class="line">p3 &#x3D; Person();</span><br><span class="line">&#x2F;&#x2F; p3.name;   虽然没报错  但是不知道 p3 类型</span><br><span class="line">(p3 as Person).name &#x3D; &#39;王麻子&#39;;</span><br><span class="line">(p3 as Person).age &#x3D; 11;</span><br><span class="line">(p3 as Person).getInfo();</span><br></pre></td></tr></table></figure>

<h1 id="联缀操作符"><a href="#联缀操作符" class="headerlink" title=".. 联缀操作符"></a>.. 联缀操作符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .. 联缀 操作符</span><br><span class="line">  Person p4 &#x3D; Person();</span><br><span class="line">  p4</span><br><span class="line">    ..name &#x3D; &#39;哈哈哈&#39;</span><br><span class="line">    ..age &#x3D; 40</span><br><span class="line">    ..getInfo();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 类的继承</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%804/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;$name    ---   $age&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    print(&quot;object 努力学习&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="继承、重写父类方法"><a href="#继承、重写父类方法" class="headerlink" title="继承、重写父类方法"></a>继承、重写父类方法</h1><blockquote>
<p>使用 extends 关键字继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Zp extends Person &#123;</span><br><span class="line">  String sex;</span><br><span class="line">  Zp(String name, int age, [String sex &#x3D; &#39;男&#39;]) : super(name, age) &#123;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  faGongZi(&#123;int money&#125;) &#123;</span><br><span class="line">    print(&#39;发工资了 $money&#39;);</span><br><span class="line">    super.work();</span><br><span class="line">    work();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK: 重写父类方法</span><br><span class="line">  @override</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;$name 今年 $age  很有钱&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 多继承</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%806/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  printA() &#123;</span><br><span class="line">    print(&#39;AAAAA&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;A run&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  printB() &#123;</span><br><span class="line">    print(&#39;BBBBBBBBB&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; B.bbb()&#123;&#125;    作为 minxins 的类不能有构造函数</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;B run&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mixins-混入"><a href="#mixins-混入" class="headerlink" title="mixins 混入"></a>mixins 混入</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MARK:   mixins 的必须是单独的一个object 类 A不能继承于其他类</span><br><span class="line">class Z with A, B &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="继承-mixins-混入"><a href="#继承-mixins-混入" class="headerlink" title="继承 + mixins 混入"></a>继承 + mixins 混入</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class X extends Person with A, B &#123;</span><br><span class="line">  X.aa() : super.aa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-和-B-共有的方法后继承的覆盖之前的"><a href="#A-和-B-共有的方法后继承的覆盖之前的" class="headerlink" title="A 和 B 共有的方法后继承的覆盖之前的"></a>A 和 B 共有的方法后继承的覆盖之前的</h1>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart abstract 抽象类</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%805/</url>
    <content><![CDATA[<h1 id="抽象类-相当于协议-接口"><a href="#抽象类-相当于协议-接口" class="headerlink" title="抽象类 相当于协议 接口"></a>抽象类 相当于协议 接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  &#x2F;&#x2F;抽象方法 只有方法名 没有具体实现</span><br><span class="line">  run();</span><br><span class="line"></span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;普通方法&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Animal-an-Animal-抽象类-不能被实例化"><a href="#Animal-an-Animal-抽象类-不能被实例化" class="headerlink" title="Animal an = Animal();   //抽象类 不能被实例化"></a>Animal an = Animal();   //抽象类 不能被实例化</h2><h1 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h1><blockquote>
<p>继承自抽象类必须实现抽象方法     继承自抽象类的属性不是必须实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;小狗跑&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="implements-声明、with"><a href="#implements-声明、with" class="headerlink" title="implements 声明、with"></a>implements 声明、with</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat implements Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;我是🐱&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;小🐱跑的快&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck with Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;小鸭跑&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 泛型</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%807/</url>
    <content><![CDATA[<h1 id="方法添加泛型"><a href="#方法添加泛型" class="headerlink" title="方法添加泛型"></a>方法添加泛型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T getData&lt;T&gt;(T value) &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类添加泛型"><a href="#类添加泛型" class="headerlink" title="类添加泛型"></a>类添加泛型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Pppp&lt;T&gt; &#123;</span><br><span class="line">  var list &#x3D; List&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  add(T) &#123;</span><br><span class="line">    list.add(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printList() &#123;</span><br><span class="line">    print(list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="泛型-接口"><a href="#泛型-接口" class="headerlink" title="泛型 接口"></a>泛型 接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class ABC&lt;T&gt; &#123;</span><br><span class="line">  addObject(String key);</span><br><span class="line">  setValue(String key, T value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实现泛型接口"><a href="#实现泛型接口" class="headerlink" title="实现泛型接口"></a>实现泛型接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Wq&lt;T&gt; implements ABC&lt;T&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  addObject(String key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  setValue(String key, T value) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 导入库</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%808/</url>
    <content><![CDATA[<blockquote>
<p>如果库冲突了 使用 as 重命名   show 导入部分  hide不导入的部分</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;XXX.dart&#39; as lib show Person;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 开发错误 StatefulWidget createState must return a subtype of State</title>
    <url>/2020/12/01/400-Flutter-%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF-StatefulWidget-createState-must-return-a-subtype-of-State/</url>
    <content><![CDATA[<p>报错如下:</p>
<p>StatefulWidget.createState must return a subtype of State</p>
<p>The createState function for XXXX2 returned a state of type _XXXXState, which is not a subtype of State<XXXX2>, violating the contract for createState.</p>
<p>错误分析：<br>其实就是返回的 Widget 类型不对，<br>大意了，修改正确即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-a44eecc36a9468ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="错误图"
                ></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 本地图片配置工具 FlutterGen</title>
    <url>/2020/12/02/400-Flutter-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7-FlutterGen/</url>
    <content><![CDATA[<h1 id="github-gt-FlutterGen"><a href="#github-gt-FlutterGen" class="headerlink" title="github -&gt; FlutterGen"></a><a class="link"   href="https://github.com/FlutterGen" >github -&gt; FlutterGen<i class="fas fa-external-link-alt"></i></a></h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 推荐使用 Homebrew 安装</span><br><span class="line">$ brew install FlutterGen&#x2F;tap&#x2F;fluttergen</span><br></pre></td></tr></table></figure>

<p>#使用前先把 assets: 配置好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets:</span><br><span class="line">    - assets&#x2F;images&#x2F;cat.png</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fluttergen -c example&#x2F;pubspec.yaml</span><br></pre></td></tr></table></figure>

<h1 id="VSCode-中-终端使用"><a href="#VSCode-中-终端使用" class="headerlink" title="VSCode 中 终端使用"></a>VSCode 中 终端使用</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-645686099e6124e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="VSCode"
                ></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 工程修复</title>
    <url>/2020/12/04/400-Flutter%E5%B7%A5%E7%A8%8B%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>Flutter工程 误删iOS、误删Android等文件时</p>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开终端输入</span><br><span class="line">flutter create 工程目录</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 配置相关</title>
    <url>/2020/12/03/400-Flutter-%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><blockquote>
<p>CocoaPods requires your terminal to be using UTF-8 encoding<br>Consider adding the following to ~/.profile:<br>export LANG=en_US.UTF-8</p>
</blockquote>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.打开终端 输入命令open -e .bash_profile</span><br><span class="line">2.在终端输入 export LANG&#x3D;en_US.UTF-8 保存</span><br><span class="line">3.重启VSCode</span><br><span class="line"></span><br><span class="line">⚠️⚠️安装zsh导致全局配置还不行的话⚠️⚠️</span><br><span class="line">1. vim ~&#x2F;.zshrc</span><br><span class="line">2. 按E进入编辑 （大写E）</span><br><span class="line">3. 在最后一行加入  export LANG&#x3D;en_US.UTF-8</span><br><span class="line">4. 按ESC退出编辑  键入 :wq 保存退出</span><br><span class="line">5. 重启VSCode</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><blockquote>
<p>-bash: flutter: command not found</p>
</blockquote>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.打开终端 输入命令open -e .bash_profile</span><br><span class="line">2.在终端输入 </span><br><span class="line"></span><br><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;Users&#x2F;(你的用户名)&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;Users&#x2F;(你的用户名)&#x2F;flutter&#x2F;bin</span><br><span class="line">export NO_PROXY&#x3D;localhost,127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.终端输入 source ~&#x2F;.bash_profile保存</span><br><span class="line"></span><br><span class="line">⚠️⚠️安装zsh导致全局配置还不行的话⚠️⚠️</span><br><span class="line">1. vim ~&#x2F;.zshrc</span><br><span class="line">2. 按E进入编辑 （大写E）</span><br><span class="line">3. 在最后一行加入  </span><br><span class="line">export PATH&#x3D;&#x2F;Users&#x2F;z&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">export NO_PROXY&#x3D;localhost,127.0.0.1</span><br><span class="line"></span><br><span class="line">4. 按ESC退出编辑  键入 :wq 保存退出</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 AspectRatio、Card</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6AspectRatio%E3%80%81Card/</url>
    <content><![CDATA[<h1 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h1><blockquote>
<p>设置自身比例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AspectRatio(</span><br><span class="line">        aspectRatio: 5.0 &#x2F; 1.0,</span><br><span class="line">        child: Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            &#39;AspectRatio 宽高比 5&#x2F;1&#39;,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            style: TextStyle(fontSize: 30),</span><br><span class="line">          ),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>

<h1 id="Card"><a href="#Card" class="headerlink" title="Card"></a>Card</h1><blockquote>
<p>卡片样式</p>
</blockquote>
<p>```<br>Card(<br>      margin: EdgeInsets.all(10),<br>      shape: RoundedRectangleBorder(<br>          side: BorderSide(color: Colors.orange, width: 2),<br>          borderRadius: BorderRadius.circular(10)),<br>      child: Column(<br>        children: [<br>          AspectRatio(<br>            aspectRatio: 16 / 9,<br>            child: Image.network(<br>              randomImgSrc(),<br>              fit: BoxFit.cover,<br>            ),<br>          ),<br>          Padding(<br>            padding: EdgeInsets.all(12),<br>            child: Row(<br>              crossAxisAlignment: CrossAxisAlignment.baseline,<br>              children: [<br>                ClipOval(<br>                  child: Image.network(randomImgSrc(),<br>                      width: 60, fit: BoxFit.cover),<br>                ),<br>                Container(<br>                  padding: EdgeInsets.fromLTRB(10, 0, 0, 0),<br>                  height: 60,<br>                  child: Stack(<br>                    children: [<br>                      Align(<br>                        alignment: Alignment.topLeft,<br>                        child: Text(<br>                          ‘我是一只大猫’,<br>                          style: TextStyle(<br>                              fontWeight: FontWeight.bold, fontSize: 22),<br>                        ),<br>                      ),<br>                      Align(<br>                        alignment: Alignment.bottomLeft,<br>                        child: Text(‘啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦’),<br>                      )<br>                    ],<br>                  ),<br>                ),<br>                CircleAvatar(<br>                  backgroundImage: NetworkImage(randomImgSrc()),<br>                ),<br>              ],<br>            ),<br>          ),<br>        ],<br>      ),<br>    );<br>``</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 依赖库查询</title>
    <url>/2020/12/05/400-Flutter%E6%9F%A5%E8%AF%A2%E4%BE%9D%E8%B5%96%E5%BA%93%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p>地址为 <a class="link"   href="https://pub.flutter-io.cn/packages" >https://pub.flutter-io.cn/packages<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p><a class="link"   href="https://pub.flutter-io.cn/packages" >点我前往查询<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 BottomNavigationBar</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6BottomNavigationBar/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int index &#x3D; 0;</span><br><span class="line">var pages &#x3D; [HomePage(), SearchPage(), SetPage()];</span><br><span class="line">var titls &#x3D; [Text(&#39;首页&#39;), Text(&#39;搜索&#39;), Text(&#39;设置&#39;)];</span><br></pre></td></tr></table></figure>


<h1 id="BottomNavigationBar"><a href="#BottomNavigationBar" class="headerlink" title="BottomNavigationBar"></a>BottomNavigationBar</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BottomNavigationBar(</span><br><span class="line">        selectedItemColor: Colors.orangeAccent,</span><br><span class="line">        iconSize: 34,</span><br><span class="line">        &#x2F;&#x2F; type: BottomNavigationBarType.shifting,</span><br><span class="line">        unselectedItemColor: Colors.grey,</span><br><span class="line">        &#x2F;&#x2F; showSelectedLabels: false,</span><br><span class="line">        &#x2F;&#x2F; showUnselectedLabels: false,</span><br><span class="line">        currentIndex: index,</span><br><span class="line">        onTap: (index) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            this.index &#x3D; index;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        items: [</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">              icon: Icon(Icons.home),</span><br><span class="line">              label: &#39;首页&#39;,</span><br><span class="line">              activeIcon: Icon(</span><br><span class="line">                Icons.home,</span><br><span class="line">                color: Colors.orangeAccent,</span><br><span class="line">              )),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">              icon: Icon(Icons.search),</span><br><span class="line">              label: &#39;搜索&#39;,</span><br><span class="line">              activeIcon: Icon(</span><br><span class="line">                Icons.search,</span><br><span class="line">                color: Colors.orangeAccent,</span><br><span class="line">              )),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">              icon: Icon(Icons.settings),</span><br><span class="line">              label: &#39;设置&#39;,</span><br><span class="line">              activeIcon: Icon(</span><br><span class="line">                Icons.settings,</span><br><span class="line">                color: Colors.orangeAccent,</span><br><span class="line">              )),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter UI 组件 Container、Text</title>
    <url>/2020/12/28/400-Flutter%E7%BB%84%E4%BB%B6Container%E3%80%81Text/</url>
    <content><![CDATA[<blockquote>
<p>Text、Container 组件较为基础同时使用也很频繁，建议自行封装一套使用，避免每次都要输入很多属性。</p>
</blockquote>
<h1 id="Text-文本组件"><a href="#Text-文本组件" class="headerlink" title="Text 文本组件"></a>Text 文本组件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">      &#39;文本组件&#39;,</span><br><span class="line">      textAlign: TextAlign.center,</span><br><span class="line">      overflow: TextOverflow.ellipsis,</span><br><span class="line">      maxLines: 2,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">        fontSize: 20,</span><br><span class="line">        color: Colors.orange,</span><br><span class="line">        fontWeight: FontWeight.bold,</span><br><span class="line">        fontStyle: FontStyle.italic,</span><br><span class="line">        decoration: TextDecoration.underline,</span><br><span class="line">        decorationColor: Colors.black,</span><br><span class="line">        decorationStyle: TextDecorationStyle.dotted,</span><br><span class="line">        letterSpacing: 2,</span><br><span class="line">      ),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h1 id="Container-组件"><a href="#Container-组件" class="headerlink" title="Container 组件"></a>Container 组件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">      child: Text(&#39;Container 组件&#39;),</span><br><span class="line">      width: 300,</span><br><span class="line">      height: 300,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        color: Colors.redAccent,</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(18)),</span><br><span class="line">        border: Border.all(</span><br><span class="line">          color: Colors.blueAccent,</span><br><span class="line">          width: 7,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      &#x2F;&#x2F;内边距</span><br><span class="line">      padding: EdgeInsets.all(18),</span><br><span class="line">      &#x2F;&#x2F;外边距</span><br><span class="line">      margin: EdgeInsets.fromLTRB(50, 50, 0, 0),</span><br><span class="line">      &#x2F;&#x2F; transform: Matrix4.translationValues(100, 0, 0),</span><br><span class="line">      transform: Matrix4.rotationZ(0.1),</span><br><span class="line">      alignment: Alignment.bottomLeft,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 GridView</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6GridView/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">   var widgetList &#x3D; List&lt;Widget&gt;();</span><br><span class="line">   for (var i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">     var c &#x3D; Container(</span><br><span class="line">       &#x2F;&#x2F; alignment: Alignment.topCenter,</span><br><span class="line">       color: Colors.green[100],</span><br><span class="line">       child: Column(</span><br><span class="line">         children: [</span><br><span class="line">           Image(image: Assets.images.cat),</span><br><span class="line">           SizedBox(</span><br><span class="line">             height: 12,</span><br><span class="line">           ),</span><br><span class="line">           Text(</span><br><span class="line">             &#39;哈哈哈 $i&#39;,</span><br><span class="line">             textAlign: TextAlign.center,</span><br><span class="line">             style: TextStyle(fontSize: 24),</span><br><span class="line">           ),</span><br><span class="line">         ],</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">     widgetList.add(c);</span><br><span class="line">   &#125;</span><br><span class="line">   return widgetList;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="GridView-count"><a href="#GridView-count" class="headerlink" title="GridView.count"></a>GridView.count</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">      scrollDirection: Axis.vertical,</span><br><span class="line">      padding: EdgeInsets.fromLTRB(16, 20, 16, 20),</span><br><span class="line">      crossAxisCount: 2,</span><br><span class="line">      crossAxisSpacing: 8,</span><br><span class="line">      mainAxisSpacing: 10,</span><br><span class="line">      childAspectRatio: 0.8,</span><br><span class="line">      children: this._getData(),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h1 id="GridView-builder"><a href="#GridView-builder" class="headerlink" title="GridView.builder"></a>GridView.builder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridView.builder(</span><br><span class="line">      padding: EdgeInsets.all(10),</span><br><span class="line">      itemCount: _getData().length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        return _getData()[index];</span><br><span class="line">      &#125;,</span><br><span class="line">      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">        crossAxisCount: 2,</span><br><span class="line">        childAspectRatio: 0.8,</span><br><span class="line">        mainAxisSpacing: 10,</span><br><span class="line">        crossAxisSpacing: 10,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Image</title>
    <url>/2020/12/28/400-Flutter%E7%BB%84%E4%BB%B6Image/</url>
    <content><![CDATA[<h1 id="Image-本地图片"><a href="#Image-本地图片" class="headerlink" title="Image 本地图片"></a>Image 本地图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">        image: Assets.images.cat,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<h1 id="Image-network-显示网络图片"><a href="#Image-network-显示网络图片" class="headerlink" title="Image.network 显示网络图片"></a>Image.network 显示网络图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">      &#39;图片url&#39;,</span><br><span class="line">      &#x2F;&#x2F;充满不变形</span><br><span class="line">      fit: BoxFit.cover,</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      color: Colors.blueGrey,</span><br><span class="line">      colorBlendMode: BlendMode.difference,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="结合-ClipOval-组件-展示圆图"><a href="#结合-ClipOval-组件-展示圆图" class="headerlink" title="结合 ClipOval 组件 展示圆图"></a>结合 ClipOval 组件 展示圆图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClipOval(</span><br><span class="line">      clipBehavior: Clip.antiAliasWithSaveLayer,</span><br><span class="line">      child: Image.network(</span><br><span class="line">        imageUrl,</span><br><span class="line">        &#x2F;&#x2F; width: 200,</span><br><span class="line">        &#x2F;&#x2F; height: 200,ß</span><br><span class="line">        fit: BoxFit.cover,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h1 id="Container-BoxDecoration-属性生成-圆图"><a href="#Container-BoxDecoration-属性生成-圆图" class="headerlink" title="Container BoxDecoration 属性生成 圆图"></a>Container BoxDecoration 属性生成 圆图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">      &#x2F;&#x2F; child: networkImage,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        borderRadius: BorderRadius.circular(150),</span><br><span class="line">        image: DecorationImage(</span><br><span class="line">          image: NetworkImage(imageUrl),</span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      width: 300,</span><br><span class="line">      height: 300,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 ListView</title>
    <url>/2020/12/28/400-Flutter%E7%BB%84%E4%BB%B6ListView/</url>
    <content><![CDATA[<h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListView(</span><br><span class="line">      padding: EdgeInsets.fromLTRB(18, 20, 18, 50),</span><br><span class="line">      &#x2F;&#x2F; 滑动方向</span><br><span class="line">      scrollDirection: Axis.horizontal,</span><br><span class="line">      children: [</span><br><span class="line">        ListTile(</span><br><span class="line">          leading: Icon(</span><br><span class="line">            Icons.tv,</span><br><span class="line">            color: Colors.amberAccent,</span><br><span class="line">          ),</span><br><span class="line">          trailing: Icon(Icons.ac_unit),</span><br><span class="line">          title: Text(&#39;标题&#39;),</span><br><span class="line">          subtitle: Text(&#39;二级标题啦啦啦啦啦&#39;),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">    List&lt;Widget&gt; widgetList &#x3D; List();</span><br><span class="line">    for (var i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">      widgetList.add(Text(</span><br><span class="line">        &#39;$i 哈哈哈哈哈&#39;,</span><br><span class="line">        style: TextStyle(fontSize: 30),</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return widgetList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ListView.builder(</span><br><span class="line">      itemCount: _getData().length,</span><br><span class="line">      itemBuilder: (BuildContext context, int index) &#123;</span><br><span class="line">        return _getData()[index];</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Row、Column、Expanded</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Row%E3%80%81Column%E3%80%81Expanded/</url>
    <content><![CDATA[<h1 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h1><blockquote>
<p>水平布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ow(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        children: [</span><br><span class="line">          MyIconWidget(Icons.tv, color: Colors.redAccent),</span><br><span class="line">          MyIconWidget(Icons.ac_unit, color: Colors.blueAccent),</span><br><span class="line">          MyIconWidget(Icons.access_alarms, color: Colors.orangeAccent)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>
<h1 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h1><blockquote>
<p>垂直布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">        children: [</span><br><span class="line">          MyIconWidget(Icons.tv, color: Colors.redAccent),</span><br><span class="line">          MyIconWidget(Icons.ac_unit, color: Colors.blueAccent),</span><br><span class="line">          MyIconWidget(Icons.access_alarms, color: Colors.orangeAccent)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>
<h1 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h1><blockquote>
<p>扩展组件 比例分配</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expanded(</span><br><span class="line">          child: MyIconWidget(Icons.games, color: Colors.blueGrey),</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Row(</span><br><span class="line">      children: [</span><br><span class="line">        Expanded(</span><br><span class="line">          flex: 2,</span><br><span class="line">          child: MyIconWidget(Icons.ac_unit, color: Colors.red),</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          flex: 1,</span><br><span class="line">          child: MyIconWidget(Icons.ac_unit, color: Colors.amberAccent),</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          flex: 2,</span><br><span class="line">          child: MyIconWidget(Icons.ac_unit, color: Colors.red),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 StatefulWidget</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Sft/</url>
    <content><![CDATA[<h1 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h1><blockquote>
<p>动态组件，页面可变化 使用  setState(() {});</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyStfWidget extends StatefulWidget implements PageRouterProtocol &#123;</span><br><span class="line">  @override</span><br><span class="line">  final Map arguments;</span><br><span class="line">  MyStfWidget(&#123;Key key, this.arguments&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyStfWidgetState createState() &#x3D;&gt; _MyStfWidgetState(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyStfWidgetState extends State&lt;MyStfWidget&gt; &#123;</span><br><span class="line">  final Map arguments;</span><br><span class="line"></span><br><span class="line">  List dataList &#x3D; [];</span><br><span class="line"></span><br><span class="line">  _MyStfWidgetState(this.arguments);</span><br><span class="line">  addData() &#123;</span><br><span class="line">    List singleList &#x3D; List();</span><br><span class="line">    for (var i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">      singleList.add(&#39;增加数据了&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.dataList.addAll(singleList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    RaisedButton addBtn &#x3D; RaisedButton(</span><br><span class="line">        child: Text(&#39;加载更多&#39;),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            this.addData();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(arguments[&#39;title&#39;] ?? &#39;默认标题&#39;),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView.builder(</span><br><span class="line">        itemCount: dataList.length + 1,</span><br><span class="line">        itemBuilder: (BuildContext context, int index) &#123;</span><br><span class="line">          if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return addBtn;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return Text(&#39;data  $index&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Stack、Align、Positioned</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Stack%E3%80%81Align%E3%80%81Positioned/</url>
    <content><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">      &#x2F;&#x2F; alignment: Alignment(-1,-1),</span><br><span class="line">      alignment: Alignment.bottomLeft,</span><br><span class="line">      children: [</span><br><span class="line">        Container(color: Colors.orange, height: 100),</span><br><span class="line">        Text(&#39;单独 Stack 布局只有两个组件&#39;,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: 20)),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h1 id="Stack-结合-Align-布局"><a href="#Stack-结合-Align-布局" class="headerlink" title="Stack 结合 Align 布局"></a>Stack 结合 Align 布局</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment.center,</span><br><span class="line">            child: Text(</span><br><span class="line">              &#39;Stack 结合 Align 布局&#39;,</span><br><span class="line">              style: TextStyle(color: Colors.white, fontSize: 30),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment.topLeft,</span><br><span class="line">            child: Icon(Icons.ac_unit),</span><br><span class="line">          ),</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment.bottomLeft,</span><br><span class="line">            child: Icon(Icons.ac_unit),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>

<h1 id="Stack-结合-Positioned-布局"><a href="#Stack-结合-Positioned-布局" class="headerlink" title="Stack 结合 Positioned 布局"></a>Stack 结合 Positioned 布局</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Positioned(</span><br><span class="line">              top: 16,</span><br><span class="line">              left: 16,</span><br><span class="line">              child: Text(</span><br><span class="line">                &#39; Stack 结合 Positioned 布局&#39;,</span><br><span class="line">                style: TextStyle(color: Colors.white, fontSize: 30),</span><br><span class="line">              )),</span><br><span class="line">          Positioned(</span><br><span class="line">              bottom: 10,</span><br><span class="line">              right: 10,</span><br><span class="line">              width: 100,</span><br><span class="line">              height: 100,</span><br><span class="line">              child: Container(</span><br><span class="line">                color: Colors.red,</span><br><span class="line">                child: Icon(Icons.tv),</span><br><span class="line">              ))</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Wrap</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Wrap/</url>
    <content><![CDATA[<h1 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h1><blockquote>
<p>流式布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wrap(</span><br><span class="line">      spacing: 10,</span><br><span class="line">      runSpacing: 10,</span><br><span class="line">      alignment: WrapAlignment.end,</span><br><span class="line">      children: [</span><br><span class="line">        MyButton(&#39;哈哈哈&#39;),</span><br><span class="line">        MyButton(&#39;阿斯顿萨达撒&#39;),</span><br><span class="line">        MyButton(&#39;苏打水萨达撒&#39;),</span><br><span class="line">        MyButton(&#39;阿瑟&#39;),</span><br><span class="line">        MyButton(&#39;萨发送个人舒服舒服当发送的&#39;),</span><br><span class="line">        MyButton(&#39;title&#39;),</span><br><span class="line">        &#x2F;&#x2F;MARK:       MaterialButton</span><br><span class="line">        MaterialButton(</span><br><span class="line">          child: Text(&#39;MaterialButton 风格 btn&#39;),</span><br><span class="line">          shape: CircleBorder(side: BorderSide(width: 100)),</span><br><span class="line">          color: Colors.orange,</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            print(&#39;object&#39;);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        &#x2F;&#x2F;MARK:IconButton</span><br><span class="line">        IconButton(icon: Icon(Icons.ac_unit), onPressed: null),</span><br><span class="line">        &#x2F;&#x2F;MARK: FlatButton</span><br><span class="line">        FlatButton(onPressed: () &#123;&#125;, child: Text(&#39;扁平化按钮&#39;)),</span><br><span class="line">        FloatingActionButton(</span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">          child: Text(&#39;FloatingActionButton&#39;),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 路由跳转</title>
    <url>/2020/12/29/400-Flutter%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="基本路由跳转-加传值"><a href="#基本路由跳转-加传值" class="headerlink" title="基本路由跳转  加传值"></a>基本路由跳转  加传值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).push(MaterialPageRoute(</span><br><span class="line">                builder: (context) &#x3D;&gt; MyRouterPage(title: &#39;首页&#39;),</span><br><span class="line">              ));</span><br></pre></td></tr></table></figure>

<h1 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode Flutter 配置</title>
    <url>/2020/11/19/400-VSCode-Flutter-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>Dart</li>
<li>Flutter</li>
<li>Flutter Generators</li>
<li>Flutter Widget Snippets</li>
<li>Flutter Helpers</li>
<li>[FF] Flutter Files</li>
<li>Awesome Flutter Snippets<h1 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h1><code>shift + cmd + d</code> 添加以下配置，这样就不用每次都在终端输入命令了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-c47d75e75723b671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="操作图"
                ></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;debug&quot;, &#x2F;&#x2F;debug 模式</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;dart&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;profile&quot;, &#x2F;&#x2F;profile 模式 可解决非联机调试白屏</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;dart&quot;,</span><br><span class="line">            &quot;flutterMode&quot;: &quot;profile&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;release&quot;, &#x2F;&#x2F;release 模式 可解决非联机调试白屏</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;dart&quot;,</span><br><span class="line">            &quot;flutterMode&quot;: &quot;release&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="搜索关键词"><a href="#搜索关键词" class="headerlink" title="搜索关键词"></a>搜索关键词</h3><p>VSCode 插件<br>VSCode Flutter 调试配置<br>VSCode Flutter release 模式<br>Flutter release<br>Flutter 启动白屏</p>
<h1 id="如果有帮助求点赞！"><a href="#如果有帮助求点赞！" class="headerlink" title="如果有帮助求点赞！"></a>如果有帮助求点赞！</h1>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>SnapKit适配刘海屏、异形屏</title>
    <url>/2020/11/20/500-SnapKit%E9%80%82%E9%85%8D%E5%88%98%E6%B5%B7%E5%B1%8F%E3%80%81%E5%BC%82%E5%BD%A2%E5%B1%8F/</url>
    <content><![CDATA[<h3 id="🌰-适配底部安全距离"><a href="#🌰-适配底部安全距离" class="headerlink" title="🌰 适配底部安全距离"></a>🌰 适配底部安全距离</h3><p>在 ViewController 的 view 中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make.bottom.equalTo(view.snp.bottomMargin)</span><br><span class="line">make.top.equalTo(view.snp.topMargin)</span><br><span class="line">make.left.equalTo(view.snp.leftMargin)</span><br><span class="line">make.right.equalTo(view.snp.rightMargin)</span><br></pre></td></tr></table></figure>

<p>如果 view 的 superView 没有适配，那么 view 布局需要通过上面的写法适配<br>如果 view 的 superView 已经适配，那么 view 布局也会自动适配</p>
<h3 id="完整🌰"><a href="#完整🌰" class="headerlink" title="完整🌰"></a>完整🌰</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        let redView &#x3D; UIView()</span><br><span class="line">        redView.backgroundColor &#x3D; .red</span><br><span class="line">        view.addSubview(redView)</span><br><span class="line">        redView.snp.makeConstraints &#123; make in</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.bottomMargin.equalToSuperview()  &#x2F;&#x2F;没适配</span><br><span class="line">&#x2F;&#x2F;            make.bottom.equalToSuperview()    &#x2F;&#x2F;没适配</span><br><span class="line">            make.bottom.equalTo(view.snp.bottomMargin)    &#x2F;&#x2F;适配</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.topMargin.equalToSuperview()   &#x2F;&#x2F;没适配导航栏高度</span><br><span class="line">&#x2F;&#x2F;            make.top.equalToSuperview()   &#x2F;&#x2F;没适配导航栏高度</span><br><span class="line">            make.top.equalTo(view.snp.topMargin)    &#x2F;&#x2F;适配导航栏高度</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.leftMargin.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">&#x2F;&#x2F;            make.left.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">                      make.left.equalTo(view.snp.leftMargin)    &#x2F;&#x2F;适配</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.rightMargin.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">&#x2F;&#x2F;            make.right.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">                      make.right.equalTo(view.snp.rightMargin)    &#x2F;&#x2F;适配</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果 redView 已经适配   那么下边的都会适配</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果 redView 没适配   那么只有最后一个会适配</span><br><span class="line">        let blackView &#x3D; UIView()</span><br><span class="line">        blackView.backgroundColor &#x3D; .black</span><br><span class="line">        redView.addSubview(blackView)</span><br><span class="line">        blackView.snp.makeConstraints &#123; make in</span><br><span class="line">            make.left.right.equalToSuperview()</span><br><span class="line">            make.height.equalTo(150)</span><br><span class="line">&#x2F;&#x2F;            make.bottomMargin.equalToSuperview()  &#x2F;&#x2F;适配</span><br><span class="line">&#x2F;&#x2F;            make.bottom.equalTo(view.snp.bottomMargin)    &#x2F;&#x2F;适配</span><br><span class="line">            make.bottom.equalToSuperview()    &#x2F;&#x2F;没适配</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SnapKit</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 常用代码块</title>
    <url>/2020/11/21/500-Xcode-%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<p>一些常用的代码块</p>
<h1 id="点我直达"><a href="#点我直达" class="headerlink" title="点我直达"></a><a class="link"   href="https://github.com/xxxIxxxx/CodeSnippets" >点我直达<i class="fas fa-external-link-alt"></i></a></h1><h1 id="Xcode-路径"><a href="#Xcode-路径" class="headerlink" title="Xcode 路径"></a>Xcode 路径</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;UserData&#x2F;CodeSnippets</span><br></pre></td></tr></table></figure>

<p>打开路径将文件拖进去<br>代码块添加后需要重启 Xcode</p>
<h1 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>lazytab</td>
<td>懒加载属性 tableView</td>
</tr>
<tr>
<td>mk</td>
<td>//MARK: -</td>
</tr>
<tr>
<td>snpmake</td>
<td>SnapKit make 布局</td>
</tr>
<tr>
<td>snpremake</td>
<td>SnapKit remake 布局</td>
</tr>
<tr>
<td>initBtn</td>
<td>UIButton 初始化</td>
</tr>
<tr>
<td>initCCell</td>
<td>UICollectionViewCell 初始化</td>
</tr>
<tr>
<td>initImgV</td>
<td>UIImageView 初始化</td>
</tr>
<tr>
<td>initLab</td>
<td>UILable 初始化</td>
</tr>
<tr>
<td>initTCell</td>
<td>UITableViewCell 初始化</td>
</tr>
<tr>
<td>initView</td>
<td>UIView 初始化</td>
</tr>
<tr>
<td>ssself</td>
<td>guard let  strongSelf = self</td>
</tr>
</tbody></table>
<h1 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>initBtn</td>
<td>UIButton 初始化</td>
</tr>
<tr>
<td>initImgV</td>
<td>UIImageView 初始化</td>
</tr>
<tr>
<td>initLab</td>
<td>UILable 初始化</td>
</tr>
<tr>
<td>initCell</td>
<td>UITableViewCell 初始化</td>
</tr>
<tr>
<td>initView</td>
<td>UIView 初始化</td>
</tr>
<tr>
<td>initTextF</td>
<td>UITextField 初始化</td>
</tr>
<tr>
<td>pna</td>
<td>@property (nonatomic, assign)</td>
</tr>
<tr>
<td>pns</td>
<td>@property (nonatomic, strong)</td>
</tr>
<tr>
<td>pnc</td>
<td>@property (nonatomic, copy)</td>
</tr>
<tr>
<td>td</td>
<td>//TODO:</td>
</tr>
<tr>
<td>mas_make</td>
<td>Masonry make 布局</td>
</tr>
<tr>
<td>mas_remake</td>
<td>Masonry remake 布局</td>
</tr>
<tr>
<td>mas_update</td>
<td>Masonry update 布局</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 代码块</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode-快捷键，Xcode12-打开控制台</title>
    <url>/2020/11/22/500-Xcode-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%8CXcode12-%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command + shift + y</td>
<td>打开控制台</td>
</tr>
<tr>
<td>command + shift + j</td>
<td>定位当前文件在导航</td>
</tr>
<tr>
<td>command + shift + o</td>
<td>输入后快速跳转到对应文件，还可输入方法名</td>
</tr>
<tr>
<td>command + shift + L</td>
<td>打开资源文件</td>
</tr>
<tr>
<td>command + shift + f</td>
<td>搜索项目</td>
</tr>
<tr>
<td>command + shift + k</td>
<td>clean 项目</td>
</tr>
<tr>
<td>command + shift + t</td>
<td>新开当前项目</td>
</tr>
<tr>
<td>command + shift + ,</td>
<td>编辑scheme</td>
</tr>
<tr>
<td>command + shift + 2</td>
<td>打开可用调试设备</td>
</tr>
<tr>
<td>command + shift + w</td>
<td>关闭项目</td>
</tr>
<tr>
<td>command + r</td>
<td>运行项目</td>
</tr>
<tr>
<td>command + b</td>
<td>build 项目</td>
</tr>
<tr>
<td>command + .</td>
<td>停止当前操作</td>
</tr>
<tr>
<td>command + 0</td>
<td>开启/关闭 导航</td>
</tr>
<tr>
<td>command + 1，2 … 9</td>
<td>实操看下效果吧</td>
</tr>
<tr>
<td>command + f</td>
<td>搜索当前文件</td>
</tr>
<tr>
<td>command + L</td>
<td>跳转到对应行</td>
</tr>
<tr>
<td>command + w</td>
<td>关闭当前文件</td>
</tr>
<tr>
<td>command + y</td>
<td>关闭断点调试</td>
</tr>
<tr>
<td>command + \</td>
<td>打断点</td>
</tr>
<tr>
<td>command + ,</td>
<td>偏好设置</td>
</tr>
<tr>
<td>command + return</td>
<td>仅编辑器</td>
</tr>
<tr>
<td>control + 6</td>
<td>显示当前文件的方法，然后可以继续输方法名回车跳转</td>
</tr>
<tr>
<td>control + 0</td>
<td>切换 Target</td>
</tr>
<tr>
<td>control + 4</td>
<td>切换项目</td>
</tr>
<tr>
<td>command + option + w</td>
<td>保留当前打开，关闭其他文件</td>
</tr>
</tbody></table>
<p>欢迎补充比较实用的快捷键！</p>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS OC 与 Swift 混编</title>
    <url>/2020/12/06/500-iOS-OC-%E4%B8%8E-Swift-%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h1 id="1-XXX-Bridging-Header-h"><a href="#1-XXX-Bridging-Header-h" class="headerlink" title="1. XXX-Bridging-Header.h"></a>1. XXX-Bridging-Header.h</h1><p>新建Swift文件时一般会自动提示创建<code>XXX-Bridging-Header.h</code>文件。如果没有那么自己新建一个 Header 文件，命名为<code>项目名-Bridging-Header.h</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-40814d95e9d8b2f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="新建 Header 文件"
                ></p>
<h1 id="2-打开-Target-gt-BuildSettings-搜索-Header"><a href="#2-打开-Target-gt-BuildSettings-搜索-Header" class="headerlink" title="2. 打开 Target -&gt; BuildSettings 搜索 Header"></a>2. 打开 Target -&gt; BuildSettings 搜索 <code>Header</code></h1><h2 id="User-Header-Search-Paths-填写-SRCROOT"><a href="#User-Header-Search-Paths-填写-SRCROOT" class="headerlink" title="User Header Search Paths 填写 $(SRCROOT)"></a><code>User Header Search Paths</code> 填写 <code>$(SRCROOT)</code></h2><h2 id="Enable-Modules-c-and-objective-C-填写-YES"><a href="#Enable-Modules-c-and-objective-C-填写-YES" class="headerlink" title="Enable Modules(c and objective-C) 填写 YES"></a><code>Enable Modules(c and objective-C)</code> 填写 <code>YES</code></h2><h2 id="Objective-C-Bridging-Header-填写-项目名称-项目名称-Bridging-Header-h-⚠️这里是个路径"><a href="#Objective-C-Bridging-Header-填写-项目名称-项目名称-Bridging-Header-h-⚠️这里是个路径" class="headerlink" title="Objective-C Bridging Header 填写 项目名称/项目名称-Bridging-Header.h ⚠️这里是个路径"></a><code>Objective-C Bridging Header</code> 填写 <code>项目名称/项目名称-Bridging-Header.h</code> ⚠️这里是个路径</h2><h2 id="Objective-C-Generated-Interface-Header-Name-填写-项目名称-Swift-h-这里是-OC-引用-Swift-需要用到的。"><a href="#Objective-C-Generated-Interface-Header-Name-填写-项目名称-Swift-h-这里是-OC-引用-Swift-需要用到的。" class="headerlink" title="Objective-C Generated Interface Header Name 填写 项目名称-Swift.h 这里是 OC 引用 Swift 需要用到的。"></a><code>Objective-C Generated Interface Header Name</code> 填写 <code>项目名称-Swift.h</code> 这里是 OC 引用 Swift 需要用到的。</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-c91b49763e023f54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="BuildSettings 需要修改的地方"
                ></p>
<h1 id="3-pod-需要修改的地方"><a href="#3-pod-需要修改的地方" class="headerlink" title="3. pod 需要修改的地方"></a>3. pod 需要修改的地方</h1><p>Podfile 增加 <code>use_frameworks!</code> 后重新 <code>pod install</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target&#39;XXXXX&#39; do</span><br><span class="line">use_frameworks!</span><br></pre></td></tr></table></figure>
<p><strong>⚠️并把所有 <code>pod</code> 导入的库 使用 <code>&lt;&gt;</code> 导入 而不是<code>&quot;&quot;</code> 例如<code>#import &lt;AFNetworking.h&gt;</code></strong></p>
<blockquote>
<p>⚠️第三库报错大多都是导入方式不对引起的⚠️</p>
</blockquote>
<h1 id="4-OC-引用-Swift"><a href="#4-OC-引用-Swift" class="headerlink" title="4. OC 引用 Swift"></a>4. OC 引用 Swift</h1><p>在需要的地方导入 <code>#import &quot;项目名-Swift.h&quot;</code> 然后在需要被引用的属性、方法前增加 <code>@objc</code><br>⚠️ <code> 项目名-Swift.h 这个是隐藏文件看不到</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class XXXViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @objc var name:String &#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">    &#125;  </span><br><span class="line">    @objc func data()  &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-Swift-引用-OC"><a href="#5-Swift-引用-OC" class="headerlink" title="5. Swift 引用 OC"></a>5. Swift 引用 OC</h1><p>把需要引用的文件导入到 <code>项目名-Bridging-Header.h</code> ，即可在 Swift 中引用。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS混编</tag>
      </tags>
  </entry>
  <entry>
    <title>解决导入 objc/Runtime.h 和 objc/message.h 头文件后，敲击代码不提示 / Runtime 代码不提示</title>
    <url>/2020/12/02/500-iOS-Runtime/</url>
    <content><![CDATA[<h1 id="解决导入-objc-Runtime-h-和-objc-message-h-头文件后，敲击代码不提示-Runtime-代码不提示"><a href="#解决导入-objc-Runtime-h-和-objc-message-h-头文件后，敲击代码不提示-Runtime-代码不提示" class="headerlink" title="解决导入 objc/Runtime.h 和 objc/message.h 头文件后，敲击代码不提示 / Runtime 代码不提示"></a>解决导入 <code>objc/Runtime.h</code> 和 <code>objc/message.h</code> 头文件后，敲击代码不提示 / Runtime 代码不提示</h1><p>Build Settings 搜索 <code>objc_msg</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-d1f64b02dd132e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="Build Settings 修改"
                ></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Widget 不显示无法添加、iOS Widget 加载网络图片</title>
    <url>/2020/12/07/500-iOS-Widget-%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%A0%E6%B3%95%E6%B7%BB%E5%8A%A0-%E3%80%81iOS-Widget-%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="Intent-Widget-开发"><a href="#Intent-Widget-开发" class="headerlink" title="Intent Widget 开发"></a><a class="link"   href="https://www.jianshu.com/p/029c85bdf16b" >Intent Widget 开发<i class="fas fa-external-link-alt"></i></a></h3><h3 id="Static-Widget-开发"><a href="#Static-Widget-开发" class="headerlink" title="Static Widget 开发"></a><a class="link"   href="https://www.jianshu.com/p/84c180963ac6" >Static Widget 开发<i class="fas fa-external-link-alt"></i></a></h3><h3 id="Demo下载"><a href="#Demo下载" class="headerlink" title="Demo下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo下载<i class="fas fa-external-link-alt"></i></a></h3><h1 id="Widget-在添加时找不到"><a href="#Widget-在添加时找不到" class="headerlink" title="Widget 在添加时找不到"></a>Widget 在添加时找不到</h1><p> 出现这种情况，可能是只配置了可编辑的 <code>Widget</code>。<br>导致<code>NSExtensionPointIdentifier</code>只有这一种类型 <code>com.apple.intents-service</code> 会被识别为 Siri 扩展。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>再添加一个不可编辑的 <code>Widget</code> 即可。不需要展示出，在 <code>@main</code>方法里不添加就好。<br>确定新添加的<code>NSExtensionPointIdentifier</code>类型为 <code>com.apple.widgetkit-extension</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-7fe44d27ed6af214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="plist"
                ></p>
<hr>
<h1 id="Widget-是不能做动画也不能异步刷新的，所以图片加载必须同步"><a href="#Widget-是不能做动画也不能异步刷新的，所以图片加载必须同步" class="headerlink" title="Widget 是不能做动画也不能异步刷新的，所以图片加载必须同步"></a>Widget 是不能做动画也不能异步刷新的，所以图片加载必须同步</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 同步下载图片，Widget 不能异步刷新</span><br><span class="line"></span><br><span class="line">funcgetImage(_imgUrlString:String) -&gt;UIImage? &#123;</span><br><span class="line"></span><br><span class="line"> guardletdata &#x3D;try?Data(contentsOf:URL(string: imgUrlString)!)else&#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;图片下载失败&quot;)</span><br><span class="line"></span><br><span class="line"> returnnil&#125;</span><br><span class="line"></span><br><span class="line">    print(&quot;图片下载成功&quot;)</span><br><span class="line"></span><br><span class="line"> returnUIImage(data: data)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line"></span><br><span class="line">Image(uiImage:getImage(entry.imageUrlStr) ??UIImage(named:&quot;aaaa&quot;)!)</span><br><span class="line"></span><br><span class="line">                        .resizable()</span><br><span class="line"></span><br><span class="line">                        .frame(width:60,</span><br><span class="line"></span><br><span class="line">                               height:60,</span><br><span class="line"></span><br><span class="line">                               alignment: .center)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
        <tag>iOS小组件</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView 加载 html</title>
    <url>/2020/12/17/500-iOS-WKWebView-loadHTMLString-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87-%E4%B8%BA%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>本文主要是针对后台返回数据是 html 标签的数据加载。异步加载 html 标签内的 img 标签，给 img 标签添加点击事件</p>
</blockquote>
<h1 id="例如返回的数据格式如下"><a href="#例如返回的数据格式如下" class="headerlink" title="例如返回的数据格式如下"></a>例如返回的数据格式如下</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  一、《望天门山》 作者：唐代李白 1、原文</span><br><span class="line">  天门中断楚江开，碧水东流至此回。两岸青山相对出，孤帆一bai片日边来。 2、译文</span><br><span class="line">  天门山从中间断裂是楚江把它冲开，碧水向东浩然奔流到这里折回。</span><br><span class="line">  两岸高耸的青山隔着长江相峙而立，江面上一叶孤舟像从日边驶来。</span><br><span class="line">  &lt;img</span><br><span class="line">    src&#x3D;&quot;https:&#x2F;&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;006CHHsBly1gkxrs7785ej31402eoe84.jpg&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">完整的 html 标签数据</span><br></pre></td></tr></table></figure>
<p> 这些数据一般都是使用了富文本编辑器编辑的内容，而且各种标签样式都有可能使用到，所以最好还是使用 WKWebView 来加载！<br> 但是如果内容含有 img 标签的话就会等待所有的图片加载完才会展示出整体的样式，这样比较影响体验。<br> 所以应该考虑异步加载图片，而不影响文字等标签样式的展示。</p>
<h1 id="Demo下载"><a href="#Demo下载" class="headerlink" title="Demo下载"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXWebView" >Demo下载<i class="fas fa-external-link-alt"></i></a></h1><h4 id="1-先将图片链接中的-scheme-替换为自定义的-scheme"><a href="#1-先将图片链接中的-scheme-替换为自定义的-scheme" class="headerlink" title="1.先将图片链接中的 scheme 替换为自定义的 scheme"></a>1.先将图片链接中的 scheme 替换为自定义的 scheme</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)changeImageScheme &#123;</span><br><span class="line">    self.htmlString &#x3D; [self.htmlString stringByReplacingOccurrencesOfString:self.oriImageUrl withString:self.xxxCustomImageUrl];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在-html-标签中添加函数"><a href="#2-在-html-标签中添加函数" class="headerlink" title="2.在 html 标签中添加函数"></a>2.在 html 标签中添加函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addJsScript &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *htmlLab &#x3D; @&quot;&lt;&#x2F;html&gt;&quot;;</span><br><span class="line">    NSString *scriptLab1 &#x3D; @&quot;&lt;&#x2F;script&gt;&quot;;</span><br><span class="line">    </span><br><span class="line">    NSString *jsFunctionString &#x3D; @&quot;function xxxGetAllImg() &#123; return document.getElementsByTagName(\&quot;img\&quot;); &#125;\</span><br><span class="line">    function xxxUpdateImage(url, imgData) &#123;  var list &#x3D; Array.from(xxxGetAllImg()); for (let item of list) &#123;  if ((item.src &#x3D;&#x3D; url)) &#123; item.src &#x3D; imgData;   break; &#125; &#125; &#125;        &quot;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (![self.htmlString containsString:htmlLab]) &#123;</span><br><span class="line">        [self addHtmlLab];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if ([self.htmlString containsString:scriptLab1]) &#123;</span><br><span class="line">     </span><br><span class="line">        NSString *scriptString &#x3D; [NSString stringWithFormat:@&quot;%@%@&quot;,jsFunctionString,scriptLab1];</span><br><span class="line">        self.htmlString &#x3D; [self.htmlString stringByReplacingOccurrencesOfString:scriptLab1 withString:scriptString];</span><br><span class="line">        </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSString *scriptLab0 &#x3D; @&quot;&lt;script&gt;&quot;;</span><br><span class="line">        NSString *scriptString &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@&quot;,scriptLab0,jsFunctionString,scriptLab1,htmlLab];</span><br><span class="line">        self.htmlString &#x3D; [self.htmlString stringByReplacingOccurrencesOfString:htmlLab withString:scriptString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-定义一个实现-WKURLSchemeHandler-协议的类"><a href="#3-定义一个实现-WKURLSchemeHandler-协议的类" class="headerlink" title="3.定义一个实现 WKURLSchemeHandler 协议的类"></a>3.定义一个实现 WKURLSchemeHandler 协议的类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface XXXCustomSchemeHanlder : NSObject &lt;WKURLSchemeHandler&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *oriImageUrl;</span><br><span class="line">@property (nonatomic, copy) NSString *oriImageScheme;</span><br><span class="line">@property (nonatomic, strong) UIImage *placeholderImage;</span><br><span class="line">@property (nonatomic, copy) void(^updateImageBlock)(void);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="4-实现协议方法-用于拦截图片加载"><a href="#4-实现协议方法-用于拦截图片加载" class="headerlink" title="4.实现协议方法 用于拦截图片加载"></a>4.实现协议方法 用于拦截图片加载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)webView:(nonnull WKWebView *)webView startURLSchemeTask:(nonnull id&lt;WKURLSchemeTask&gt;)urlSchemeTask &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UIImage *image &#x3D; self.placeholderImage;</span><br><span class="line">    NSData *data &#x3D; UIImageJPEGRepresentation(image, 1.0);</span><br><span class="line">    NSURLResponse *response &#x3D; [[NSURLResponse alloc] initWithURL:urlSchemeTask.request.URL MIMEType:@&quot;image&#x2F;jpeg&quot; expectedContentLength:data.length textEncodingName:nil];</span><br><span class="line">    [urlSchemeTask didReceiveResponse:response];</span><br><span class="line">    [urlSchemeTask didReceiveData:data];</span><br><span class="line">    [urlSchemeTask didFinish];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (self.updateImageBlock) &#123;</span><br><span class="line">        self.updateImageBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *htmlImageUrlStr &#x3D; [NSString stringWithFormat:@&quot;%@&quot;,urlSchemeTask.request.URL];</span><br><span class="line">    NSString *dloadImageUrlStr &#x3D; [htmlImageUrlStr stringByReplacingOccurrencesOfString:XXXCustomImageScheme withString:self.oriImageScheme];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [self readImageForKey:dloadImageUrlStr htmlImageUrlStr:htmlImageUrlStr webView:webView];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)readImageForKey:(NSString *)dloadImageUrlStr htmlImageUrlStr:(NSString *)htmlImageUrlStr webView:(WKWebView *)webView &#123;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:dloadImageUrlStr];</span><br><span class="line">    [[SDWebImageManager sharedManager] loadImageWithURL:url options:SDWebImageRetryFailed progress:nil completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123;</span><br><span class="line">        if (image || data) &#123;</span><br><span class="line">            NSData *imgData &#x3D; data;</span><br><span class="line">            if (!imgData) &#123;</span><br><span class="line">                imgData &#x3D; UIImageJPEGRepresentation(image, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [weakSelf callJsUpdateImage:webView imageData:imgData htmlImageUrlStr:htmlImageUrlStr];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (error) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)callJsUpdateImage:(WKWebView *)webView imageData:(NSData *)imageData htmlImageUrlStr:(NSString *)imageUrlString &#123;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    NSString *imageDataStr &#x3D; [NSString stringWithFormat:@&quot;data:image&#x2F;png;base64,%@&quot;,[imageData base64EncodedString]];</span><br><span class="line">    NSString *func &#x3D; [NSString stringWithFormat:@&quot;xxxUpdateImage(&#39;%@&#39;,&#39;%@&#39;)&quot;,imageUrlString,imageDataStr];</span><br><span class="line">    [webView evaluateJavaScript:func completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        if (weakSelf.updateImageBlock &amp;&amp; !error) &#123;</span><br><span class="line">            weakSelf.updateImageBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-初始化-WKWebView-并配置拦截信息"><a href="#5-初始化-WKWebView-并配置拦截信息" class="headerlink" title="5.初始化 WKWebView 并配置拦截信息"></a>5.初始化 WKWebView 并配置拦截信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WKWebViewConfiguration *config &#x3D; [[WKWebViewConfiguration alloc] init];</span><br><span class="line">XXXCustomSchemeHanlder *schemeHandler &#x3D; XXXCustomSchemeHanlder.new;</span><br><span class="line"></span><br><span class="line">schemeHandler.oriImageScheme &#x3D; self.oriImageScheme;</span><br><span class="line">schemeHandler.oriImageUrl &#x3D; self.oriImageUrl;</span><br><span class="line">schemeHandler.placeholderImage &#x3D; self.placeholderImage;</span><br><span class="line"></span><br><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">schemeHandler.updateImageBlock &#x3D; ^ &#123;</span><br><span class="line">    [weakSelf updateHeight];</span><br><span class="line">&#125;;</span><br><span class="line">[config setURLSchemeHandler:schemeHandler forURLScheme:XXXCustomImageScheme];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WKWebView  *webView &#x3D; [[WKWebView alloc]initWithFrame:CGRectMake(0, 0, self.width, self.height) configuration:config];</span><br></pre></td></tr></table></figure>

<h4 id="6-更新高度"><a href="#6-更新高度" class="headerlink" title="6. 更新高度"></a>6. 更新高度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)updateHeight &#123;</span><br><span class="line">    [self nowUpdateHeight];</span><br><span class="line">    [self delayUpdateHeight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)nowUpdateHeight &#123;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    [self.webView evaluateJavaScript:@&quot;document.body.offsetHeight&quot; completionHandler:^(id _Nullable result,NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 高度会有一点少 ，手动补上 20</span><br><span class="line">        CGFloat height &#x3D; [result floatValue] + 20.0;</span><br><span class="line">        weakSelf.webView.height &#x3D; height;</span><br><span class="line">        weakSelf.height &#x3D; height;</span><br><span class="line">        if (weakSelf.loadOverHeight) &#123;</span><br><span class="line">            weakSelf.loadOverHeight(height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)delayUpdateHeight &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, DelayTime * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self nowUpdateHeight];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Demo下载-1"><a href="#Demo下载-1" class="headerlink" title="Demo下载"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXWebView" >Demo下载<i class="fas fa-external-link-alt"></i></a></h1>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 与 web 交互传图</title>
    <url>/2020/12/07/500-iOS-%E4%B8%8E-web-%E4%BA%A4%E4%BA%92-%E4%BC%A0%E5%9B%BE/</url>
    <content><![CDATA[<p>web 端将图片 base64 编码后传给 iOS 端，会在 base64 编码前加上 <code>data:image/png;base64,</code> 需要先把这一串给去掉后进行解码，然后转 data 再转为 image </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 修改状态栏的颜色 preferredStatusBarStyle</title>
    <url>/2020/11/02/500-iOS-%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%A0%8F%E7%9A%84%E9%A2%9C%E8%89%B2-preferredStatusBarStyle/</url>
    <content><![CDATA[<h3 id="⚠️⚠️⚠️首先要在项目的-Info-plist-文件里设置-View-controller-based-status-bar-appearance-为-YES，如果没有就不用添加⚠️-⚠️⚠️"><a href="#⚠️⚠️⚠️首先要在项目的-Info-plist-文件里设置-View-controller-based-status-bar-appearance-为-YES，如果没有就不用添加⚠️-⚠️⚠️" class="headerlink" title="⚠️⚠️⚠️首先要在项目的 Info.plist 文件里设置 View controller-based status bar appearance 为 YES，如果没有就不用添加⚠️ ⚠️⚠️"></a>⚠️⚠️⚠️首先要在项目的 Info.plist 文件里设置 View controller-based status bar appearance 为 YES，如果没有就不用添加⚠️ ⚠️⚠️</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">1. 重写 UINavigationController 的 childViewControllerForStatusBarStyle</span><br><span class="line">可以写在基类的 UINavigationController 中，也可以使用Category</span><br><span class="line">*&#x2F;</span><br><span class="line">- (UIViewController *)childViewControllerForStatusBarStyle &#123;</span><br><span class="line">    return self.topViewController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Swift </span><br><span class="line">override var childForStatusBarStyle: UIViewController? &#123;</span><br><span class="line">        return topViewController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">2.  在需要改变状态栏颜色的 UIViewController 中实现 preferredStatusBarStyle</span><br><span class="line">*&#x2F;</span><br><span class="line">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</span><br><span class="line">   return UIStatusBarStyleLightContent;</span><br><span class="line">   &#x2F;&#x2F; return UIStatusBarStyleDefault;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Swift</span><br><span class="line">override var preferredStatusBarStyle: UIStatusBarStyle &#123;</span><br><span class="line">      return .lightContent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">3. 当触发某个条件需要改变状态栏颜色时在 UIViewController 中调用</span><br><span class="line">然后在 - (UIStatusBarStyle)preferredStatusBarStyle; 中判断你的条件是否满足改变颜色</span><br><span class="line">*&#x2F;</span><br><span class="line">[self setNeedsStatusBarAppearanceUpdate];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Swift</span><br><span class="line">setNeedsStatusBarAppearanceUpdate()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>iOS修改状态栏颜色<br>OC 修改状态栏颜色<br>Swift修改状态栏颜色</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 多 Target CocoaPods 管理</title>
    <url>/2020/11/28/500-iOS-%E5%A4%9A-Target-CocoaPods-%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-iOS-多-Target-CocoaPods-管理，直接来看例子"><a href="#1-iOS-多-Target-CocoaPods-管理，直接来看例子" class="headerlink" title="1. iOS 多 Target CocoaPods 管理，直接来看例子"></a>1. iOS 多 Target CocoaPods 管理，直接来看例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &quot;11.0&quot;</span><br><span class="line">source &quot;https:&#x2F;&#x2F;cdn.cocoapods.org&#x2F;&quot;</span><br><span class="line">#source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"></span><br><span class="line">#定义公共库</span><br><span class="line">def commonPods</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &quot;KakaJSON&quot;, &quot;~&gt; 1.1.2&quot;</span><br><span class="line">  pod &quot;SnapKit&quot;, &quot;~&gt; 5.0.1&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#为 Target1 配置自己独有的库</span><br><span class="line">target &quot;Target1&quot; do</span><br><span class="line">  commonPods</span><br><span class="line">  pod &quot;YYCategories&quot;</span><br><span class="line">  pod &quot;Alamofire&quot;, &quot;~&gt; 5.2.2&quot;</span><br><span class="line">end</span><br><span class="line">#为 Target2 配置自己独有的库</span><br><span class="line">target &quot;Target2&quot; do</span><br><span class="line">  commonPods</span><br><span class="line">  pod &quot;Moya&quot;, &quot;~&gt; 14.0.0&quot;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-判断在哪一个-Target，iOS-Target-判断"><a href="#2-判断在哪一个-Target，iOS-Target-判断" class="headerlink" title="2. 判断在哪一个 Target，iOS Target 判断"></a>2. 判断在哪一个 Target，iOS Target 判断</h1><h3 id="Swift-设置"><a href="#Swift-设置" class="headerlink" title="Swift 设置"></a>Swift 设置</h3><p>Build Settings 搜索 <code>swift compiler</code> 具体看图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-da3235308811d72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="添加 Target 判断条件"
                ></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if MAINTARGET</span><br><span class="line">tipLab.text &#x3D; &quot;mmmm&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="OC-设置"><a href="#OC-设置" class="headerlink" title="OC 设置"></a>OC 设置</h3><p>Build Settings 搜索 <code>macros</code> 具体看图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-3ae5817bcb53187d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="OC 操作图"
                ></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #ifdef TARGETMAIN</span><br><span class="line">NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;TARGETMAIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>Target</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-报错-&#39;sharedApplication&#39;-is-unavailable--not-available-on-iOS</title>
    <url>/2020/11/20/500-iOS-%E6%8A%A5%E9%94%99-&#39;sharedApplication&#39;-is-unavailable--not-available-on-iOS-(App-E/</url>
    <content><![CDATA[<p>这是因为使用了在 App Extension 内不安全的API</p>
<h3 id="解决办法见下图"><a href="#解决办法见下图" class="headerlink" title="解决办法见下图"></a>解决办法见下图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-2161dedfa7242b3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="操作步骤图"
                ></p>
<h3 id="CocoapPods-第三方库-报错同样的解决办法见下图"><a href="#CocoapPods-第三方库-报错同样的解决办法见下图" class="headerlink" title="CocoapPods 第三方库 报错同样的解决办法见下图"></a>CocoapPods 第三方库 报错同样的解决办法见下图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-0b33c4b741a47ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="操作步骤图"
                ></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
        <tag>App Extension</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 用户可编辑的 Widget</title>
    <url>/2020/11/27/500-iOS14-Widget-%E5%BC%80%E5%8F%91-1/</url>
    <content><![CDATA[<h3 id="本篇是用户可编辑的-Widget"><a href="#本篇是用户可编辑的-Widget" class="headerlink" title="本篇是用户可编辑的 Widget"></a>本篇是用户可编辑的 Widget</h3><h3 id="用户不可编辑的-Widget，点我去看"><a href="#用户不可编辑的-Widget，点我去看" class="headerlink" title="用户不可编辑的 Widget，点我去看"></a><a class="link"   href="https://www.jianshu.com/p/84c180963ac6" >用户不可编辑的 Widget，点我去看<i class="fas fa-external-link-alt"></i></a></h3><h3 id="编辑屏幕-Widget-不显示，Widget-加载网络图片"><a href="#编辑屏幕-Widget-不显示，Widget-加载网络图片" class="headerlink" title="编辑屏幕 Widget 不显示，Widget 加载网络图片"></a><a class="link"   href="https://www.jianshu.com/p/a80d59c94442" >编辑屏幕 Widget 不显示，Widget 加载网络图片<i class="fas fa-external-link-alt"></i></a></h3><h1 id="Demo-下载"><a href="#Demo-下载" class="headerlink" title="Demo 下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo 下载<i class="fas fa-external-link-alt"></i></a></h1><h1 id="先来看效果图"><a href="#先来看效果图" class="headerlink" title="先来看效果图"></a>先来看效果图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-196fcdf3f96e1360.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="效果图"
                ></p>
<h1 id="建议将-demo-下载下来对照着看对应-demo-里的-AnimalWidget-文件"><a href="#建议将-demo-下载下来对照着看对应-demo-里的-AnimalWidget-文件" class="headerlink" title="建议将 demo 下载下来对照着看对应 demo 里的 AnimalWidget 文件"></a>建议将 demo 下载下来对照着看对应 demo 里的 AnimalWidget 文件</h1><h3 id="1-新建-Widget-Extension，勾选-Intent。"><a href="#1-新建-Widget-Extension，勾选-Intent。" class="headerlink" title="1. 新建 Widget Extension，勾选 Intent。"></a>1. 新建 Widget Extension，勾选 Intent。</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-4c736e922128a5f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="1. 新建 Widget Extension，勾选 Intent"
                ></p>
<h3 id="2-点击-AnimalWidget-intentdefinition-文件-添加可编辑的数据类型-具体操作看图吧"><a href="#2-点击-AnimalWidget-intentdefinition-文件-添加可编辑的数据类型-具体操作看图吧" class="headerlink" title="2. 点击 AnimalWidget.intentdefinition 文件 添加可编辑的数据类型 具体操作看图吧"></a>2. 点击 AnimalWidget.intentdefinition 文件 添加可编辑的数据类型 具体操作看图吧</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-e26dffe1a81d1a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="2. 点击 AnimalWidget.intentdefinition 文件 具体操作看图吧"
                ></p>
<h3 id="3-为第二步新增的数据类型-设置对应的值"><a href="#3-为第二步新增的数据类型-设置对应的值" class="headerlink" title="3. 为第二步新增的数据类型 设置对应的值"></a>3. 为第二步新增的数据类型 设置对应的值</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-6c898cf25193f0c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="image.png"
                ></p>
<h3 id="4-编辑-Info-plist-️是-widget-extension-的-Info-plist"><a href="#4-编辑-Info-plist-️是-widget-extension-的-Info-plist" class="headerlink" title="4. 编辑 Info.plist (️是 widget extension 的 Info.plist )"></a>4. 编辑 Info.plist (️是 widget extension 的 Info.plist )</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSExtension&lt;&#x2F;key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;IntentsSupported&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;string&gt;AnimalWidgetConfigurationIntent&lt;&#x2F;string&gt;</span><br><span class="line">		&lt;&#x2F;array&gt;</span><br><span class="line">		&lt;key&gt;NSExtensionAttributes&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;dict&gt;</span><br><span class="line">			&lt;key&gt;IntentsRestrictedWhileLocked&lt;&#x2F;key&gt;</span><br><span class="line">			&lt;array&#x2F;&gt;</span><br><span class="line">			&lt;key&gt;IntentsRestrictedWhileProtectedDataUnavailable&lt;&#x2F;key&gt;</span><br><span class="line">			&lt;array&#x2F;&gt;</span><br><span class="line">			&lt;key&gt;IntentsSupported&lt;&#x2F;key&gt;</span><br><span class="line">			&lt;array&gt;</span><br><span class="line">				&lt;string&gt;AnimalWidgetConfigurationIntent&lt;&#x2F;string&gt;</span><br><span class="line">			&lt;&#x2F;array&gt;</span><br><span class="line">		&lt;&#x2F;dict&gt;</span><br><span class="line">		&lt;key&gt;NSExtensionPointIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;string&gt;com.apple.intents-service&lt;&#x2F;string&gt;</span><br><span class="line">		&lt;key&gt;NSExtensionPrincipalClass&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;string&gt;$(PRODUCT_MODULE_NAME).IntentHandler&lt;&#x2F;string&gt;</span><br><span class="line">	&lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-8bb6ff14aab5c9eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="4. 编辑 Info.plist (️是 widget extension 的 Info.plist )"
                ></p>
<h3 id="5-创建-IntentHandler-swift-添加一下代码-可能会报错-找不到-AnimalWidgetConfigurationIntentHandling-、AnimalWidgetConfigurationIntent-先不管先把别的配置好"><a href="#5-创建-IntentHandler-swift-添加一下代码-可能会报错-找不到-AnimalWidgetConfigurationIntentHandling-、AnimalWidgetConfigurationIntent-先不管先把别的配置好" class="headerlink" title="5. 创建 IntentHandler.swift 添加一下代码 (可能会报错 找不到 AnimalWidgetConfigurationIntentHandling 、AnimalWidgetConfigurationIntent  先不管先把别的配置好)"></a>5. 创建 IntentHandler.swift 添加一下代码 (可能会报错 找不到 AnimalWidgetConfigurationIntentHandling 、AnimalWidgetConfigurationIntent  先不管先把别的配置好)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Intents</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 自己创建的文件</span><br><span class="line">class IntentHandler: INExtension, AnimalWidgetConfigurationIntentHandling &#123; &#x2F;&#x2F; AnimalWidgetConfigurationIntentHandling 是第二步的名字 加上 IntentHandling 后缀</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 配置给用户可选的列表                    AnimalWidgetConfigurationIntent 是第二步的名字 加上 Intent 后缀</span><br><span class="line">    func provideAnimalOptionsCollection(for intent: AnimalWidgetConfigurationIntent, searchTerm: String?, with completion: @escaping (INObjectCollection&lt;Animal&gt;?, Error?) -&gt; Void) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 这里可以去请求网络拿数据</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;&#x2F;搜索词 searchTerm 搜索cat</span><br><span class="line">        if searchTerm &#x3D;&#x3D; &quot;cat&quot; &#123;</span><br><span class="line">            completion(INObjectCollection(items: [Animal(identifier: &quot;cat&quot;, display: &quot;cat&quot;)]), nil)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let animals: [Animal] &#x3D; XXXAnimal.zoo.map &#123; (xxxAnimal) in</span><br><span class="line">            return Animal(identifier: xxxAnimal.id, display: xxxAnimal.name)</span><br><span class="line">        &#125;</span><br><span class="line">        completion(INObjectCollection(items: animals), nil)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func handler(for intent: INIntent) -&gt; Any &#123;</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-修改-AnimalWidget-swift-内容"><a href="#6-修改-AnimalWidget-swift-内容" class="headerlink" title="6. 修改 AnimalWidget.swift 内容"></a>6. 修改 AnimalWidget.swift 内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你的工程已经存在了一个 Widget 将 @main 去掉</span><br><span class="line">使用下面</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我的这部分代码在 XXXWidget.swift</span><br><span class="line">@main</span><br><span class="line">struct AllWidget: WidgetBundle &#123;</span><br><span class="line">    </span><br><span class="line">    @WidgetBundleBuilder</span><br><span class="line">    var body: some Widget &#123;</span><br><span class="line">        XXXWidget()</span><br><span class="line">        AnimalWidget()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="修改-TimelineEntry"><a href="#修改-TimelineEntry" class="headerlink" title="修改 TimelineEntry"></a>修改 TimelineEntry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct SimpleEntry: TimelineEntry &#123;</span><br><span class="line">    let date: Date</span><br><span class="line">    let configuration: ConfigurationIntent</span><br><span class="line">&#125;</span><br><span class="line">--------------原️----新️-----------------</span><br><span class="line">&#x2F;&#x2F;&#x2F; 重新命名 去掉 let configuration: ConfigurationIntent  （也可以保留但类型是 AnimalWidgetConfigurationIntent）</span><br><span class="line">&#x2F;&#x2F;&#x2F;增加自己需要的参数</span><br><span class="line">struct AnimalSimpleEntry: TimelineEntry &#123;</span><br><span class="line">    let date: Date</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 新加自己需要的参数</span><br><span class="line">    let animal: XXXAnimal</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="修改-IntentTimelineProvider"><a href="#修改-IntentTimelineProvider" class="headerlink" title="修改 IntentTimelineProvider"></a>修改 IntentTimelineProvider</h4><h4 id="️-涉及到-AnimalWidgetConfigurationIntent-可能会报错-先不管-️"><a href="#️-涉及到-AnimalWidgetConfigurationIntent-可能会报错-先不管-️" class="headerlink" title="️ 涉及到 AnimalWidgetConfigurationIntent 可能会报错 先不管 ️"></a><strong>️ 涉及到 AnimalWidgetConfigurationIntent 可能会报错 先不管 ️</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Provider: IntentTimelineProvider &#123;</span><br><span class="line">    func placeholder(in context: Context) -&gt; SimpleEntry &#123;</span><br><span class="line">        SimpleEntry(date: Date(), configuration: ConfigurationIntent())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getSnapshot(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (SimpleEntry) -&gt; ()) &#123;</span><br><span class="line">        let entry &#x3D; SimpleEntry(date: Date(), configuration: configuration)</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getTimeline(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123;</span><br><span class="line">        var entries: [SimpleEntry] &#x3D; []</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Generate a timeline consisting of five entries an hour apart, starting from the current date.</span><br><span class="line">        let currentDate &#x3D; Date()</span><br><span class="line">        for hourOffset in 0 ..&lt; 5 &#123;</span><br><span class="line">            let entryDate &#x3D; Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!</span><br><span class="line">            let entry &#x3D; SimpleEntry(date: entryDate, configuration: configuration)</span><br><span class="line">            entries.append(entry)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let timeline &#x3D; Timeline(entries: entries, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------原️----新️-----------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重新命名</span><br><span class="line">struct AnimalProvider: IntentTimelineProvider &#123;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 按照要求增加  Entry 和 Intent</span><br><span class="line">    typealias Entry &#x3D; AnimalSimpleEntry</span><br><span class="line">    typealias Intent &#x3D; AnimalWidgetConfigurationIntent</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    func placeholder(in context: Context) -&gt; AnimalSimpleEntry &#123;</span><br><span class="line">        AnimalSimpleEntry(date: Date(), animal: .lion)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getSnapshot(for configuration: AnimalWidgetConfigurationIntent, in context: Context, completion: @escaping (AnimalSimpleEntry) -&gt; ()) &#123;</span><br><span class="line">        let entry &#x3D; AnimalSimpleEntry(date: Date(), animal: .lion)</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    func getTimeline(for configuration: AnimalWidgetConfigurationIntent, in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        let currentDate &#x3D; Date()</span><br><span class="line">        </span><br><span class="line">        guard let id &#x3D; configuration.animal?.identifier, let entryDate &#x3D; Calendar.current.date(byAdding: .minute, value: 1, to: currentDate) else &#123;</span><br><span class="line">            let timeline &#x3D; Timeline(entries: [AnimalSimpleEntry(date: currentDate, animal: .lion)], policy: .atEnd)</span><br><span class="line">            completion(timeline)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let entry &#x3D; AnimalSimpleEntry(date: entryDate, animal: XXXAnimal.animal(id, color: configuration.color))</span><br><span class="line">        </span><br><span class="line">        let timeline &#x3D; Timeline(entries: [entry], policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他地方对照-demo-修改就可以了"><a href="#其他地方对照-demo-修改就可以了" class="headerlink" title="其他地方对照 demo 修改就可以了"></a>其他地方对照 demo 修改就可以了</h2><h1 id="️如果有-Cannot-find-type-‘AnimalWidgetConfigurationIntent’-in-scope-报错-尝试多-build-几次或者-重启-Xcode️"><a href="#️如果有-Cannot-find-type-‘AnimalWidgetConfigurationIntent’-in-scope-报错-尝试多-build-几次或者-重启-Xcode️" class="headerlink" title="️如果有  Cannot find type ‘AnimalWidgetConfigurationIntent’ in scope 报错 尝试多 build 几次或者 重启 Xcode️"></a>️如果有  Cannot find type ‘AnimalWidgetConfigurationIntent’ in scope 报错 尝试多 build 几次或者 重启 Xcode️</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-194231fd2ac108f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="其他注意"
                ></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS14 Widget</title>
    <url>/2020/11/26/500-iOS14-Widget-%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Demo-下载"><a href="#Demo-下载" class="headerlink" title="Demo 下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo 下载<i class="fas fa-external-link-alt"></i></a></h1><h3 id="这个是用户不可配置的，没有编辑选项的-widget"><a href="#这个是用户不可配置的，没有编辑选项的-widget" class="headerlink" title="这个是用户不可配置的，没有编辑选项的 widget"></a>这个是用户不可配置的，没有编辑选项的 widget</h3><h3 id="Intent-用户可编辑的点我去看"><a href="#Intent-用户可编辑的点我去看" class="headerlink" title="Intent 用户可编辑的点我去看"></a><a class="link"   href="https://www.jianshu.com/p/029c85bdf16b" >Intent 用户可编辑的点我去看<i class="fas fa-external-link-alt"></i></a></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-126d13797dd4e2de.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="效果图"
                ></p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 时间线</span><br><span class="line">struct XXXProvider: TimelineProvider &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 占位的展示</span><br><span class="line">    func placeholder(in context: Context) -&gt; XXXSimpleEntry &#123;</span><br><span class="line">        XXXSimpleEntry(date: Date(), displayTime: XXXData.displayData())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 快照</span><br><span class="line">    func getSnapshot(in context: Context, completion: @escaping (XXXSimpleEntry) -&gt; ()) &#123;</span><br><span class="line">        let entry &#x3D; XXXSimpleEntry(date: Date(), displayTime: XXXData.displayData())</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;根据时间线提供需要展示的状态</span><br><span class="line">    func getTimeline(in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;时间线刷新了&quot; + &quot;\(Date())&quot;)</span><br><span class="line">        </span><br><span class="line">        var entrys: [XXXSimpleEntry] &#x3D; []</span><br><span class="line">        let currentData &#x3D; Date()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 提供当前时间后 1个小时内  每一秒的状态 (已经提供了3600个状态，太多会不展示卡死)</span><br><span class="line">        for i in 0...60*60 &#123;</span><br><span class="line">            guard let entryDate &#x3D; Calendar.current.date(byAdding: .second, value: i, to: currentData) else &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            entrys.append(XXXSimpleEntry(date: entryDate, displayTime: XXXData.displayData(entryDate)))</span><br><span class="line">        &#125;</span><br><span class="line">        let timeline &#x3D; Timeline(entries: entrys, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 每一个时间线的实体</span><br><span class="line">struct XXXSimpleEntry: TimelineEntry &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;展示该状态的时间</span><br><span class="line">    let date: Date</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 自己配置的数据</span><br><span class="line">    let displayTime: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; widget 展示 view</span><br><span class="line">struct XXXWidgetEntryView : View &#123;</span><br><span class="line">    var entry: XXXProvider.Entry</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 返回在这个时间 (entry.date)    你想要展示的widegt样式</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ZStack &#123;</span><br><span class="line">            </span><br><span class="line">            Color.orange.edgesIgnoringSafeArea(.all)</span><br><span class="line">            VStack &#123;</span><br><span class="line">                Text(entry.displayTime)</span><br><span class="line">                    .multilineTextAlignment(.center)</span><br><span class="line">                    .foregroundColor(.blue)</span><br><span class="line">                    &#x2F;&#x2F;&#x2F;配置点击链接会在主工程收到拉起事件</span><br><span class="line">                    .widgetURL(URL(string: &quot;widgetDemo:&#x2F;&#x2F;789&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;widget</span><br><span class="line">struct XXXWidget: Widget &#123;</span><br><span class="line">    let kind: String &#x3D; &quot;XXXWidget&quot;</span><br><span class="line"></span><br><span class="line">    var body: some WidgetConfiguration &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; StaticConfiguration 是静态的，用户不可配置的 长按不会出现编辑</span><br><span class="line">        StaticConfiguration(kind: kind, provider: XXXProvider()) &#123; entry in</span><br><span class="line">            XXXWidgetEntryView(entry: entry)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(&quot;添加时的标题&quot;)</span><br><span class="line">        .description(&quot;添加时的描述&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;提供预览状态</span><br><span class="line">struct XXXWidget_Previews: PreviewProvider &#123;</span><br><span class="line">    </span><br><span class="line">    static var previews: some View &#123;</span><br><span class="line">        XXXWidgetEntryView(entry: XXXSimpleEntry(date: Date(), displayTime: XXXData.displayData()))</span><br><span class="line">            .previewContext(WidgetPreviewContext(family: .systemSmall))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;主入口</span><br><span class="line">@main</span><br><span class="line">struct AllWidget: WidgetBundle &#123;</span><br><span class="line">    </span><br><span class="line">    @WidgetBundleBuilder</span><br><span class="line">    var body: some Widget &#123;</span><br><span class="line">        XXXWidget()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="部分操作的详细截图"><a href="#部分操作的详细截图" class="headerlink" title="部分操作的详细截图"></a>部分操作的详细截图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-d4e70bcacfcacc7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="File -&gt; New -&gt; Target"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-b19a4ce4f064179c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="这个是用户不可配置的widget，勾选的是用户可配置的。我们先来做不可配置的"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-786376718471b3c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="调整最低运行系统"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-5fcaf3ede4232577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="关联主工程数据"
                ></p>
<h1 id="Demo-下载-1"><a href="#Demo-下载-1" class="headerlink" title="Demo 下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo 下载<i class="fas fa-external-link-alt"></i></a></h1>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS占位图、空白页面</title>
    <url>/2020/11/24/500-iOS%E5%8D%A0%E4%BD%8D%E5%9B%BE%E3%80%81%E7%A9%BA%E7%99%BD%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="iOS占位图、空白页面-Github直达"><a href="#iOS占位图、空白页面-Github直达" class="headerlink" title="iOS占位图、空白页面 Github直达"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXPlaceholder" >iOS占位图、空白页面 Github直达<i class="fas fa-external-link-alt"></i></a></h1><h1 id="iOS占位图、空白页面-适用于view、tableView、collectionView、scrollvew"><a href="#iOS占位图、空白页面-适用于view、tableView、collectionView、scrollvew" class="headerlink" title="iOS占位图、空白页面 适用于view、tableView、collectionView、scrollvew"></a>iOS占位图、空白页面 适用于view、tableView、collectionView、scrollvew</h1><h1 id="😄😄😄"><a href="#😄😄😄" class="headerlink" title="😄😄😄"></a>😄😄😄</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-337781e6ecaac4ae.gif?imageMogr2/auto-orient/strip"
                      alt="tableView使用效果"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-37d81ba5477c72c3.gif?imageMogr2/auto-orient/strip"
                      alt="view使用效果"
                ></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a><em>注意</em></h1><h5 id="1-当tableView、collectionView-有数据时（row-gt-0，item-gt-0）不显示占位图"><a href="#1-当tableView、collectionView-有数据时（row-gt-0，item-gt-0）不显示占位图" class="headerlink" title="1.当tableView、collectionView 有数据时（row&gt;0，item&gt;0）不显示占位图"></a>1.当tableView、collectionView 有数据时（row&gt;0，item&gt;0）不显示占位图</h5><h5 id="2-当scrollView-contentSize-height-gt-scrollView-frame-size-height-时临时禁用滑动属性（tableView、collectionView优先遵循第一条）"><a href="#2-当scrollView-contentSize-height-gt-scrollView-frame-size-height-时临时禁用滑动属性（tableView、collectionView优先遵循第一条）" class="headerlink" title="2.当scrollView.contentSize.height &gt; scrollView.frame.size.height 时临时禁用滑动属性（tableView、collectionView优先遵循第一条）"></a>2.当scrollView.contentSize.height &gt; scrollView.frame.size.height 时临时禁用滑动属性（tableView、collectionView优先遵循第一条）</h5><h5 id="3-建议导入demo中的XXXPlaceholderEX文件夹"><a href="#3-建议导入demo中的XXXPlaceholderEX文件夹" class="headerlink" title="3.建议导入demo中的XXXPlaceholderEX文件夹"></a>3.建议导入demo中的XXXPlaceholderEX文件夹</h5><h5 id="4-占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件"><a href="#4-占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件" class="headerlink" title="4.占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件"></a>4.占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件</h5><h5 id="5-我觉得用法还是挺简单的，看下demo吧😂"><a href="#5-我觉得用法还是挺简单的，看下demo吧😂" class="headerlink" title="5.我觉得用法还是挺简单的，看下demo吧😂"></a>5.我觉得用法还是挺简单的，看下demo吧😂</h5><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo update</span><br><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json  (清除搜索缓存)</span><br><span class="line">pod &#39;XXXPlaceholder&#39;, &#39;~&gt; 0.0.1&#39;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>参照demo创建占位图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;self为tableView</span><br><span class="line">self.xxx_emptyView &#x3D; [XXXPlaceholderView emptyView];</span><br><span class="line">self.xxx_noNetworkView &#x3D; [XXXPlaceholderView noNetworkView];</span><br><span class="line">&#x2F;&#x2F;占位图会自动添加点击事件</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>tableView、collectionView 展示占位图调用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">刷新数据源 tableView、collectionView专用</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_reloadData;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line">刷新数据源 tableView、collectionView专用</span><br><span class="line">@param clickBlock 占位图点击事件Block</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_reloadDataWithClickBlock:  (nullable   XXXPlaceholderClickBlock)clickBlock;</span><br><span class="line"></span><br><span class="line">[self.tableView xxx_reloadDataWithClickBlock:^&#123;</span><br><span class="line">           &#x2F;&#x2F;这里做再次请求</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></li>
<li><p>view使用 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> 展示无数据占位图</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)xxx_showEmptyView;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">展示无数据占位图</span><br><span class="line">@param clickBlock 占位图点击事件Block</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_showEmptyViewWithClickBlock:(nullable XXXPlaceholderClickBlock)clickBlock;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">展示无网络占位图</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_showNoNetWorkView;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">展示无网络占位图</span><br><span class="line">@param clickBlock 占位图点击事件Block</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_showNoNetWorkViewWithClickBlock:(nullable XXXPlaceholderClickBlock)clickBlock;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line"> 移出所有占位图</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)xxx_removePlaceholderView;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="Github直达"><a href="#Github直达" class="headerlink" title="Github直达"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXPlaceholder" >Github直达<i class="fas fa-external-link-alt"></i></a></h1></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS拖拽卡片</title>
    <url>/2020/11/22/500-iOS%E6%8B%96%E6%8B%BD%E5%8D%A1%E7%89%87%E5%8F%A0%E5%8A%A0%E5%8D%A1%E7%89%87/</url>
    <content><![CDATA[<h1 id="github-XXXCardStore"><a href="#github-XXXCardStore" class="headerlink" title="github XXXCardStore"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXCardStore" >github XXXCardStore<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-86f449d502adaa19.gif?imageMogr2/auto-orient/strip"
                      alt="效果图"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-70de1ba83f9ad822.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="说明图"
                ></p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol>
<li>pod search XXXCardStore<br>如未搜索到 请执行 pod repo update 进行更新，然后清除搜索缓存 rm ~/Library/Caches/CocoaPods/search_index.json</li>
<li>pod ‘XXXCardStore’</li>
<li>import &lt; XXXCardStore .h&gt;</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">XXXCardStore *xxx &#x3D; [XXXCardStore new];</span><br><span class="line">    [self.view addSubview:xxx];</span><br><span class="line">    xxx.frame &#x3D; CGRectMake(50, 100, 300, 200);</span><br><span class="line">    xxx.cardOffset &#x3D; 10.0;</span><br><span class="line">    xxx.isInfiniteLoop &#x3D;YES;</span><br><span class="line">    xxx.delegate &#x3D; self;</span><br><span class="line">    xxx.imgUrlStrArr &#x3D; @[@&quot;http:&#x2F;&#x2F;f.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;203fb80e7bec54e7c340af43b2389b504fc26a3b.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;d.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;0d338744ebf81a4c6231d43ddb2a6059242da6c6.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;a.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;4e4a20a4462309f788a28152790e0cf3d6cad6a4.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;d.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;810a19d8bc3eb135101902e6ad1ea8d3fc1f4494.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;f.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;86d6277f9e2f0708a5559f5de224b899a901f21f.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;h.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;ca1349540923dd5441e81235da09b3de9d8248d7.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;c.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;faedab64034f78f09d3f2eae72310a55b3191cb2.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;d.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;622762d0f703918f037f88975a3d269758eec4c5.jpg&quot;</span><br><span class="line">                         ];</span><br><span class="line">    [xxx reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tapCard:(NSInteger)index cardStore:(UIView *)xxxCardStore&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;--- tap   &#x3D;&#x3D;&#x3D;  %ld&quot;,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="自定义卡片内容"><a href="#自定义卡片内容" class="headerlink" title="自定义卡片内容"></a>自定义卡片内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 自定义卡片内容</span><br><span class="line"> </span><br><span class="line"> @param customCard 你的customView 内部试图未清除</span><br><span class="line"> @param index 需要准备的 card的 index</span><br><span class="line"> @param xxxCardStore xxxCardStore 主体</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)customCardView:(UIView *)customCard index:(NSInteger)index cardStore:(UIView *)xxxCardStore;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS mask 遮罩，彩色文本</title>
    <url>/2020/11/20/500-iOS%E6%B8%90%E5%8F%98%E5%BD%A9%E8%89%B2%E6%96%87%E5%AD%97%E3%80%81iOS-mask-%E9%81%AE%E7%BD%A9/</url>
    <content><![CDATA[<h1 id="iOS渐变彩色文字、iOS-mask-遮罩"><a href="#iOS渐变彩色文字、iOS-mask-遮罩" class="headerlink" title="iOS渐变彩色文字、iOS mask 遮罩"></a>iOS渐变彩色文字、iOS mask 遮罩</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-2f3e46c5908444fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="效果图"
                ></p>
<p><a class="link"   href="https://github.com/ibireme/YYCategories" >使用到了YYCategories<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="彩色文字"><a href="#彩色文字" class="headerlink" title="彩色文字"></a>彩色文字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIView *colorBgView &#x3D; [UIView new];</span><br><span class="line">    [self.view addSubview:colorBgView];</span><br><span class="line">    colorBgView.frame &#x3D; CGRectMake(0, 300, UIScreen.mainScreen.bounds.size.width, 40);</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;这里用了YYCategories</span><br><span class="line">    UIBezierPath *colorTextPath &#x3D; [UIBezierPath bezierPathWithText:@&quot;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&quot; font:[UIFont systemFontOfSize:28]];</span><br><span class="line">    CAShapeLayer *colorTextLayer &#x3D; [CAShapeLayer layer];</span><br><span class="line">    colorTextLayer.path &#x3D; colorTextPath.CGPath;</span><br><span class="line">    colorTextLayer.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">    colorBgView.layer.mask &#x3D; colorTextLayer;</span><br><span class="line">    </span><br><span class="line">    CAGradientLayer *colorLayer &#x3D; CAGradientLayer.new;</span><br><span class="line">    colorLayer.colors &#x3D; @[(__bridge id)UIColor.redColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.orangeColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.greenColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.blueColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.yellowColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.purpleColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.blackColor.CGColor,];</span><br><span class="line">    colorLayer.startPoint &#x3D; CGPointMake(0, 0.5);</span><br><span class="line">    colorLayer.endPoint &#x3D; CGPointMake(1, 0.5);</span><br><span class="line">    colorLayer.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 40);</span><br><span class="line">    [colorBgView.layer addSublayer:colorLayer];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="过渡遮罩"><a href="#过渡遮罩" class="headerlink" title="过渡遮罩"></a>过渡遮罩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> &#x2F;&#x2F;&#x2F;黑色背景view</span><br><span class="line">    UIView *indicatorView &#x3D; [UIView new];</span><br><span class="line">    [self.view addSubview:indicatorView];</span><br><span class="line">    indicatorView.backgroundColor &#x3D; UIColor.blackColor;</span><br><span class="line">    indicatorView.layer.cornerRadius &#x3D; 20;</span><br><span class="line">    indicatorView.layer.masksToBounds &#x3D; YES;</span><br><span class="line">    indicatorView.frame &#x3D; CGRectMake(0, 195, 100, 40);</span><br><span class="line">    self.indicatorView &#x3D; indicatorView;</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F;这里用了YYCategories</span><br><span class="line">    UIBezierPath *textPath &#x3D; [UIBezierPath bezierPathWithText:@&quot;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&quot; font:[UIFont systemFontOfSize:28]];</span><br><span class="line">    CAShapeLayer *textLayer &#x3D; [CAShapeLayer layer];</span><br><span class="line">    textLayer.path &#x3D; textPath.CGPath;</span><br><span class="line">    textLayer.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    UIView *darkView &#x3D; [UIView new];</span><br><span class="line">    [self.view addSubview:darkView];</span><br><span class="line">    darkView.backgroundColor &#x3D; UIColor.darkGrayColor;</span><br><span class="line">    darkView.frame &#x3D; CGRectMake(0, 200, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">    darkView.layer.mask &#x3D; textLayer;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    UIView *whiteView &#x3D; [UIView new];</span><br><span class="line">    [darkView addSubview:whiteView];</span><br><span class="line">    whiteView.backgroundColor &#x3D; UIColor.whiteColor;</span><br><span class="line">    whiteView.layer.cornerRadius &#x3D; 20;</span><br><span class="line">    whiteView.layer.masksToBounds &#x3D; YES;</span><br><span class="line">    whiteView.frame &#x3D; CGRectMake(0, -5, 100, 40);</span><br><span class="line">    self.whiteView &#x3D; whiteView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;也可以使用layer</span><br><span class="line">&#x2F;&#x2F;    CALayer *darkLayer &#x3D; CALayer.new;</span><br><span class="line">&#x2F;&#x2F;    [self.view.layer addSublayer:darkLayer];</span><br><span class="line">&#x2F;&#x2F;    darkLayer.backgroundColor &#x3D; UIColor.darkGrayColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    darkLayer.frame &#x3D; CGRectMake(0, 200, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">&#x2F;&#x2F;    darkLayer.mask &#x3D; textLayer;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    CAShapeLayer *whiteLayer &#x3D; CAShapeLayer.new;</span><br><span class="line">&#x2F;&#x2F;    [darkLayer addSublayer:whiteLayer];</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.backgroundColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.fillColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.strokeColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.borderColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.cornerRadius &#x3D; 20;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.masksToBounds &#x3D; YES;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.frame &#x3D; CGRectMake(0, -5, 100, 40);</span><br><span class="line">&#x2F;&#x2F;    self.whiteLayer &#x3D; whiteLayer;</span><br><span class="line">    </span><br><span class="line">    UISlider *slider &#x3D; UISlider.new;</span><br><span class="line">    [self.view addSubview:slider];</span><br><span class="line">    [slider addTarget:self action:@selector(changeFrame:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line">    slider.frame &#x3D; CGRectMake(0, 260, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">- (void)changeFrame:(UISlider *)slider &#123;</span><br><span class="line"> </span><br><span class="line">    CGFloat x &#x3D; UIScreen.mainScreen.bounds.size.width *slider.value;</span><br><span class="line">    self.indicatorView.frame &#x3D; CGRectMake(x, 195, 100, 40);</span><br><span class="line">    self.whiteView.frame &#x3D; CGRectMake(x, -5, 100, 40);</span><br><span class="line">    self.whiteLayer.frame &#x3D; CGRectMake(x, -5, 100, 40);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序引入模块，App.js</title>
    <url>/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="创建一个模块-utils-appConfig-js"><a href="#创建一个模块-utils-appConfig-js" class="headerlink" title="创建一个模块 utils/appConfig.js"></a>创建一个模块 utils/appConfig.js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const appConfig &#x3D; &#123;</span><br><span class="line">  host: &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">  sayHi(e) &#123;</span><br><span class="line">    console.log(&#39;hi&#39; + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default appConfig</span><br></pre></td></tr></table></figure>

<h1 id="导入创建的模块使用-其他-js-文件内"><a href="#导入创建的模块使用-其他-js-文件内" class="headerlink" title="导入创建的模块使用     其他 .js 文件内"></a>导入创建的模块使用     其他 .js 文件内</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import appConfig from &#39;..&#x2F;..&#x2F;..&#x2F;utils&#x2F;appConfig.js&#39;;</span><br><span class="line">console.log(appConfig.host);</span><br><span class="line">appConfig.sayHi(&#39;朱小明&#39;)</span><br></pre></td></tr></table></figure>


<h1 id="获取-App-js"><a href="#获取-App-js" class="headerlink" title="获取 App.js"></a>获取 App.js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  userToken:&#39;zhu xiao ming&#39;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; 省略其他</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let app &#x3D; getApp();</span><br><span class="line">console.log(app.userToken);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序界面跳转传值、反向传值</title>
    <url>/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h1 id="page1-点击事件-wxml"><a href="#page1-点击事件-wxml" class="headerlink" title="page1 点击事件 .wxml"></a>page1 点击事件 .wxml</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text bind:tap&#x3D;&quot;pushNav&quot;&gt;界面跳转传值&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure>
<h1 id="page1-跳转方法实现-js"><a href="#page1-跳转方法实现-js" class="headerlink" title="page1 跳转方法实现 .js"></a>page1 跳转方法实现 .js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushNav(e) &#123;</span><br><span class="line">    </span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      &#x2F;&#x2F; 跳转传值方式 1</span><br><span class="line">      url: &#39;..&#x2F;page2?carName&#x3D;&#39; + &#39;特斯拉&#39;,</span><br><span class="line"></span><br><span class="line">      events: &#123;</span><br><span class="line">        &#x2F;&#x2F; 反向传值 page2 回调给 page1 接收处</span><br><span class="line">        getuserInfoClick(e) &#123;</span><br><span class="line">          console.log(e);</span><br><span class="line">          that.setData(&#123; userName: e.userName &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        &#x2F;&#x2F; 跳转传值方式 2</span><br><span class="line">        &#x2F;&#x2F; 这个其实有点类似于通知的意思 定义通知名称 和 参数</span><br><span class="line">        res.eventChannel.emit(&#39;diyfunName&#39;, &#123; parKey: &#39;我是通过 eventChannel 传递的另一个数据&#39; &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h1 id="page2-接收传值，并回传-js"><a href="#page2-接收传值，并回传-js" class="headerlink" title="page2 接收传值，并回传  .js"></a>page2 接收传值，并回传  .js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过方式1 传值接收</span><br><span class="line">    this.setData(&#123; carName: options.carName &#125;);</span><br><span class="line"></span><br><span class="line">    const eventChannel &#x3D; this.getOpenerEventChannel();</span><br><span class="line">    </span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 反向传值 page2 传给 page1</span><br><span class="line">    eventChannel.emit(&#39;getuserInfoClick&#39;, &#123; userName: &#39;朱小明&#39; &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F; 通过方式2 传值接收</span><br><span class="line">    eventChannel.on(&#39;diyfunName&#39;, function (params) &#123;</span><br><span class="line">      that.setData(&#123; otherPar: params.parKey &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序自定义组件、父子组件相互调用传值</title>
    <url>/2021/01/15/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-创建-header-组件"><a href="#1-创建-header-组件" class="headerlink" title="1.创建 header 组件"></a>1.创建 header 组件</h1><h2 id="1-1-选中文件夹，右键新建-Component。-暂命名为-header"><a href="#1-1-选中文件夹，右键新建-Component。-暂命名为-header" class="headerlink" title="1.1 选中文件夹，右键新建 Component。 暂命名为 header"></a>1.1 选中文件夹，右键新建 Component。 暂命名为 header</h2><h2 id="1-2-header-js-文件配置组件属性与方法"><a href="#1-2-header-js-文件配置组件属性与方法" class="headerlink" title="1.2 header.js 文件配置组件属性与方法"></a>1.2 header.js 文件配置组件属性与方法</h2><blockquote>
<p>交互关键方法⚠️ this.triggerEvent(‘subClickEvent’, ‘来自 子组件 的信号这个是 参数’)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;组件的属性列表</span><br><span class="line">  properties: &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 属性名 简化写法</span><br><span class="line">    name: String,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 属性名</span><br><span class="line">    car: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      value: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生命周期函数，可以为函数，或一个在methods段中定义的方法名</span><br><span class="line">  lifetimes: &#123;</span><br><span class="line">    attached: function () &#123; &#125;,</span><br><span class="line">    moved: function () &#123; &#125;,</span><br><span class="line">    detached: function () &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件所在页面的生命周期函数</span><br><span class="line">  pageLifetimes: &#123;</span><br><span class="line">    show: function () &#123; &#125;,</span><br><span class="line">    hide: function () &#123; &#125;,</span><br><span class="line">    resize: function () &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件的初始数据</span><br><span class="line">  data: &#123;</span><br><span class="line">    color: &#39;彩色&#39;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件的方法列表</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    logP() &#123;</span><br><span class="line">      console.log(&#39;pppppp&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组件内部先调用该方法 再调用父方法</span><br><span class="line">    cllParentClick() &#123;</span><br><span class="line">      &#x2F;&#x2F;  触发 subClickEvent 事件， 间接通知在 父组件中 subClickEvent 绑定的 subClick 方法</span><br><span class="line">      &#x2F;&#x2F;  建议  subClickEvent 与  subClick 命名相同，这个刚接触感觉会有一点混乱</span><br><span class="line">      &#x2F;&#x2F; subClickEvent 就是通知名。subClickEvent 这个通知在使用该组件时绑定的，绑定了父组件的 subClick 方法。然后在这里触发了 subClickEvent 通知</span><br><span class="line">      this.triggerEvent(&#39;subClickEvent&#39;, &#39;来自 子组件 的信号这个是 参数&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    btnClick(e) &#123;</span><br><span class="line">      console.log(&#39;开车开车&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 私有方法 下划线开头</span><br><span class="line">    _saySelfName() &#123;</span><br><span class="line">      console.log(&#39;header&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-header-wxml"><a href="#1-3-header-wxml" class="headerlink" title="1.3 header.wxml"></a>1.3 header.wxml</h2><p>header 组件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">  &lt;text&gt;name:&#123;&#123;name&#125;&#125;  car:&#123;&#123;car&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;button size&#x3D;&quot;default&quot; type&#x3D;&quot;primary&quot; bind:tap&#x3D;&quot;btnClick&quot;&gt;开车开车&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;button size&#x3D;&quot;default&quot; type&#x3D;&quot;primary&quot; bind:tap&#x3D;&quot;cllParentClick&quot;&gt;调用父组件 subClick 方法&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>
<p>header.wxss</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-使用-header-组件"><a href="#2-使用-header-组件" class="headerlink" title="2. 使用 header 组件"></a>2. 使用 header 组件</h1><h2 id="2-1-page-json"><a href="#2-1-page-json" class="headerlink" title="2.1 page.json"></a>2.1 page.json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;header&quot;: &quot;..&#x2F;..&#x2F;..&#x2F;components&#x2F;header&#x2F;header&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-page-wxml"><a href="#2-2-page-wxml" class="headerlink" title="2.2 page.wxml"></a>2.2 page.wxml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;header id&#x3D;&#39;comHeader&#39; name&#x3D;&#39;朱小明&#39; car&#x3D;&#39;自行车&#39; bind:subClickEvent&#x3D;&#39;subClick&#39;&gt;&lt;&#x2F;header&gt;</span><br><span class="line">&lt;button bind:tap&#x3D;&quot;getHeaderInfo&quot;&gt;获取组件属性&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里注册的 subClickEvent 事件，当 header 组件触发 subClickEvent 时，调用 page 的  subClick 方法。 建议将 subClickEvent 与 subClick 命名相同</p>
</blockquote>
<h2 id="2-3-page-js"><a href="#2-3-page-js" class="headerlink" title="2.3 page.js"></a>2.3 page.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; header 组件间接调用该方法</span><br><span class="line">  subClick(e) &#123;</span><br><span class="line">    console.log(e.detail);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 主动获取 header 组件实例对象</span><br><span class="line">  getHeaderInfo() &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取组件实例对象  记得加 # </span><br><span class="line">    let header &#x3D; this.selectComponent(&#39;#comHeader&#39;);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取属性</span><br><span class="line">    console.log(header.properties.color);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 调用方法</span><br><span class="line">    header.logP();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>从输入 URL 到展现页面的全过程</title>
    <url>/2021/02/03/1000-000%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E5%B1%95%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从输入-URL-到展现页面的全过程"><a href="#从输入-URL-到展现页面的全过程" class="headerlink" title="从输入 URL 到展现页面的全过程"></a>从输入 URL 到展现页面的全过程</h1><blockquote>
<p>8 个过程</p>
</blockquote>
<ul>
<li>URL 输入</li>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求</li>
<li>服务器相应请求</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<h2 id="1-URL-输入"><a href="#1-URL-输入" class="headerlink" title="1. URL 输入"></a>1. URL 输入</h2><blockquote>
<p>URL中文名叫做统一资源定位符，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
</blockquote>
<p><strong>主要组成部分：protocol :// hostname[:port] / path / [;parameters][?query]#fragment</strong></p>
<ul>
<li>protocol 协议</li>
<li>hostname 主机名</li>
<li>port 端口号</li>
<li>path 路径</li>
<li>parameters 参数</li>
<li>query 查询</li>
<li>fragment 信息片段<blockquote>
<p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>
</blockquote>
<h2 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h2><blockquote>
<p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如<a class="link"   href="http://www.baidu.com,其实不是百度网站真正意义上的地址.互联网上每一台计算机的唯一标识是它的ip地址,但是ip地址并不方便记忆.用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机,也就是上面提到的百度的网址.所以互联网设计者需要在用户的方便性与可用性方面做一个权衡,这个权衡就是一个网址到ip地址的转换,这个过程就是dns解析.它实际上充当了一个翻译的角色,实现了网址到ip地址的转换.网址到ip地址转换的过程是如何进行的/" >www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的<i class="fas fa-external-link-alt"></i></a>?</p>
</blockquote>
</li>
</ul>
<p><strong>查找顺序： 浏览器缓存–&gt; 操作系统缓存–&gt; 本地host文件 –&gt; 路由器缓存–&gt; ISP DNS缓存 –&gt; 顶级DNS服务器/根DNS服务器</strong></p>
<p><strong>1. 浏览器缓存：</strong> 首先会向浏览器的缓存中读取上一次访问的记录，在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看缓存的当前状态 。</p>
<p><strong>2. 操作系统缓存：</strong>  查找存储在系统运行内存中的缓存。在mac中可以通过下面的命令清除系统中的DNS缓存。<br><code>dscacheutil -flushcache</code></p>
<p><strong>3. 本地 host 文件：</strong> 查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
<p><strong>4. 路由器缓存：</strong> 有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。</p>
<p><strong>5. ISP DNS 缓存：</strong> 互联网服务提供商（如中国电信）也会提供DNS服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向根域名服务器请求查询。</p>
<p><strong>6. 顶级 DNS 服务器 / 根 DNS 服务器：</strong> 根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的DNS服务器IP（baidu.com），本机继续查找，直到服务器找到(<a class="link"   href="http://www.baidu.com)的主机./" >www.baidu.com)的主机。<i class="fas fa-external-link-alt"></i></a><br>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/t5awpd.png"
                      alt="过程图"
                ></p>
<p>上述图片是查找 <a class="link"   href="http://www.google.com/" >www.google.com<i class="fas fa-external-link-alt"></i></a> 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为</a>: . -&gt; .com -&gt; google.com. -&gt; <a class="link"   href="http://www.google.com../" >www.google.com.。<i class="fas fa-external-link-alt"></i></a></p>
<p>补充：</p>
<ol>
<li><p>什么是 DNS ？<br>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<br>  通俗的讲，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p>
</li>
<li><p>DNS 查询的两种方式：递归查询和迭代查询</p>
<p> 2.1 递归解析<br> 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/4vqiqy.png"
                      alt="DNS 递归解析查询"
                ></p>
<p> 2.2 迭代解析<br> 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/rnsyzp.png"
                      alt="DNS 迭代解析查询"
                ></p>
</li>
<li><p>DNS 域名称空间的组织方式<br>我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>名称类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>根域</td>
<td>DNS 域名中使用时，规模由尾部句点(.) 来指定名称位于根或更高级别的域层次结构</td>
<td>单个句点(.)或句点用于末尾的名称</td>
</tr>
<tr>
<td>顶级域</td>
<td>用来指示某个国家/地区或组织的名称</td>
<td>.com</td>
</tr>
<tr>
<td>第二层域</td>
<td>个人或组织在 Internet 上使用的注册名称</td>
<td>qq.com</td>
</tr>
<tr>
<td>子域</td>
<td>已注册的二级域名派生的域名，通俗的讲就是网站名</td>
<td><a class="link"   href="http://www.qq.com/" >www.qq.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>主机名</td>
<td>通常情况下，DNS 域名的最左侧的标签标示网络上的特定计算机 如 h1</td>
<td>h1.<a class="link"   href="http://www.qq.com/" >www.qq.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<ol start="4">
<li><p>DNS 优化<br>了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。</p>
<p> 4.1 DNS 缓存<br> DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。<br> 4.2 DNS 负载均衡<br> 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
</li>
</ol>
<h2 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/bnd17b.png"
                      alt="TCP 连接图"
                ></p>
<p>三次握手以建立 TCP 连接<br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p><strong>为什需要三次握手？</strong><br>《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>
<h2 id="4-发送HTTP请求"><a href="#4-发送HTTP请求" class="headerlink" title="4. 发送HTTP请求"></a>4. 发送HTTP请求</h2><p>建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。   </p>
<p>客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>
<ul>
<li>请求方法URI协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<h2 id="5-服务器永久重定向"><a href="#5-服务器永久重定向" class="headerlink" title="5.服务器永久重定向"></a>5.服务器永久重定向</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<a class="link"   href="http://www.google.com/" >http://www.google.com/<i class="fas fa-external-link-alt"></i></a> 而非<a class="link"   href="http://google.com/%E3%80%82" >http://google.com/。<i class="fas fa-external-link-alt"></i></a>   <br>​    为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a class="link"   href="http://www.yy.com/%E5%92%8Chttp://yy.com/%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%9A%E8%AE%A4%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%80%A0%E6%88%90%E6%AF%8F%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%93%BE%E6%8E%A5%E9%83%BD%E5%87%8F%E5%B0%91%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%8E%92%E5%90%8D%E3%80%82%E8%80%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9F%A5%E9%81%93301%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E6%8A%8A%E8%AE%BF%E9%97%AE%E5%B8%A6www%E7%9A%84%E5%92%8C%E4%B8%8D%E5%B8%A6www%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%92%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8E%92%E5%90%8D%E4%B8%8B%E3%80%82%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E6%80%A7%E5%8F%98%E5%B7%AE%EF%BC%8C%E5%BD%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%90%8D%E5%AD%97%E6%97%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E9%87%8C%E5%87%BA%E7%8E%B0%E5%A5%BD%E5%87%A0%E6%AC%A1%E3%80%82" >http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>补充</li>
</ul>
<ol>
<li>301和302的区别：</li>
</ol>
<p>301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。<br>  他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；<br>  302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</p>
<ol start="2">
<li><p>重定向原因：<br>(1)网站调整（如改变网页目录结构）；<br>(2)网页被移到一个新地址；<br>(3)网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>
</li>
<li><p>什么时候进行301或者302跳转呢？<br>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下：</p>
</li>
</ol>
<ul>
<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
<li>空间服务器不稳定，换空间的时候。</li>
</ul>
<h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？   </p>
<p>后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。   <br>一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/pn6p43.png"
                      alt="示例图"
                ></p>
<ul>
<li>补充：</li>
</ul>
<ol>
<li>什么是反向代理？<br>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/ysfjxn.png"
                      alt="示例图"
                ></li>
</ol>
<h2 id="7-服务器返回一个-HTTP-响应"><a href="#7-服务器返回一个-HTTP-响应" class="headerlink" title="7. 服务器返回一个 HTTP 响应"></a>7. 服务器返回一个 HTTP 响应</h2><p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。 HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>空行</li>
<li>响应正文</li>
</ul>
<p><strong>状态行：</strong><br>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。<br>格式: HTTP-Version Status-Code Reason-Phrase CRLF<br>例如: HTTP/1.1 200 OK \r\n<br>| -协议版本：是用http1.0还是其他版本<br>| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok<br>| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<p>==1xx：== 信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p>
<ul>
<li>100 Continue</li>
<li>101 Switching Protocols</li>
</ul>
<p>==2xx：== 成功状态码，表示服务器已成功接收到请求并进行处理。</p>
<ul>
<li>200 OK 表示客户端请求成功</li>
<li>204 No Content 成功，但不返回任何实体的主体部分</li>
<li>206 Partial Content 成功执行了一个范围（Range）请求</li>
</ul>
<p>==3xx：== 重定向状态码，表示服务器要求客户端重定向。</p>
<ul>
<li>301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</li>
<li>302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</li>
<li>303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</li>
<li>307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</li>
</ul>
<p>==4xx：== 客户端错误状态码，表示客户端的请求有非法内容。</p>
<ul>
<li>400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li>
</ul>
<p>==5xx：== 服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p>
<ul>
<li>500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li>503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>
</ul>
<p><strong>响应头：</strong><br>响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/m1chic.png"
                      alt="响应头"
                ></p>
<p><strong>响应正文：</strong><br>包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/0qw5o5.png"
                      alt="响应正文"
                ></p>
<h2 id="8-浏览器显示-html"><a href="#8-浏览器显示-html" class="headerlink" title="8. 浏览器显示 html"></a>8. 浏览器显示 html</h2><blockquote>
<p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p>
</blockquote>
<p><strong>构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</strong><br>渲染过程：</p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br>​    当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。<br>​    JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。<br>​    JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/we6f9l.png"
                      alt="渲染过程"
                ></p>
<h2 id="9-连接结束"><a href="#9-连接结束" class="headerlink" title="9. 连接结束"></a>9. 连接结束</h2><p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭，过程如下。<br>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：<br>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。<br>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。<br>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。<br>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p>
<p><strong>补充：</strong><br><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://juejin.cn/post/6844903616101220366" >https://juejin.cn/post/6844903616101220366<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>DNS</tag>
        <tag>HTTP 请求</tag>
      </tags>
  </entry>
</search>
