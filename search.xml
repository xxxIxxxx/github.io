<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用 hexo 和 github 搭建自己的博客</title>
    <url>/2020/12/18/000/</url>
    <content><![CDATA[<h1 id="博客迁移自本人简书"><a href="#博客迁移自本人简书" class="headerlink" title="博客迁移自本人简书"></a><a class="link"   href="https://www.jianshu.com/u/192abcc5117c" >博客迁移自本人简书<i class="fas fa-external-link-alt"></i></a></h1><blockquote>
<p>迁移的文章时间未同步。为了防止每次发布，时间跟着改变。随机给了一个时间。</p>
</blockquote>
<h1 id="Hexo-教程"><a href="#Hexo-教程" class="headerlink" title="Hexo 教程"></a><a class="link"   href="https://hexo.io/zh-cn/" >Hexo 教程<i class="fas fa-external-link-alt"></i></a></h1><h1 id="Hexo-主题-Keep"><a href="#Hexo-主题-Keep" class="headerlink" title="Hexo 主题 Keep"></a><a class="link"   href="https://keep.xpoet.cn/" >Hexo 主题 Keep<i class="fas fa-external-link-alt"></i></a></h1><blockquote>
<p>Keep主题 精简好看 就是我用的这套主题</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Swift GCD barrier</title>
    <url>/2020/11/02/100-Swift-GCD-barrier/</url>
    <content><![CDATA[<h1 id="异步读写造成数组越界"><a href="#异步读写造成数组越界" class="headerlink" title="异步读写造成数组越界"></a>异步读写造成数组越界</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let count &#x3D; 100000</span><br><span class="line">var array &#x3D; Array(0 ... count)</span><br><span class="line"></span><br><span class="line">func getLast() -&gt; Int &#123;</span><br><span class="line">&#x2F;&#x2F; ⚠️⚠️ 这里加了判断看似安全，但在异步操作时 判断 array.count &gt; 0 的同时可能就有一个异步的操作改变了数组</span><br><span class="line">    if array.count &gt; 0 &#123;</span><br><span class="line">        return array[array.count - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func removeLast() &#123;</span><br><span class="line">    array.removeLast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        print(getLast())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-barrier"><a href="#使用-barrier" class="headerlink" title="使用 barrier"></a>使用 barrier</h1><blockquote>
<p>会保证在同一个队列中 .barrier 执行完之后才会去做其他线程操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let count &#x3D; 100000</span><br><span class="line">var array &#x3D; Array(0 ... count)</span><br><span class="line">let arrayQueue &#x3D; DispatchQueue(label: &quot;arrayQueue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line"></span><br><span class="line">func getLast() -&gt; Int &#123;</span><br><span class="line">    arrayQueue.sync &#123; () -&gt; Int in</span><br><span class="line">        if array.count &gt; 0 &#123;</span><br><span class="line">            return array[array.count - 1]</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func removeLast() &#123;</span><br><span class="line">&#x2F;&#x2F;⚠️⚠️ 这里使用 barrier </span><br><span class="line">    let workItem &#x3D; DispatchWorkItem(qos: DispatchQoS.default, flags: DispatchWorkItemFlags.barrier) &#123;</span><br><span class="line">        array.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    arrayQueue.async(execute: workItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    for _ in 0 ... count &#123;</span><br><span class="line">        print(getLast())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift GCD 死锁</title>
    <url>/2020/11/04/100-Swift-GCD-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="1-串行队列中，在异步任务中添加同步任务"><a href="#1-串行队列中，在异步任务中添加同步任务" class="headerlink" title="1. 串行队列中，在异步任务中添加同步任务"></a>1. 串行队列中，在异步任务中添加同步任务</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 由于没有定义 attributes 所以是串行队列</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;----- task 1 -------&quot;)</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        print(&quot;----- task 2 -------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⚠️解决方法</span><br><span class="line">&#x2F;&#x2F;&#x2F; 解决方法将串行改为并行</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="2-主线程同步"><a href="#2-主线程同步" class="headerlink" title="2. 主线程同步"></a>2. 主线程同步</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue.main</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    print(&quot;----- task 1 -------&quot;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift GCD 的串行队列与并行队列</title>
    <url>/2020/11/07/100-Swift-GCD-%E7%9A%84%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97%E4%B8%8E%E5%B9%B6%E8%A1%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>队列</th>
<th>异步是否阻塞当前线程</th>
<th>同步是否阻塞当前线程</th>
<th>执行顺序</th>
</tr>
</thead>
<tbody><tr>
<td>串行队列</td>
<td>否</td>
<td>是</td>
<td>按添加顺序</td>
</tr>
<tr>
<td>并行队列</td>
<td>否</td>
<td>是</td>
<td>同时执行，但会被同步阻塞</td>
</tr>
</tbody></table>
<h1 id="串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序"><a href="#串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序" class="headerlink" title="串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序"></a>串行队列异步任务不会阻塞线程，同步会阻塞当前线程，执行顺序按添加顺序</h1><h1 id="并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞"><a href="#并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞" class="headerlink" title="并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞"></a>并行队列异步任务不会阻塞线程，同步会阻塞当前线程，同时执行，但会被同步阻塞</h1><hr>
<h1 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;queue&quot;)</span><br><span class="line">print(&quot;------ 开始 -------&quot;)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 3)</span><br><span class="line">    print(&quot;------ async 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ async 1 不阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 2 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 3)</span><br><span class="line">    print(&quot;------ sync 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ 被 sync 1 阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 3 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------ 开始 -------</span><br><span class="line">------ async 1 不阻塞 -------</span><br><span class="line">------ async 1 -------</span><br><span class="line">------ async 2 -------</span><br><span class="line">------ sync 1 -------</span><br><span class="line">------ 被 sync 1 阻塞 -------</span><br><span class="line">------ async 3 -------</span><br></pre></td></tr></table></figure>
<h1 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;queue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line">print(&quot;------ 开始 -------&quot;)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 3)</span><br><span class="line">    print(&quot;------ async 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ async 1 不阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 2 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    Thread.sleep(forTimeInterval: 5)</span><br><span class="line">    print(&quot;------ sync 1 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------ 被 sync 1 阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    print(&quot;------ async 3 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------ 开始 -------</span><br><span class="line">------ async 1 不阻塞 -------</span><br><span class="line">------ async 2 -------</span><br><span class="line">------ async 1 -------</span><br><span class="line">------ sync 1 -------</span><br><span class="line">------ 被 sync 1 阻塞 -------</span><br><span class="line">------ async 3 -------</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift String 截取字符串，String 转 NSString</title>
    <url>/2020/11/09/100-Swift-String-%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C-String-%E8%BD%AC-NSString/</url>
    <content><![CDATA[<h1 id="String-转-NSString，转为-NSString-后-OC-的方法就能使用了"><a href="#String-转-NSString，转为-NSString-后-OC-的方法就能使用了" class="headerlink" title="String 转 NSString，转为 NSString 后 OC 的方法就能使用了"></a>String 转 NSString，转为 NSString 后 OC 的方法就能使用了</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 转为 NSString</span><br><span class="line"> (&quot;ABCD&quot; as NSString)</span><br><span class="line">&#x2F;&#x2F; 调用 NSString 的方法</span><br><span class="line"> (&quot;ABCD&quot; as NSString).substring(to: 1)</span><br></pre></td></tr></table></figure>

<h1 id="Swift-中-String-的字符串截取"><a href="#Swift-中-String-的字符串截取" class="headerlink" title="Swift 中 String 的字符串截取"></a>Swift 中 String 的字符串截取</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let str &#x3D; &quot;ABCDEFGHIGK&quot;</span><br><span class="line"></span><br><span class="line">       print(&quot;前5个&quot; + &quot;\(str.prefix(5))&quot;)</span><br><span class="line">       &#x2F;&#x2F; 前5个ABCDE</span><br><span class="line"></span><br><span class="line">       print(&quot;前150个&quot; + str.prefix(150))</span><br><span class="line">       &#x2F;&#x2F; 前150个ABCDEFGHIGK</span><br><span class="line"></span><br><span class="line">       print(&quot;后3个&quot; + &quot;\(str.suffix(3))&quot;)</span><br><span class="line">       &#x2F;&#x2F; 后3个IGK</span><br><span class="line"></span><br><span class="line">       print(&quot;后150个&quot; + &quot;\(str.suffix(150))&quot;)</span><br><span class="line">       &#x2F;&#x2F; 后150个ABCDEFGHIGK</span><br><span class="line"></span><br><span class="line">       let startIndex &#x3D; str.index(str.startIndex, offsetBy: 2)</span><br><span class="line">       let endIndex &#x3D; str.index(str.startIndex, offsetBy: 5)</span><br><span class="line"></span><br><span class="line">       print(&quot;2-5是&quot; + str[startIndex ..&lt; endIndex])</span><br><span class="line">       &#x2F;&#x2F; 2-5是CDE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 多线程</title>
    <url>/2020/11/10/100-Swift-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-Thread"><a href="#1-Thread" class="headerlink" title="1. Thread"></a>1. Thread</h1><h4 id="闭包内直接执行代码"><a href="#闭包内直接执行代码" class="headerlink" title="闭包内直接执行代码"></a>闭包内直接执行代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 闭包内直接执行代码</span><br><span class="line">Thread.detachNewThread &#123;</span><br><span class="line">                print(&quot;111&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建一个方法-开启子线程后去调用"><a href="#创建一个方法-开启子线程后去调用" class="headerlink" title="创建一个方法 开启子线程后去调用"></a>创建一个方法 开启子线程后去调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个方法 开启子线程后去调用</span><br><span class="line">let tr &#x3D; Thread(target: self, selector: #selector(threadTest), object: nil)</span><br><span class="line">&#x2F;&#x2F;开启</span><br><span class="line">tr.start()</span><br><span class="line"></span><br><span class="line">@objc func threadTest () &#123;</span><br><span class="line">        print(&quot;777&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Operation"><a href="#2-Operation" class="headerlink" title="2. Operation"></a>2. Operation</h1><h4 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; BlockOperation</span><br><span class="line">let operation &#x3D; BlockOperation &#123;</span><br><span class="line">      print(&quot; ----- BlockOperation  -----&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let queue &#x3D; OperationQueue()</span><br><span class="line">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>

<h4 id="继承自-Operation"><a href="#继承自-Operation" class="headerlink" title="继承自 Operation"></a>继承自 Operation</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 继承自 Operation</span><br><span class="line">class MyOperation: Operation &#123;</span><br><span class="line">            override func main() &#123;</span><br><span class="line">                print(&quot;--- MyOperation do ... ----&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">let operation &#x3D; MyOperation()</span><br><span class="line">&#x2F;&#x2F;&#x2F; 当 operation 执行完 会执行这个</span><br><span class="line">operation.completionBlock &#x3D; &#123;</span><br><span class="line">            print(&quot;----- completionBlock  ------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let queue &#x3D; OperationQueue()</span><br><span class="line">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>

<h1 id="3-GCD"><a href="#3-GCD" class="headerlink" title="3. GCD"></a>3. GCD</h1><h4 id="队列-Queue-常用的"><a href="#队列-Queue-常用的" class="headerlink" title="队列 Queue 常用的"></a>队列 Queue 常用的</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 异步 并行</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F; 回到主线程异步</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F; 异步延时</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 1) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><blockquote>
<p>label：名字标签<br>qos：优先级<br>attributes：串行队列、并行队列 concurrent<br>autoreleaseFrequency：频率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;, qos: DispatchQoS.default, attributes: DispatchQueue.Attributes.concurrent, autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit, target: nil)</span><br><span class="line">        </span><br><span class="line">queue.async &#123;</span><br><span class="line">            print(&quot; --- 异步 ---&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">queue.sync &#123;</span><br><span class="line">            print(&quot;--- 同步 -----&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">queue.asyncAfter(deadline: .now() + 5) &#123;</span><br><span class="line">            print(&quot;---- 5s ------&quot;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><blockquote>
<p>同步会等待他上一个进入的线程执行完才会开始(无论上一个线程是同步还是异步)，并且阻挡线程等待自己执行完毕才会继续往下执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 串行队列</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;)</span><br><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line"></span><br><span class="line">print(&quot;------- 开始 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(3)</span><br><span class="line">    print(&quot;------- 异步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    print(&quot;------- 同步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 A 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    print(&quot;------- 同步 B -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 B 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;------- 异步 B -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;------- 等待 -------&quot;)</span><br><span class="line">&#x2F;&#x2F; wait 会阻塞线程</span><br><span class="line">group.wait()</span><br><span class="line">print(&quot;------- 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; notify 不会阻塞</span><br><span class="line">&#x2F;&#x2F;group.notify(queue: queue) &#123;</span><br><span class="line">&#x2F;&#x2F;print(&quot;------- 结束 -------&quot;)</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">------- 开始 -------</span><br><span class="line">------- 异步 A -------</span><br><span class="line">------- 同步 A -------</span><br><span class="line">------- 同步 A 结束 -------</span><br><span class="line">------- 同步 B -------</span><br><span class="line">------- 同步 B 结束 -------</span><br><span class="line">------- 等待 -------</span><br><span class="line">------- 异步 B -------</span><br><span class="line">------- 结束 -------</span><br></pre></td></tr></table></figure>

<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><blockquote>
<p>同步会阻塞后面的线程执行，且同步不受前边异步的影响</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;myQueue&quot;, attributes: DispatchQueue.Attributes.concurrent)</span><br><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line"></span><br><span class="line">print(&quot;------- 开始 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;------- 异步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;------- 同步 A -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 A 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    sleep(3)</span><br><span class="line">    print(&quot;------- 同步 B -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 同步 B 结束 -------&quot;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    sleep(2)</span><br><span class="line">    print(&quot;------- 异步 B 耗时操作 -------&quot;)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: queue) &#123;</span><br><span class="line">    print(&quot;------- 全部结束 -------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;------- 未被耗时操作阻塞 -------&quot;)</span><br><span class="line"></span><br><span class="line">------- 开始 -------</span><br><span class="line">------- 同步 A -------</span><br><span class="line">------- 同步 A 结束 -------</span><br><span class="line">------- 异步 A -------</span><br><span class="line">------- 同步 B -------</span><br><span class="line">------- 同步 B 结束 -------</span><br><span class="line">------- 未被耗时操作阻塞 -------</span><br><span class="line">------- 异步 B 耗时操作 -------</span><br><span class="line">------- 全部结束 -------</span><br></pre></td></tr></table></figure>
<h4 id="DispatchSource-定时器例子"><a href="#DispatchSource-定时器例子" class="headerlink" title="DispatchSource 定时器例子"></a>DispatchSource 定时器例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var time &#x3D; 7</span><br><span class="line">let timer &#x3D; DispatchSource.makeTimerSource(flags: [], queue: .global())</span><br><span class="line">&#x2F;&#x2F;每秒执行一次</span><br><span class="line">timer.schedule(deadline: .now(), repeating: 1)</span><br><span class="line">timer.setEventHandler &#123;</span><br><span class="line">&#x2F;&#x2F;  由于使用的 queue 是  .global()   这里不是主线程 </span><br><span class="line">    time -&#x3D; 1</span><br><span class="line">    print(&quot;----- \(time)&quot;)</span><br><span class="line">    if time &#x3D;&#x3D; 1 &#123;</span><br><span class="line">        timer.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">timer.resume()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 数组</title>
    <url>/2020/11/22/100-Swift-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list &#x3D; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line">list.removeAll&#123; $0 &#x3D;&#x3D; &quot;2&quot; &#125;</span><br><span class="line">&#x2F;&#x2F;[&quot;1&quot;,&quot;3&quot;,&quot;4&quot;]</span><br></pre></td></tr></table></figure>


<h1 id="Swift-数组遍历的几种方式"><a href="#Swift-数组遍历的几种方式" class="headerlink" title="Swift 数组遍历的几种方式"></a>Swift 数组遍历的几种方式</h1><h3 id="1-for-in-不带索引"><a href="#1-for-in-不带索引" class="headerlink" title="1. for-in 不带索引"></a>1. for-in 不带索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 不带索引</span><br><span class="line">for obj in arr &#123;</span><br><span class="line">    print(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-forEach-不能使用-break-continue-，只能使用-return"><a href="#2-forEach-不能使用-break-continue-，只能使用-return" class="headerlink" title="2. forEach 不能使用 break continue ，只能使用 return"></a>2. forEach 不能使用 break continue ，只能使用 return</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 不带索引</span><br><span class="line">arr.forEach &#123; obj in</span><br><span class="line">    &#x2F;&#x2F; 不能使用 break continue ，只能使用 return</span><br><span class="line">    print(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-enumerated-带索引-和-值"><a href="#3-enumerated-带索引-和-值" class="headerlink" title="3. enumerated() 带索引 和 值"></a>3. enumerated() 带索引 和 值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 带索引 和 值</span><br><span class="line">for (index, obj) in arr.enumerated() &#123;</span><br><span class="line">    print(&quot;位置：\(index)&quot; + &quot;值：\(obj)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-while"><a href="#4-while" class="headerlink" title="4. while"></a>4. while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 迭代器</span><br><span class="line">var arrIterator &#x3D; arr.makeIterator()</span><br><span class="line">while let obj &#x3D; arrIterator.next() &#123;</span><br><span class="line">    print(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-indices-下标索引-遍历下标"><a href="#5-indices-下标索引-遍历下标" class="headerlink" title="5. indices 下标索引 遍历下标"></a>5. indices 下标索引 遍历下标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [Int](7 ..&lt; 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 下标索引 遍历下标</span><br><span class="line">for index in arr.indices &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间-for-in-区间-for-循环"><a href="#区间-for-in-区间-for-循环" class="headerlink" title="区间 for-in 区间 for 循环"></a>区间 for-in 区间 for 循环</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s &#x3D; 5</span><br><span class="line">&#x2F;&#x2F;&#x2F; 开区间不包含 50 ， 5 个一输出</span><br><span class="line">for i in stride(from: 0, to: 50, by: s) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 闭区间包含 50， 5 个一输出</span><br><span class="line">for i in stride(from: 0, through: 50, by: s) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组的一些查找操作"><a href="#数组的一些查找操作" class="headerlink" title="数组的一些查找操作"></a>数组的一些查找操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array &#x3D; [Int](7 ..&lt; 117)</span><br><span class="line"></span><br><span class="line">let a &#x3D; array.contains(100)</span><br><span class="line">print(&quot;\(a ? &quot;包含&quot; : &quot;不包含&quot;)&quot; + &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">let b &#x3D; array.contains(where: &#123; $0 &gt; 8 &#125;)</span><br><span class="line">print(&quot;\(b ? &quot;含有大于8的数字&quot; : &quot;不含有大于8的数字&quot;)&quot;)</span><br><span class="line"></span><br><span class="line">let c &#x3D; array.allSatisfy &#123; $0 &gt;&#x3D; 6 &#125;</span><br><span class="line">print(&quot;\(c ? &quot;所有数字都大于等于6&quot; : &quot;有数字小于6&quot;)&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;数组中第一个元素是&quot; + &quot;\(String(describing: array.first))&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;数组中最后一个元素是&quot; + &quot;\(String(describing: array.last))&quot;)</span><br><span class="line"></span><br><span class="line">let first &#x3D; array.first(where: &#123; $0 &gt; 8 &#125;)</span><br><span class="line">if let first &#x3D; first &#123;</span><br><span class="line">    print(&quot;第一个大于8的数字是&quot; + &quot;\(first)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let last &#x3D; array.last(where: &#123; $0 &gt; 8 &#125;)</span><br><span class="line">if let last &#x3D; last &#123;</span><br><span class="line">    print(&quot;最后一个大于8的数字是&quot; + &quot;\(last)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 10 在数组中第一次出现的位置</span><br><span class="line">array.firstIndex(of: 10)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 17 在数组中最后一次出现的位置</span><br><span class="line">array.lastIndex(of: 17)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift 添加下标 subscript</title>
    <url>/2020/11/23/100-Swift-%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87-subscript/</url>
    <content><![CDATA[<h1 id="关键子-subscript"><a href="#关键子-subscript" class="headerlink" title="关键子 subscript "></a>关键子 <code>subscript </code></h1><p>参数和返回值可以是任意类型（<code>inout</code>输入输出除外）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct People &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;, age &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给实例添加下标</span><br><span class="line">    subscript(n: String) -&gt; Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return age</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            age &#x3D; newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给结构体添加下标</span><br><span class="line">    static subscript(name: String, age: Int) -&gt; People &#123;</span><br><span class="line">        People(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; People(name: &quot;哈哈哈&quot;, age: 18)</span><br><span class="line">print(a[&quot;哈哈哈&quot;])&#x2F;&#x2F;18</span><br><span class="line">a[&quot;哈哈哈&quot;] &#x3D; 20</span><br><span class="line">print(a[&quot;哈哈哈&quot;])&#x2F;&#x2F;20</span><br><span class="line">let p &#x3D; People[&quot;哈喽&quot;, 20]</span><br><span class="line">print(p)&#x2F;&#x2F;People(name: &quot;哈喽&quot;, age: 20)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 的一些高阶函数 map、filter、reduce、flatMap、compactMap</title>
    <url>/2020/11/17/100-Swift-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-map-filter-reduce-flatMap-compactMap/</url>
    <content><![CDATA[<h1 id="map-对集合里的每一个元素进行操作，然后返回个新的集合"><a href="#map-对集合里的每一个元素进行操作，然后返回个新的集合" class="headerlink" title="map 对集合里的每一个元素进行操作，然后返回个新的集合"></a>map 对集合里的每一个元素进行操作，然后返回个新的集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers &#x3D; [1, 3, 5, 7, 9]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 对集合里的每一个元素进行操作，然后返回个新的集合</span><br><span class="line">print(numbers.map &#123; $0 * 10 &#125;)</span><br><span class="line">&#x2F;&#x2F; [10, 30, 50, 70, 90]</span><br></pre></td></tr></table></figure>

<h1 id="filter-过滤集合里面的每一个元素，返回一个满足条件的新的集合"><a href="#filter-过滤集合里面的每一个元素，返回一个满足条件的新的集合" class="headerlink" title="filter 过滤集合里面的每一个元素，返回一个满足条件的新的集合"></a>filter 过滤集合里面的每一个元素，返回一个满足条件的新的集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers &#x3D; [1, 3, 5, 7, 9]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 过滤集合里面的每一个元素，返回一个满足条件的新的集合</span><br><span class="line">print(numbers.filter &#123; $0 &gt; 5 &#125;)</span><br><span class="line">&#x2F;&#x2F; [7, 9]</span><br></pre></td></tr></table></figure>

<h1 id="reduce-对集合里面的每一个元素-作用在当前累计的结果上"><a href="#reduce-对集合里面的每一个元素-作用在当前累计的结果上" class="headerlink" title="reduce  对集合里面的每一个元素 作用在当前累计的结果上"></a>reduce  对集合里面的每一个元素 作用在当前累计的结果上</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 对集合里面的每一个元素 作用在当前累计的结果上</span><br><span class="line">let abc &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">print(abc.reduce(&quot;100&quot;) &#123; $0 + ($1 + &quot;kk&quot;) &#125;)</span><br><span class="line">&#x2F;&#x2F; 100akkbkkckk</span><br></pre></td></tr></table></figure>

<h1 id="flatMap-集合内的元素全是集合，那么把元素拆成同一级-放在一个新的集合里"><a href="#flatMap-集合内的元素全是集合，那么把元素拆成同一级-放在一个新的集合里" class="headerlink" title="flatMap 集合内的元素全是集合，那么把元素拆成同一级 放在一个新的集合里"></a>flatMap 集合内的元素全是集合，那么把元素拆成同一级 放在一个新的集合里</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [[1, 2, 3], [4, 5], [7]]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 集合内的元素全是集合，那么把元素拆成同一级 放在一个新的集合里</span><br><span class="line">print(list.flatMap &#123; $0 &#125;)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5, 7]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 只会拆一层</span><br><span class="line">let list1 &#x3D; [[1, 2, 3], [4, 5], [7], [[8], [9]]]</span><br><span class="line">print(list1.flatMap &#123; $0 &#125;)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5, 7, [8], [9]]</span><br></pre></td></tr></table></figure>

<h1 id="compactMap-过滤空值"><a href="#compactMap-过滤空值" class="headerlink" title="compactMap 过滤空值"></a>compactMap 过滤空值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let names: [String?] &#x3D; [&quot;am&quot;,nil,&quot;qw&quot;,&quot;er&quot;,nil]</span><br><span class="line">&#x2F;&#x2F;&#x2F; 过滤空值</span><br><span class="line">print(names.compactMap&#123; $0 &#125;)</span><br><span class="line">&#x2F;&#x2F;[&quot;am&quot;, &quot;qw&quot;, &quot;er&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 类型转换</title>
    <url>/2020/12/21/100-Swift-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="Swift-类型转换-as-的使用"><a href="#Swift-类型转换-as-的使用" class="headerlink" title="Swift 类型转换 as 的使用"></a>Swift 类型转换 as 的使用</h1><h2 id="if-let-as"><a href="#if-let-as" class="headerlink" title="if let as"></a>if let as</h2><p> 类型转换，此时 <code>btn</code> 是 <code>Any</code> 类型，使用 <code>as?</code> 将他尝试转为 <code>UIButton</code>类型。并赋值给 <code>a</code>。 实际开发中建议 <code>a</code> 与 <code>btn</code> 命名一致，这里为了便于区分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if let a &#x3D; btn as? UIButton &#123;</span><br><span class="line">    print(a)</span><br><span class="line">    &#x2F;&#x2F; 这里 a 为真</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="guard-let-as"><a href="#guard-let-as" class="headerlink" title="guard let as"></a>guard let as</h2><p>和 <code>if let as</code> 基本一致，只是当转换失败时提前退出。适用于一些异步回调里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let btn &#x3D; btn as? UIButton else &#123; return &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>在 Swift 中为 String 添加扩展</title>
    <url>/2021/06/05/100-Swift%E4%B8%ADString%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="String-extension-代码"><a href="#String-extension-代码" class="headerlink" title="String extension 代码"></a>String extension 代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">    func index(from: Int) -&gt; Index &#123;</span><br><span class="line">        &#x2F;&#x2F; 增加越界防护， 负数就不考虑了吧</span><br><span class="line">        if from &lt; count &#123;</span><br><span class="line">            return index(startIndex, offsetBy: from)</span><br><span class="line">        &#125;</span><br><span class="line">        return endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(from: Int) -&gt; String &#123;</span><br><span class="line">        let fromIndex &#x3D; index(from: from)</span><br><span class="line">        return String(self[fromIndex...])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(to: Int) -&gt; String &#123;</span><br><span class="line">        String(prefix(to))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(with r: Range&lt;Int&gt;) -&gt; String &#123;</span><br><span class="line">        let startIndex &#x3D; index(from: r.lowerBound)</span><br><span class="line">        let endIndex &#x3D; index(from: r.upperBound)</span><br><span class="line">        return String(self[startIndex ..&lt; endIndex])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;01234567&quot;</span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(from: 0) &#x2F;&#x2F; &quot;01234567&quot;</span><br><span class="line">_ &#x3D; str.substring(from: 4) &#x2F;&#x2F; &quot;4567&quot;</span><br><span class="line">_ &#x3D; str.substring(from: 100) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(to: 0) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line">_ &#x3D; str.substring(to: 1) &#x2F;&#x2F; &quot;0&quot;</span><br><span class="line">_ &#x3D; str.substring(to: 100) &#x2F;&#x2F; &quot;01234567&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(with: 0 ..&lt; 1) &#x2F;&#x2F; &quot;0&quot;</span><br><span class="line">_ &#x3D; str.substring(with: 0 ..&lt; 100) &#x2F;&#x2F; &quot;01234567&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift 协议与扩展</title>
    <url>/2020/12/25/100-Swift%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议 Protocol"></a>协议 Protocol</h1><h2 id="使用-Protocol-关键字创建一个协议"><a href="#使用-Protocol-关键字创建一个协议" class="headerlink" title="使用 Protocol 关键字创建一个协议"></a>使用 Protocol 关键字创建一个协议</h2><blockquote>
<p>让遵守该协议的 class 与 struct 实现约定一些方法与属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol PageNumberProtocol &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例属性</span><br><span class="line">    var pageNumber: Int &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例方法</span><br><span class="line">    func add()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类属性</span><br><span class="line">    static var name: String? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类方法</span><br><span class="line">    static func logName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遵守协议"><a href="#遵守协议" class="headerlink" title="遵守协议"></a>遵守协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Person: PageNumberProtocol &#123;</span><br><span class="line">    var pageNumber: Int</span><br><span class="line"></span><br><span class="line">    func add() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static var name: String?</span><br><span class="line"></span><br><span class="line">    static func logName() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car: PageNumberProtocol &#123;</span><br><span class="line">    var pageNumber: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">    func add() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static var name: String?</span><br><span class="line"></span><br><span class="line">    static func logName() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展-extension"><a href="#扩展-extension" class="headerlink" title="扩展 extension"></a>扩展 extension</h1><h2 id="扩展使用的很多应该都很熟悉"><a href="#扩展使用的很多应该都很熟悉" class="headerlink" title="扩展使用的很多应该都很熟悉"></a>扩展使用的很多应该都很熟悉</h2><blockquote>
<p>分散代码实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Car &#123;</span><br><span class="line">    func dididi() &#123;</span><br><span class="line">        print(&quot;滴滴滴&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car().dididi()</span><br></pre></td></tr></table></figure>

<h1 id="Protocl-Extension"><a href="#Protocl-Extension" class="headerlink" title="Protocl + Extension"></a>Protocl + Extension</h1><blockquote>
<p>给出协议并实现协议，这样遵守协议的 class 和 struct 就能直接使用协议方法。</p>
</blockquote>
<h2 id="runtime-添加属性"><a href="#runtime-添加属性" class="headerlink" title="runtime 添加属性"></a>runtime 添加属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getAssociatedObject&lt;T&gt;(_ object: Any, _ key: UnsafeRawPointer) -&gt; T? &#123;</span><br><span class="line">    return objc_getAssociatedObject(object, key) as? T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func setRetainedAssociatedObject&lt;T&gt;(_ object: Any, _ key: UnsafeRawPointer, _ value: T) &#123;</span><br><span class="line">    objc_setAssociatedObject(object, key, value, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protocol PageNumberProtocol &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例属性</span><br><span class="line">    var pageNumber: Int &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的实例方法</span><br><span class="line">    func add()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类属性</span><br><span class="line">    static var name: String? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加的类方法</span><br><span class="line">    static func logName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展遵守协议"><a href="#扩展遵守协议" class="headerlink" title="扩展遵守协议"></a>扩展遵守协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private var pageNumberKey: Void?</span><br><span class="line"></span><br><span class="line">private var nameKey: Void?</span><br><span class="line"></span><br><span class="line">extension UIViewController: PageNumberProtocol &#123;</span><br><span class="line">    static func logName() &#123;</span><br><span class="line">        debugPrint(name ?? &quot;无名&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static var name: String? &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            getAssociatedObject(self, &amp;nameKey)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            setRetainedAssociatedObject(self, &amp;nameKey, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func add() &#123;</span><br><span class="line">        pageNumber +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var pageNumber: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            getAssociatedObject(self, &amp;pageNumberKey) ?? 0</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            setRetainedAssociatedObject(self, &amp;pageNumberKey, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样所有遵守 PageNumberProtocol 协议的 UIViewController 就都有了协议要求的属性与方法且已经实现了。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Protocol</tag>
        <tag>Extension</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 实用技巧</title>
    <url>/2021/06/05/100-Swift%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="1-protocol-extension-初始化后直接配置相应属性"><a href="#1-protocol-extension-初始化后直接配置相应属性" class="headerlink" title="1. protocol + extension 初始化后直接配置相应属性"></a>1. protocol + extension 初始化后直接配置相应属性</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol XXXBuilder &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension XXXBuilder &#123;</span><br><span class="line">    public func with(configure: (inout Self) -&gt; Void) -&gt; Self &#123;</span><br><span class="line">        var this &#x3D; self</span><br><span class="line">        configure(&amp;this)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension NSObject: XXXBuilder &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">let tipLab &#x3D; UILabel().with &#123; lab in</span><br><span class="line">            lab.textColor &#x3D; .red</span><br><span class="line">            lab.backgroundColor &#x3D; .black</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Double-转-String-限制小数位数"><a href="#2-Double-转-String-限制小数位数" class="headerlink" title="2. Double 转 String,限制小数位数"></a>2. Double 转 String,限制小数位数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    func format(_ count: Int) -&gt; String &#123;</span><br><span class="line">        String(format: &quot;%.\(count)f&quot;, self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>第三方库提示</title>
    <url>/2020/11/11/100-Swift%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E3%80%81%E4%BB%A3%E7%A0%81%E4%B8%8D%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<h4 id="1-像OC的pch文件一样导入第三方库"><a href="#1-像OC的pch文件一样导入第三方库" class="headerlink" title="1.像OC的pch文件一样导入第三方库"></a>1.像OC的pch文件一样导入第三方库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个Swift文件，在导入的库前添加 @_exported</span><br><span class="line">🌰</span><br><span class="line"></span><br><span class="line">@_exported import Alamofire</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-Swift导入的第三方库代码没提示"><a href="#2-Swift导入的第三方库代码没提示" class="headerlink" title="2.Swift导入的第三方库代码没提示"></a>2.Swift导入的第三方库代码没提示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.选择target </span><br><span class="line">2.选择Build Settings </span><br><span class="line">3.搜索 User Header Search Paths</span><br><span class="line">4.填写 $(PODS_ROOT)，并设置为“recursive”  </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>Swift获取值的类型</title>
    <url>/2020/11/19/100-Swift%E8%8E%B7%E5%8F%96%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>使用 <code>type(of:)</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let a &#x3D; type(of:&quot;😄&quot;)</span><br><span class="line"></span><br><span class="line">print(a) &#x2F;&#x2F;String</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://developer.apple.com/documentation/swift/2885064-type" >直达文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>在Swift中使用 NSClassFromString</title>
    <url>/2020/11/02/100-%E5%9C%A8Swift%E4%B8%AD%E4%BD%BF%E7%94%A8-NSClassFromString/</url>
    <content><![CDATA[<p>在Swift中使用 NSClassFromString</p>
<p>需要 <code>工程名</code> + <code> .</code>  +  <code>string</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSClassFromString(Bundle.main.object(forInfoDictionaryKey: &quot;CFBundleName&quot;)! + &quot;.&quot; + &quot;CustomCell&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="每次写这些很麻烦-所以简单封装下"><a href="#每次写这些很麻烦-所以简单封装下" class="headerlink" title="每次写这些很麻烦,所以简单封装下"></a>每次写这些很麻烦,所以简单封装下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func GetClassFromString(_ classString: String) -&gt; AnyClass? &#123;</span><br><span class="line">    </span><br><span class="line">    guard let bundleName: String &#x3D; Bundle.main.object(forInfoDictionaryKey: &quot;CFBundleName&quot;) as? String else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    var anyClass: AnyClass? &#x3D; NSClassFromString(bundleName + &quot;.&quot; + classString)</span><br><span class="line">    if (anyClass &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        anyClass &#x3D; NSClassFromString(classString)</span><br><span class="line">    &#125;</span><br><span class="line">    return anyClass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以后就可以直接调用"><a href="#以后就可以直接调用" class="headerlink" title="以后就可以直接调用"></a>以后就可以直接调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetClassFromString(&quot;cellName&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 怎么保证可靠传输？</title>
    <url>/2021/02/04/1000-001TCP%20%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="1-TCP-怎么保证可靠传输？"><a href="#1-TCP-怎么保证可靠传输？" class="headerlink" title="1. TCP 怎么保证可靠传输？"></a>1. TCP 怎么保证可靠传输？</h1><blockquote>
<p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。</p>
</blockquote>
<p>TCP协议保证数据传输可靠性的方式主要有：</p>
<ol>
<li><strong>数据分割</strong> 应用数据被分割成 TCP 认为最合适发送的数据块。</li>
<li><strong>编号</strong> TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>检验和</strong> TTCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制</strong>  TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h1 id="2-ARQ-协议"><a href="#2-ARQ-协议" class="headerlink" title="2. ARQ 协议"></a>2. ARQ 协议</h1><p> <strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h2 id="2-1-停止等待ARQ协议"><a href="#2-1-停止等待ARQ协议" class="headerlink" title="2.1 停止等待ARQ协议"></a>2.1 停止等待ARQ协议</h2><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>优点：</strong> 简单<br><strong>缺点：</strong> 信道利用率低，等待时间长</p>
<h3 id="2-1-1-无差错情况"><a href="#2-1-1-无差错情况" class="headerlink" title="2.1.1 无差错情况"></a>2.1.1 无差错情况</h3><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<h3 id="2-1-2-出现差错情况（超时重传）"><a href="#2-1-2-出现差错情况（超时重传）" class="headerlink" title="2.1.2 出现差错情况（超时重传）"></a>2.1.2 出现差错情况（超时重传）</h3><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。 <strong>这种自动重传方式常称为 自动重传请求 ARQ 。</strong></p>
<p>另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<h3 id="2-1-3-确认丢失和确认迟到"><a href="#2-1-3-确认丢失和确认迟到" class="headerlink" title="2.1.3 确认丢失和确认迟到"></a>2.1.3 确认丢失和确认迟到</h3><ul>
<li><strong>确认丢失：</strong> 确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> 确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h2 id="2-2-连续ARQ协议"><a href="#2-2-连续ARQ协议" class="headerlink" title="2.2 连续ARQ协议"></a>2.2 连续ARQ协议</h2><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h1 id="3-滑动窗口和流量控制"><a href="#3-滑动窗口和流量控制" class="headerlink" title="3. 滑动窗口和流量控制"></a>3. 滑动窗口和流量控制</h1><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h1 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个<strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</p>
</li>
<li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p>
</li>
<li><p><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
</li>
</ul>
<blockquote>
<p>摘录于 <a class="link"   href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E5%9B%9B-tcp-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93" >https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=四-tcp-协议如何保证可靠传输<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>ARQ协议</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 中常见的拥塞控制算法有哪些？</title>
    <url>/2021/02/05/1000-002TCP%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h1><p>拥塞控制主要是四个算法：<br><strong>1.慢启动 2.拥塞避免 3.拥塞发生 4.快速恢复</strong></p>
<h2 id="1-慢启动算法-Slow-Start"><a href="#1-慢启动算法-Slow-Start" class="headerlink" title="1.慢启动算法 - Slow Start"></a>1.慢启动算法 - Slow Start</h2><p>在 TCP 连接刚建立时，一点一点提速，先试探网络的状况，避免扰乱了网络通道的秩序。<br>慢启动是指一开始向网络注入的报文段少，并不是指拥塞窗口 cwnd 增长速度慢。</p>
<ul>
<li><strong>慢启动算法：</strong></li>
</ul>
<ol>
<li>连接建好的开始先初始化拥塞窗口的 cwnd 大小为 1，表明可以传送一个 MSS 大小的数据。</li>
<li>每当收到一个 ACK，cwnd 大小加 1，呈线性上升。</li>
<li>每当过了一个往返延迟时间 RTT(Round-Trip TIme),cwnd 大小直接翻倍，乘以 2，呈指数上升。</li>
<li>还有一个 ssthresh(slow start threshold)，是一个上限(阈值)，当 cwnd &gt;= ssthresh 时就会进入“拥塞避免算法”。</li>
</ol>
<h2 id="2-拥塞避免算法-Congestion-Avoidance"><a href="#2-拥塞避免算法-Congestion-Avoidance" class="headerlink" title="2. 拥塞避免算法- Congestion Avoidance"></a>2. 拥塞避免算法- Congestion Avoidance</h2><p>当窗口大小 cwnd &gt;= 慢启动的阈值后，就会进入拥塞避免算法。<br>拥塞避免 不能完全避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为线性增长，避免窗口增长过快导致窗口拥塞。缓慢的增加调整到最佳状态，使网络比较不容易出现拥塞。</p>
<ul>
<li><strong>拥塞避免算法：</strong></li>
</ul>
<ol>
<li>收到一个 ACK，则 cwnd = cwnd + 1/cwnd</li>
<li>每当经过了一个往返延迟时间 RTT，cwnd 大小加 1。</li>
</ol>
<h2 id="3-拥塞状态时的算法"><a href="#3-拥塞状态时的算法" class="headerlink" title="3.拥塞状态时的算法"></a>3.拥塞状态时的算法</h2><p>TCP 拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的 TCP 拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判断方式，<strong>一种是超时重传 RTO(Retransmission Timeout)超时，另一个是收到三个重复确认 ACK</strong>。</p>
<ul>
<li><strong>超时重传 RTO(Retransmission Timeout)超时，TCP 会重传数据包。TCP 认为这种情况比较糟糕，反应也比较激烈：</strong></li>
</ul>
<ol>
<li>由于发生丢包，将慢启动阈值(ssthresh)设置为当前 cwnd 的一半，即 ssthresh = cwnd / 2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ol>
<p>早期的 TCP Tahoe 算法就是使用上述处理方法，由于一丢包就一切重来，导致 cwnd 又重置为 1，十分不利于网络数据的稳定传递。<br>所以，TCP Reno 算法进行了优化。当收到三个重复确认 ACK 时，TCP 开启快速重传 Fast Retransmit 算法，而不用等到 RTO 超时再进行重传</p>
<ul>
<li><strong>三个重复确认 ACK：</strong></li>
</ul>
<ol>
<li>cwnd 大小缩减为当前的一半。</li>
<li>ssthresh 设置为缩小后的 cwnd 大小</li>
<li>进入快速恢复算法 Fast Recovery。</li>
</ol>
<h2 id="4-快速恢复算法-Fast-Recovery"><a href="#4-快速恢复算法-Fast-Recovery" class="headerlink" title="4.快速恢复算法 - Fast Recovery"></a>4.快速恢复算法 - Fast Recovery</h2><p>TCP Tahoe 是早期的算法，所以没有快速恢复算法，而 Reno 算法有。在进入快速恢复之前，cwnd 和 ssthresh 已经被改为原有的 cwnd 的一半。</p>
<ol>
<li>cwnd = cwnd + 3 MSS，加 3 MSS 的原因是收到 3 个重复的 ACK。</li>
<li>重传 DACKs 指定数据包。</li>
<li>如果再收到 DACKs，那么 cwnd 大小增加 1。</li>
<li>如果收到新的 ACK，表明重传的包成功了，退出快速恢复算法。将 cwnd 设置为 ssthresh，然后进入拥塞避免算法。</li>
</ol>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 HTTPS 的加密与认证过程</title>
    <url>/2021/02/06/1000-003%E7%AE%80%E8%BF%B0%20HTTPS%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><ul>
<li><p>共享/对称密钥加密：客户端和服务端使用相同的密钥加密，缺陷：发送密钥有被窃听的风险，但不发送，对方就不能解密。如果密钥能够安全发送，那么数据也能安全送达，就无需加密。</p>
</li>
<li><p> 公开密钥加密：非对称加密，一把私钥，一把公钥，成对。首先，发送公钥给加密方，发送密文一方使用对方的公钥进行加密，对方收到密文后，使用自己的私钥进行解密。</p>
</li>
<li><p>混合加密：使用公开密钥加密方式传递共享密钥，再使用共享密钥加密传递的数据</p>
</li>
</ul>
<h1 id="证书的正确性：CA（数字认证机构）颁发的公开密钥证书"><a href="#证书的正确性：CA（数字认证机构）颁发的公开密钥证书" class="headerlink" title="证书的正确性：CA（数字认证机构）颁发的公开密钥证书"></a>证书的正确性：CA（数字认证机构）颁发的公开密钥证书</h1><ul>
<li>服务器把自己的公钥登录至CA进行认证；</li>
<li>CA机构使用自己的私钥给服务器的公钥署数字签名并颁发公钥证书；</li>
<li>客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥（事先植入到浏览器客户端），向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性；</li>
<li>使用服务器的公开密钥对报文加密并发送</li>
</ul>
<h1 id="SSL-TLS握手协议"><a href="#SSL-TLS握手协议" class="headerlink" title="SSL/TLS握手协议"></a>SSL/TLS握手协议</h1><ul>
<li>客户端给出协议版本号，一个随机数（client random），以及客户端支持的加密方式；</li>
<li>服务端确认双方使用的加密方式，并给出数字证书，以及一个服务器生成的随机数（server random）；</li>
<li>客户端确认证书有效，然后生成一个新的随机数（premaster secret），并使用数字证书的公钥加密这个随机数，发送给服务端；</li>
<li>服务端使用自己的私钥，获得客户端发送的随机数（premaster secret）;</li>
<li>客户端和服务端，根据约定的加密方式，使用前面的三个随机数，生成一个对话密钥（session key）,及共享密钥，然后使用该密钥加密整个数据交互过程。</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</title>
    <url>/2021/02/07/1000-004%E7%AE%80%E8%BF%B0%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><blockquote>
<p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p>
</blockquote>
<p><strong>第一次握手：</strong> 客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p><strong>第二次握手：</strong> 服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p><strong>第三次握手：</strong> 客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><blockquote>
<p>关闭时，发包顺序不一定。一般来说是客户端主动发起的关闭，过程如下。</p>
</blockquote>
<p><strong>第一次挥手：</strong> 当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p><strong>第二次挥手：</strong> 主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p><strong>第三次挥手：</strong> 主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p><strong>第四次挥手：</strong> 主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p>
<h1 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h1><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 与 HTTPS 有哪些区别？</title>
    <url>/2021/02/08/1000-005HTTP%20%E4%B8%8E%20HTTPS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1><ol>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ol>
<li>HyperText Transfer Protocol：超文本传输协议。</li>
<li>是一种用于分布式、协作式和超媒体信息系统的应用层协议。</li>
<li>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</li>
<li>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><ol>
<li>Hypertext Transfer Protocol Secure：安全的超文本传输协议。</li>
<li>是一种透过计算机网络进行安全通信的传输协议。</li>
<li>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。</li>
<li>HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</li>
<li>HTTPS 默认工作在 TCP 协议443端口</li>
</ol>
<h1 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h1><p><strong>1. 客户端发起 HTTPS 请求</strong><br><strong>2. 服务端的配置</strong><br>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>
<p><strong>3. 传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>
<p><strong>4. 客户端解析证书</strong><br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<p><strong>5. 传送加密信息</strong><br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p><strong>6. 服务端解密信息</strong><br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<p><strong>7. 传输加密后的信息</strong><br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<p><strong>8. 客户端解密信息</strong><br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://www.runoob.com/w3cnote/http-vs-https.html" >https://www.runoob.com/w3cnote/http-vs-https.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是跨域，什么情况下会发生跨域请求？</title>
    <url>/2021/02/09/1000-006%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h1><p>在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是跨域请求。</p>
<p>跨域的情况有：<br>同一域名不同端口<br>同一域名不同协议<br>域名不同 ip 相同<br>主域相同子域不同<br>不同域名</p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><ol>
<li>通过jsonp跨域</li>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ol>
<blockquote>
<p>摘录于 <a class="link"   href="https://cloud.tencent.com/developer/article/1175899" >https://cloud.tencent.com/developer/article/1175899<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>简述常见的 HTTP 状态码的含义（301，304，401，403）</title>
    <url>/2021/02/10/1000-007%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%20HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88301%EF%BC%8C304%EF%BC%8C401%EF%BC%8C403%EF%BC%89/</url>
    <content><![CDATA[<h1 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3** 重定向"></a>3** 重定向</h1><p><strong>300 Multiple Choice</strong><br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p><strong>301 Moved Permanently</strong><br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>
<p><strong>304 Not Modified</strong><br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p>
<p><strong>302 Found</strong><br>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>
<p><strong>303 See Other</strong><br>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</p>
<h1 id="4-客户端响应"><a href="#4-客户端响应" class="headerlink" title="4** 客户端响应"></a>4** 客户端响应</h1><p><strong>400 Bad Request</strong><br>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。</p>
<p><strong>401 Unauthorized</strong><br>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</p>
<p><strong>403 Forbidden</strong><br>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</p>
<p><strong>404 Not Found</strong><br>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<p><strong>405 Method Not Allowed</strong><br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<h1 id="5-服务端响应"><a href="#5-服务端响应" class="headerlink" title="5** 服务端响应"></a>5** 服务端响应</h1><p><strong>500 Internal Server Error</strong><br>服务器遇到了不知道如何处理的情况。</p>
<p><strong>501 Not Implemented</strong><br>此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。</p>
<p><strong>502 Bad Gateway</strong><br>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</p>
<p><strong>503 Service Unavailable</strong><br>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</p>
<h1 id="2-成功响应"><a href="#2-成功响应" class="headerlink" title="2** 成功响应"></a>2** 成功响应</h1><p><strong>200 OK</strong><br>请求成功。成功的含义取决于 HTTP 方法：<br>GET：资源已被提取并在消息正文中传输。<br>HEAD：实体标头位于消息正文中。<br>POST：描述动作结果的资源在消息体中传输。<br>TRACE：消息正文包含服务器收到的请求消息</p>
<p><strong>201 Created</strong><br>该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</p>
<p><strong>202 Accepted</strong><br>请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</p>
<p><strong>203 Non-Authoritative Information</strong><br>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。</p>
<h1 id="1-信息响应"><a href="#1-信息响应" class="headerlink" title="1** 信息响应"></a>1** 信息响应</h1><p><strong>100 Continue</strong><br>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p>
<p><strong>101 Switching Protocol</strong><br>该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。<br><strong>102 Processing (WebDAV)</strong><br>此代码表示服务器已收到并正在处理该请求，但没有响应可用。<br><strong>103 Early Hints</strong><br>此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 </p>
<blockquote>
<p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP 有拥塞控制吗？</title>
    <url>/2021/02/11/1000-008UDP/</url>
    <content><![CDATA[<h1 id="UDP-有拥塞控制吗？"><a href="#UDP-有拥塞控制吗？" class="headerlink" title="UDP 有拥塞控制吗？"></a>UDP 有拥塞控制吗？</h1><ol>
<li><strong>UDP 没有拥塞控制</strong>，网络出现拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。</li>
<li>UDP 支持一对一、一对多和多对的的交互通信。</li>
<li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<h1 id="TCP-与-UDP-的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。"><a href="#TCP-与-UDP-的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。" class="headerlink" title="TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。"></a>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</h1><h1 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h1><p>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及查错检测的功能。</p>
<h1 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h1><ol>
<li>UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表</li>
<li>UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li>
</ol>
<h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><ol>
<li>某些实时应用需要使用没有拥塞控制的 UDP，但很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，导致大家都无法正常接收。</li>
<li>还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠传输进行适当的改进，以减少数据的丢失。应用进程可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文</li>
</ol>
<blockquote>
<p><a class="link"   href="https://developer.aliyun.com/article/699136" >https://developer.aliyun.com/article/699136<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.runoob.com/w3cnote/summary-of-network.html#_label7" >https://www.runoob.com/w3cnote/summary-of-network.html#_label7<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</title>
    <url>/2021/02/12/1000-009DNS%20%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDNS%20%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="DNS-查询服务器的基本流程"><a href="#DNS-查询服务器的基本流程" class="headerlink" title="DNS 查询服务器的基本流程"></a>DNS 查询服务器的基本流程</h1><p><strong>查询顺序：</strong>浏览器缓存–&gt; 操作系统缓存–&gt; 本地 host 文件 –&gt; 路由器缓存–&gt; ISP DNS 缓存 –&gt; 顶级 DNS 服务器/根 DNS 服务器</p>
<p><strong>1. 浏览器缓存：</strong> 首先会向浏览器的缓存中读取上一次访问的记录，在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看缓存的当前状态 。</p>
<p><strong>2. 操作系统缓存：</strong> 查找存储在系统运行内存中的缓存。在 mac 中可以通过下面的命令清除系统中的 DNS 缓存。<br><code>dscacheutil -flushcache</code></p>
<p><strong>3. 本地 host 文件：</strong> 查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
<p><strong>4. 路由器缓存：</strong> 有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</p>
<p><strong>5. ISP DNS 缓存：</strong> 互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</p>
<p><strong>6. 顶级 DNS 服务器 / 根 DNS 服务器：</strong> 根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（baidu.com），本机继续查找，直到服务器找到(<a class="link"   href="http://www.baidu.com)的主机./" >www.baidu.com)的主机。<i class="fas fa-external-link-alt"></i></a><br>最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/t5awpd.png"
                      alt="过程图"
                ></p>
<p>上述图片是查找 <a class="link"   href="http://www.google.com/" >www.google.com<i class="fas fa-external-link-alt"></i></a> 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是</a> <a class="link"   href="http://www.google.com.,并不是我多打了一个.,这个.对应的就是根域名服务器,默认情况下所有的网址的最后一位都是.,既然是默认情况下,为了方便用户,通常都会省略,浏览器在请求/" >www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求<i class="fas fa-external-link-alt"></i></a> DNS 的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; <a class="link"   href="http://www.google.com../" >www.google.com.。<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="什么是-DNS-劫持？"><a href="#什么是-DNS-劫持？" class="headerlink" title="什么是 DNS 劫持？"></a>什么是 DNS 劫持？</h1><p>在 DNS 的解析中返回了一个假的 IP 地址给客户端，从而促使用户访问了错误的网站。</p>
<h1 id="DNS-劫持的方法"><a href="#DNS-劫持的方法" class="headerlink" title="DNS 劫持的方法"></a>DNS 劫持的方法</h1><p><strong>1. 本机 DNS 劫持</strong><br>攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地 DNS 配置，比如修改本地 hosts 文件，缓存等<br><strong>2. 路由 DNS 劫持</strong><br>很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置<br><strong>3.攻击 DNS 服务器</strong><br>直接攻击 DNS 服务器，例如对 DNS 服务器进行 DDOS 攻击，可以是 DNS 服务器宕机，出现异常请求，还可以利用某些手段感染 dns 服务器的缓存，使给用户返回来的是恶意的 ip 地址</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 OSI 七层模型，TCP，IP 属于哪一层？</title>
    <url>/2021/02/13/1000-010%E7%AE%80%E8%BF%B0%20OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8CTCP%EF%BC%8CIP%20%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.rruu.net/image/6027a373e47f9"
                     
                ></p>
<h1 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h1><p>1.应用层 2.传输层 3.网络层 4.网络接口层</p>
<h1 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h1><p>1.应用层 2.传输层 3.网络层 4.数据链路层 5.物理层</p>
<h1 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h1><p>1.物理层 2.数据链路层 3.网络层 4.传输层 5.会话层 6.表示层 7.应用层</p>
<h1 id="IP-协议属于网络层"><a href="#IP-协议属于网络层" class="headerlink" title="IP 协议属于网络层"></a>IP 协议属于网络层</h1><h1 id="TCP-协议属于传输层"><a href="#TCP-协议属于传输层" class="headerlink" title="TCP 协议属于传输层"></a>TCP 协议属于传输层</h1><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h2><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p>
<h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h2><p>最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</p>
<ol>
<li>基本数据单位为帧；</li>
<li>主要的协议：以太网协议；</li>
<li>两个重要设备名称：网桥和交换机。</li>
</ol>
<h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h2><p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是”路径选择、路由及逻辑寻址”。<br>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。</p>
<ol>
<li>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</li>
<li>基本数据单位为IP数据报；</li>
<li>包含的主要协议：<br>　　IP协议（Internet Protocol，因特网互联协议）;<br>　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;<br>　　ARP协议（Address Resolution Protocol，地址解析协议）;<br>　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</li>
<li>重要的设备：路由器。</li>
</ol>
<h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h2><p>传输层要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p>
<ol>
<li>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题</li>
<li>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）</li>
<li>重要设备：网关</li>
</ol>
<h2 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h2><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h2 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h2><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h2 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h2><p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>七层模型</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 TCP 粘包和拆包？</title>
    <url>/2021/02/14/1000-011%E4%BB%80%E4%B9%88%E6%98%AF%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="TCP-粘包和拆包"><a href="#TCP-粘包和拆包" class="headerlink" title="TCP 粘包和拆包"></a>TCP 粘包和拆包</h1><p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况。</p>
<ol>
<li><p>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，<strong>没有粘包和拆包</strong>；</p>
</li>
<li><p>服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，<strong>被称为 TCP 粘包</strong>；</p>
</li>
<li><p>服务端分两次读取到了两个数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，<strong>这被称为 TCP 拆包</strong>；</p>
</li>
<li><p>服务端分两次读取到了两个数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。<br>如果此时服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2 比较大，很有可能会发生第五种可能，即<strong>服务端分多次才能将 D1 和 D2 包接收完全，期间发生多次拆包</strong>。</p>
</li>
</ol>
<h1 id="TCP粘包-拆包发生的原因"><a href="#TCP粘包-拆包发生的原因" class="headerlink" title="TCP粘包/拆包发生的原因"></a>TCP粘包/拆包发生的原因</h1><ol>
<li><p>应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</p>
</li>
<li><p>进行 MSS 大小的 TCP 分段；</p>
</li>
<li><p>以太网帧的 payload 大于 MTU 进行 IP 分片。</p>
</li>
</ol>
<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>泛指通讯协议中的最大传输单元。一般用来说明TCP/IP四层协议中数据链路层的最大传输单元，不同类型的网络MTU也会不同，我们普遍使用的以太网的MTU是1500，即最大只能传输1500字节的数据帧。可以通过ifconfig命令查看电脑各个网卡的MTU。</p>
<h1 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h1><p>指TCP建立连接后双方约定的可传输的最大TCP报文长度，是TCP用来限制应用层可发送的最大字节数。如果底层的MTU是1500byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述对称与非对称加密的概念</title>
    <url>/2021/02/16/1000-012%E7%AE%80%E8%BF%B0%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密是最快速、最简单的一种加密方式，加密与解密用的是同样的密钥。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<p><strong>密钥交换的发送过程中有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</strong></p>
<h2 id="对称加密常用算法"><a href="#对称加密常用算法" class="headerlink" title="对称加密常用算法"></a>对称加密常用算法</h2><ol>
<li><strong>DES（Data Encryption Standard）</strong>：数据加密标准，速度较快，适用于加密大量数据的场合；</li>
<li><strong>3DES（Triple DES）</strong>：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li>
<li><strong>AES（Advanced Encryption Standard）</strong>：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密；</li>
</ol>
<h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><ol>
<li>加密方和解密方使用同一个密钥；</li>
<li>加密解密的速度比较快，适合数据比较长时的使用；</li>
<li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</li>
</ol>
<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p>
<h2 id="非对称加密常用算法"><a href="#非对称加密常用算法" class="headerlink" title="非对称加密常用算法"></a>非对称加密常用算法</h2><p>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。</p>
<p>使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。</p>
<h1 id="MD5-单向加密算法不可解密，属于散列算法。"><a href="#MD5-单向加密算法不可解密，属于散列算法。" class="headerlink" title="MD5 单向加密算法不可解密，属于散列算法。"></a>MD5 单向加密算法不可解密，属于散列算法。</h1><h1 id="Base64-是编码。"><a href="#Base64-是编码。" class="headerlink" title="Base64 是编码。"></a>Base64 是编码。</h1><blockquote>
<p>对称加密与非对称加密 <a class="link"   href="https://zhuanlan.zhihu.com/p/30573146" >https://zhuanlan.zhihu.com/p/30573146<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" >https://baike.baidu.com/item/对称加密<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 的方法有哪些？</title>
    <url>/2021/02/17/1000-013HTTP%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h1><p>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p>
<h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p>
<h1 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h1><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </p>
<h1 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h1><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p>
<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>DELETE方法删除指定的资源。</p>
<h1 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h1><p>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p>
<h1 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h1><p>OPTIONS方法用于描述目标资源的通信选项。</p>
<h1 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h1><p>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</p>
<h1 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h1><p>PATCH方法用于对资源应用部分修改。</p>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为HTTP动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享：: 例如一个请求方法可以是 safe(安全), idempotent(幂等), 或 cacheable(可缓存).</p>
<h2 id="safe-安全"><a href="#safe-安全" class="headerlink" title="safe(安全)"></a>safe(安全)</h2><p>如果说一个 HTTP 方法是安全的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD 和 OPTIONS。所有安全的方法都是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是。</p>
<h2 id="idempotent-幂等"><a href="#idempotent-幂等" class="headerlink" title="idempotent(幂等)"></a>idempotent(幂等)</h2><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p>
<h2 id="cacheable-可缓存"><a href="#cacheable-可缓存" class="headerlink" title="cacheable(可缓存)"></a>cacheable(可缓存)</h2><p>可缓存的响应是可被缓存的HTTP 响应，它被存储以供稍后检索和使用，从而将新的请求保存在伺服器。不是所有的 HTTP 响应都可以被缓存，可以被缓存的 HTTP 响应需满足如下列条件:</p>
<ul>
<li>请求中使用的方法本身是可以被缓存的，如 GET 或 HEAD 方法。如果下达了新的指示，响应 POST 方法也可以被缓存，但这种实施方式极为罕见。其他方法，如： PUT 或 DELETE 都不可以被缓存，同样他们的处理结果也不可以。</li>
<li>应用程式是会缓存已知的响应的状态码，并且被认为是可缓存的。这些可缓存的状态码如下： 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 和 501.</li>
<li>响应中没有指定的头部，如 Cache-Control，它可以阻止缓存。<br>请注意一些不缓存请求/响应到指定的 URI 可能会导致相同 URI 上以前的缓存响应失效。例如，  PUT 到 pageX.html 将使相同 URI 下所有的 GET 或 HEAD 请求缓存失效。</li>
</ul>
<blockquote>
<p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 JWT 的原理和校验机制</title>
    <url>/2021/02/17/1000-014%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。"><a href="#JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。" class="headerlink" title="JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。"></a>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。</h1><h1 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h1 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGcio1JIUZIINiIsInR5CCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIioiIxMiMONTY30DkwIiwibmFtZSI6IkpvaG4</span><br><span class="line">gRG9IIiwiaXNTb2NpYWwiOnRydWv9.</span><br><span class="line">4pcPyMD09oIPSyXnrXCjTwXyr4BsezdI1AVTmud2fU4</span><br></pre></td></tr></table></figure>
<p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>
<p>JWT 的三个部分依次如下。</p>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
<p>写成一行，就是下面的样子。<br><code>Header.Payload.Signature</code></p>
<h2 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h2 id="Payload（负载）"><a href="#Payload（负载）" class="headerlink" title="Payload（负载）"></a>Payload（负载）</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h2 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。<br><code>Authorization: Bearer &lt;token&gt;</code><br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。<br>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" >https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie 和 Session 的关系和区别是什么？</title>
    <url>/2021/02/18/1000-015Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="Cookie-和-Session-的关系和区别"><a href="#Cookie-和-Session-的关系和区别" class="headerlink" title="Cookie 和 Session 的关系和区别"></a>Cookie 和 Session 的关系和区别</h1><ol>
<li>Cookie 在客户端（浏览器），Session 在服务器端。 </li>
<li>Cookie 的安全性一般，他人可通过分析存放在本地的 Cookie 并进行 Cookie 欺骗。在安全性第一的前提下，选择 Session 更优。重要交互信息比如权限等就要放在 Session 中，一般的信息记录放 Cookie 就好了。 </li>
<li>单个 Cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 Cookie。 </li>
<li>Session 可以放在文件、数据库或内存中，比如在使用 Node 时将 Session 保存在 redis 中。由于一定时间内它是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用 Cookie。 </li>
<li>Session 的运行依赖 Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID）。 </li>
<li>用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即 Session ID。</li>
</ol>
<p>题外话，那么话说 Session Cookie 能被篡改么？ 理论上可以，只要改变了连接时的 Session ID 就可以了~</p>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息。如何识别特定的客户呢？cookie 就可以做到。每次 HTTP 请求时，客户端都会发送相应的 Cookie 信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。<br>既然它是存储在客户端的，换句话说通过某些手法我就可以篡改本地存储的信息来欺骗服务端的某些策略。</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session 是在无状态的 HTTP 协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。在浏览器关闭后这次的 Session 就消失了，下次打开就不再拥有这个 Session。其实并不是 Session 消失了，而是 Session ID 变了，服务器端可能还是存着你上次的 Session ID 及其 Session 信息，只是他们是无主状态，也许一段时间后会被删除。</p>
<hr>
<p>实际上 Cookie 与 Session 都是会话的一种方式。它们的典型使用场景比如 “购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建 Cookie/Session 来获取这些信息。</p>
<p>如果你的站点是多节点部署，使用 Nginx 做负载均衡，那么有可能会出现 Session 丢失的情况（比如，忽然就处于未登录状态）。这时可以使用 IP 负载均衡（IP 绑定 ip_hash，每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 Session 的问题），或者将 Session 信息存储在集群中。在大型的网站中，一般会有专门的 Session 服务器集群，用来保存用户会话，这时可以使用缓存服务比如 Memcached 或者 Redis 之类的来存放 Session。</p>
<p>目前大多数的应用都是用 Cookie 实现 Session 跟踪的。第一次创建 Session 时，服务端会通过在 HTTP 协议中反馈到客户端，需要在 Cookie 中记录一个 Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用 URL 重写技术进行会话跟踪，即每次 HTTP 交互，URL 后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://ruby-china.org/topics/33313" >https://ruby-china.org/topics/33313<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</title>
    <url>/2021/02/21/1000-016TCP%20%E4%B8%8E%20UDP%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="TCP-与-UDP-在网络协议中的哪一层？"><a href="#TCP-与-UDP-在网络协议中的哪一层？" class="headerlink" title="TCP 与 UDP 在网络协议中的哪一层？"></a>TCP 与 UDP 在网络协议中的哪一层？</h1><p><strong>属于传输层协议</strong></p>
<h1 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h1><ol>
<li><p><strong>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。</strong></p>
</li>
<li><p><strong>TCP注重数据安全性，UDP数据传输快。</strong>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
</li>
<li><p><strong>UDP具有较好的实时性，工作效率比TCP高，</strong>适用于对高速传输和实时性有较高的通信或广播通信。</p>
</li>
<li><p><strong>TCP 一对一， UDP 一对一、一对多、多对一、多对多。</strong> 每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li><p><strong>TCP对系统资源要求较多，UDP对系统资源要求较少。</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 TCP 滑动窗口以及重传机制</title>
    <url>/2021/02/21/1000-017%E7%AE%80%E8%BF%B0%20TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h1><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。（TCP 会在以下两种情况发生超时重传：数据包丢失，确认应答丢失）</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 http 1.0，1.1，2.0 的主要区别</title>
    <url>/2021/02/22/1000-018%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>http1.0 到 http1.1 的主要区别<ol>
<li>从无连接到长连接，可连续发送请求。在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>
<li>具有 range 头可请求部分数据。</li>
<li>host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>
<li>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码。</li>
</ol>
</li>
<li>http2.0 对比 1.X 版本主要区别<ol>
<li>多路复用即连接共享，即每一个 request 都是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request。</li>
<li>服务端推送</li>
<li>header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li>
<li>新的二进制格式， HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式。</li>
</ol>
</li>
</ul>
<h1 id="http-1-0-特性"><a href="#http-1-0-特性" class="headerlink" title="http 1.0 特性"></a>http 1.0 特性</h1><h2 id="1-无状态"><a href="#1-无状态" class="headerlink" title="1. 无状态"></a>1. 无状态</h2><p>服务器不跟踪不记录请求过的状态<br>对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录</p>
<h2 id="2-无连接"><a href="#2-无连接" class="headerlink" title="2. 无连接"></a>2. 无连接</h2><p>浏览器每次请求都需要建立 tcp 连接</p>
<p>无连接导致的性能缺陷有两种：</p>
<ol>
<li>无法复用连接<br>每次发送请求，都需要进行一次 tcp 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低</li>
<li>队头阻塞<br>http1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li>
</ol>
<h1 id="http-1-1-特性"><a href="#http-1-1-特性" class="headerlink" title="http 1.1 特性"></a>http 1.1 特性</h1><p>为了解决 http1.0 的性能缺陷，http1.1 出现了</p>
<h2 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1. 长连接"></a>1. 长连接</h2><p>http1.1 默认保持长连接，数据传输完成保持 tcp 连接不断开,继续用这个通道传输数据。<br>新增 Connection 字段，可以设置 keep-alive 值保持连接不断开。</p>
<h2 id="2-管道化"><a href="#2-管道化" class="headerlink" title="2. 管道化"></a>2. 管道化</h2><p>基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p>
<p>基于长连接的基础，我们先看没有管道化请求响应：<br>tcp 没有断开，用的同一个通道<br><code>请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></p>
<p>管道化的请求响应：<br><code>请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</code><br>即使服务器先准备好响应 2,也是按照请求顺序先返回响应 1<br>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h2 id="3-缓存处理"><a href="#3-缓存处理" class="headerlink" title="3. 缓存处理"></a>3. 缓存处理</h2><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。<br>新增字段 cache-control 来控制</p>
<h2 id="4-断点传输"><a href="#4-断点传输" class="headerlink" title="4. 断点传输"></a>4. 断点传输</h2><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率<br>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p>
<h1 id="http-2-0-特性"><a href="#http-2-0-特性" class="headerlink" title="http 2.0 特性"></a>http 2.0 特性</h1><h2 id="1-二进制分帧"><a href="#1-二进制分帧" class="headerlink" title="1. 二进制分帧"></a>1. 二进制分帧</h2><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p>
<h2 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2. 多路复用"></a>2. 多路复用</h2><p>在共享 TCP 链接的基础上同时发送请求和响应<br>一个 Tcp 中多个 http 请求是并行的</p>
<h2 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h2><p>http2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<h2 id="4-服务器推送"><a href="#4-服务器推送" class="headerlink" title="4. 服务器推送"></a>4. 服务器推送</h2><p>服务器可以额外的向客户端推送资源，而无需客户端明确的请求</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>简述 TCP 的 TIME_WAIT</title>
    <url>/2021/02/22/1000-019%E7%AE%80%E8%BF%B0%20TCP%20%E7%9A%84%20TIME_WAIT/</url>
    <content><![CDATA[<h1 id="为什么-TIME-WAIT"><a href="#为什么-TIME-WAIT" class="headerlink" title="为什么 TIME_WAIT"></a>为什么 TIME_WAIT</h1><p>主动关闭连接的一方最终进入 <code>TIME_WAIT</code> 状态等待一段才真正的释放内核中的连接记录，在释放记录之前这个连接使用的本地端口将一直被占用。<br>保持一段时间的 <code>TIME_WAIT</code> 的理由是：担心 <code>ack N+1</code> 没有送达，导致被动方重传 <code>FIN N</code>，那么主动方应当再次响应 <code>ack N+1</code>。<br>如果没有 <code>TIME_WAIT</code> 就直接复用该连接占用的端口，那么万一被动方重传<code>FIN N</code>，那么使用相同端口的新连接就会被错误关闭。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/m8c6bs.png"
                      alt="四次挥手"
                ></p>
<h1 id="优化-TIME-WAIT"><a href="#优化-TIME-WAIT" class="headerlink" title="优化 TIME_WAIT"></a>优化 TIME_WAIT</h1><p>谁主动关闭 <code>socket</code>，谁<code>TIME_WAIT</code>。<br>如果双方响应正常，TIME_WAIT 应该只是瞬间状态。</p>
<h1 id="服务端主动关闭"><a href="#服务端主动关闭" class="headerlink" title="服务端主动关闭"></a>服务端主动关闭</h1><p>无论有多少连接，服务端都只有一个端口，那就是监听端口，大量连接之间的差异仅仅是 TCP 4 元祖的客户端 ip 和 port 不同而已。</p>
<p>因此服务端<code>TIME_WAIT</code>压根不会耗尽端口，因为它就一个端口。</p>
<p>那么服务端就不需要优化了吗？对，没必要优化，一个<code>TIME_WAIT</code>的 4 元祖当遇到新的 SYN 时会复用，不需要特殊配置。</p>
<p>另外，当<code>TIME_WAIT</code>数量超过内核选项 net.ipv4.tcp_max_tw_buckets 的限制时，多余的<code>TIME_WAIT</code>连接将被立即关闭，然后在 netstat -s 中留下如下的溢出统计指标：</p>
<h1 id="客户端主动关闭"><a href="#客户端主动关闭" class="headerlink" title="客户端主动关闭"></a>客户端主动关闭</h1><p>客户端每个连接都会随机选择一个本地端口，所以最终会导致客户端大量端口处于 TIME_WAIT 状态，这和服务端主动关闭是最大的不同。<br>所以我们通常所说的 TIME_WAIT 问题都是针对客户端的，只是好像很少有人提及这一点。<br>网上有一种优化手段是把 net.ipv4.tcp_max_tw_buckets 调低，这样 TIME_WAIT 连接就会被删除，但是这不是一个最佳手段哈。</p>
<p>目前唯一安全的选项就是同时开启如下 2 个选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;1（连接发起方和接收方都需要开启）</span><br><span class="line">net.ipv4.tcp_tw_reuse&#x3D;1（只影响连接发起方）</span><br></pre></td></tr></table></figure>

<p>上述配置只影响连接发起方，也就是客户端，对服务端是无效的。<br>它的作用是向外发起连接的时候，可以复用 TIME_WAIT 的端口，但是有一个前提<br>该端口最后一次通讯时间距离当前系统时间&gt;1 秒</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://yuerblog.cc/2020/03/09/%E5%85%B3%E4%BA%8Etime_wait%E9%97%AE%E9%A2%98%E7%AE%80%E8%BF%B0%E4%B8%8E%E4%BC%98%E5%8C%96/" >https://yuerblog.cc/2020/03/09/关于time_wait问题简述与优化/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是中间人攻击？如何防止攻击？</title>
    <url>/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h1><p>A &lt;—-&gt; B<br>A &lt;—-&gt; C &lt;—-&gt; B<br>正常是 A 和 B 通信，这时 C 截获了 A 发给 B 的消息，然后假装成 A 给 B 发送消息。</p>
<p>中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。<br>在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL 协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p>
<h1 id="如何防止中间人攻击？"><a href="#如何防止中间人攻击？" class="headerlink" title="如何防止中间人攻击？"></a>如何防止中间人攻击？</h1><p>使用由 CA (数字证书认证机构 Certificate Authority)签发或签名的数子证书 来提供认证和加密。证书必须放入服务器和客户端中。</p>
<p>要信任某个证书真实有效，该证书必须通过属于可信认证中心 (CA) 的根证书进行数字签名。操作系统和浏览器维护有可信 CA 根证书的列表，以便可以轻松验证 CA 签发和签名的证书。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" >https://zh.wikipedia.org/wiki/中间人攻击<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN" >https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>ARP 地址解析协议的原理和地址解析过程</title>
    <url>/2021/06/02/1000-ARP%20%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="ARP-地址解析协议的原理和地址解析过程"><a href="#ARP-地址解析协议的原理和地址解析过程" class="headerlink" title="ARP 地址解析协议的原理和地址解析过程"></a>ARP 地址解析协议的原理和地址解析过程</h1><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48 位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
<p>使用 ARP 的 4 种情况：</p>
<ol>
<li>发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>
<li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>
</ol>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>IP 协议的定义和作用</title>
    <url>/2021/06/02/1000-IP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成了 TCP/IP 协议族的核心。</p>
<p>IP 协议主要有以下几个作用：</p>
<ul>
<li>寻址和路由：在 IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li>
<li>分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>IPV4 地址不够如何解决</title>
    <url>/2021/06/02/1000-IPV4%20%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="IPV4-地址不够如何解决"><a href="#IPV4-地址不够如何解决" class="headerlink" title="IPV4 地址不够如何解决"></a>IPV4 地址不够如何解决</h1><ul>
<li><p><strong>DHCP：</strong> 动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</p>
</li>
<li><p><strong>CIDR：</strong> 无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效的分配 IPv4 的地址空间，但无法从根本上解决地址耗尽问题。</p>
</li>
<li><p><strong>NAT：</strong> 网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</p>
</li>
<li><p><strong>IPv6 ：</strong> 作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个 IP 地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>IPV4</tag>
      </tags>
  </entry>
  <entry>
    <title>网络地址转换 NAT</title>
    <url>/2021/06/02/1000-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20NAT/</url>
    <content><![CDATA[<h1 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h1><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p>
<p>NAT 的实现方式主要有三种：</p>
<ul>
<li><p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p>
</li>
<li><p>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p>
</li>
<li><p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>路由器和交换机的区别</title>
    <url>/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h1><ul>
<li><strong>交换机：</strong> 交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li>
</ul>
<ul>
<li><strong>路由器：</strong> 路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li>
</ul>
<ul>
<li>交换机的端口不具有实际的 MAC 地址,因此交换机只是把接收到的消息转发出去而已，它的各端口并不以实际的发送方或接收方的身份参与到以太网包的传递过程；而路由器的端口具有 MAC 地址 IP 地址，所以它的端口是作为以太网包实际的接收方与发送方的身份存在的。</li>
<li>当交换机不知道将包转发到哪一个端口时，它会将包转发到除了源端口以外的所有端口；而当路由器不知道将包转发到哪一端口时，它就直接丢弃这个包。产生这种区别的原因是他们所连接的网络的规模不同——交换机工作在局域网，它所连接的网络规模比较小，向所有端口转发也不会造成多大问题；但路由器工作的环境是互联网，它的规模是远大于互联网的，若向所有端口转发则会产生大量的网络包，造成网络拥塞。</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>路由器的分组转发流程</title>
    <url>/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="路由器的分组转发流程"><a href="#路由器的分组转发流程" class="headerlink" title="路由器的分组转发流程"></a>路由器的分组转发流程</h1><ol>
<li><p>从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络；</p>
</li>
<li><p>判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 2.；</p>
</li>
<li><p>检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4.；</p>
</li>
<li><p>逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5.；</p>
</li>
<li><p>若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6.；</p>
</li>
<li><p>无法找到合适路由，向源主机报错。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>运输层协议和网络层协议的区别</title>
    <url>/2021/06/02/1000-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="运输层协议和网络层协议的区别"><a href="#运输层协议和网络层协议的区别" class="headerlink" title="运输层协议和网络层协议的区别"></a>运输层协议和网络层协议的区别</h1><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>RxSwift-Observable订阅、监听</title>
    <url>/2020/11/12/200-RxSwift-Observable%E8%AE%A2%E9%98%85%E3%80%81%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 直接订阅所有的</span><br><span class="line">ob.subscribe &#123; event in</span><br><span class="line">    print(&quot;事件&quot;, event)</span><br><span class="line">&#x2F;&#x2F; 通过 event.element 可以获取值</span><br><span class="line">    print(&quot;值是&quot;, event.element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;分开订阅</span><br><span class="line">ob.subscribe &#123; element in</span><br><span class="line">    print(&quot;onNext&quot;, element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(&quot;onError&quot;, error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125; onDisposed: &#123;</span><br><span class="line">    print(&quot;onDisposed&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;仅订阅 onNext</span><br><span class="line">ob.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="监听-do"><a href="#监听-do" class="headerlink" title="监听 do"></a>监听 do</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">ob.do &#123; element in</span><br><span class="line">    print(&quot;onNext&quot;, element)</span><br><span class="line">&#125; afterNext: &#123; element in</span><br><span class="line">    print(&quot;afterNext&quot;, element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(&quot;onError&quot;, error)</span><br><span class="line">&#125; afterError: &#123; error in</span><br><span class="line">    print(&quot;afterError&quot;, error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125; afterCompleted: &#123;</span><br><span class="line">    print(&quot;afterCompleted&quot;)</span><br><span class="line">&#125; onSubscribe: &#123;</span><br><span class="line">    print(&quot;onSubscribe&quot;)</span><br><span class="line">&#125; onSubscribed: &#123;</span><br><span class="line">    print(&quot;onSubscribed&quot;)</span><br><span class="line">&#125; onDispose: &#123;</span><br><span class="line">    print(&quot;onDispose&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 这里是订阅部分</span><br><span class="line">.subscribe &#123; element in</span><br><span class="line">    print(&quot;onNext&quot;, element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(&quot;onError&quot;, error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125; onDisposed: &#123;</span><br><span class="line">    print(&quot;onDisposed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-Single、Completab、Maybe</title>
    <url>/2020/11/22/200-RxSwift-Single%E3%80%81Completab%E3%80%81Maybe/</url>
    <content><![CDATA[<h1 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h1><p>只发出一次事件，常用于网络请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum DataError: Error &#123;</span><br><span class="line">    case error1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData() -&gt; Single&lt;[String: Any]&gt; &#123;</span><br><span class="line">    return Single&lt;[String: Any]&gt;.create &#123; (single) -&gt; Disposable in</span><br><span class="line">        single(.success([&quot;&quot;: 1]))</span><br><span class="line">&#x2F;&#x2F;                single(.error(DataError.error1))</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData().subscribe &#123; req in</span><br><span class="line">    switch req &#123;</span><br><span class="line">    case .success(let value):</span><br><span class="line">        print(value)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h1><p>只会发出<code>completed</code>或<code>error</code> 事件，用于只关心操作结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func cancel() -&gt; Completable &#123;</span><br><span class="line">    return Completable.create &#123; (comp) -&gt; Disposable in</span><br><span class="line">        comp(.completed)</span><br><span class="line">&#x2F;&#x2F;                comp(.error(ObError.error1))</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancel().subscribe &#123; rep in</span><br><span class="line">    switch rep &#123;</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;成功&quot;)</span><br><span class="line">    case let .error(error):</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h1><p>也是只能发出一个事件，正常的<code>event</code>或<code>completed </code>或<code>error</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func test() -&gt; Maybe&lt;String&gt; &#123;</span><br><span class="line">    return Maybe&lt;String&gt;.create &#123; (mayBe) -&gt; Disposable in</span><br><span class="line">        mayBe(.success(&quot;成功&quot;))</span><br><span class="line">&#x2F;&#x2F;                mayBe(.completed)</span><br><span class="line">&#x2F;&#x2F;                mayBe(.error(ObError.error1))</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().subscribe &#123; event in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .success(let value):</span><br><span class="line">        print(value)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-创建可观察序列</title>
    <url>/2020/11/11/200-RxSwift-%E5%88%9B%E5%BB%BA%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="empty-方法初始化"><a href="#empty-方法初始化" class="headerlink" title="empty() 方法初始化"></a>empty() 方法初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建了一个空内容的 Observable</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.empty()</span><br><span class="line">&#x2F;&#x2F; 先简单的写一种订阅的方法</span><br><span class="line">ob.subscribe &#123; print(&quot;执行了&quot;) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="just-方法-传入默认值初始化"><a href="#just-方法-传入默认值初始化" class="headerlink" title="just() 方法 传入默认值初始化"></a>just() 方法 传入默认值初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里不用给定泛型，会根据 just 自动推倒出</span><br><span class="line">let ob &#x3D; Observable.just(&quot;初始化默认值&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="of-方法-传入可变数量的值，但必须是同一类型"><a href="#of-方法-传入可变数量的值，但必须是同一类型" class="headerlink" title="of() 方法 传入可变数量的值，但必须是同一类型"></a>of() 方法 传入可变数量的值，但必须是同一类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(&quot;可&quot;, &quot;变&quot;, &quot;数&quot;, &quot;量&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="from-传入数组初始化"><a href="#from-传入数组初始化" class="headerlink" title="from() 传入数组初始化"></a>from() 传入数组初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.from([&quot;数&quot;, &quot;组&quot;])</span><br></pre></td></tr></table></figure>

<h3 id="never-永远不会发出-event-的-Observable-序列"><a href="#never-永远不会发出-event-的-Observable-序列" class="headerlink" title="never() 永远不会发出 event 的 Observable 序列"></a>never() 永远不会发出 event 的 Observable 序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Any&gt;.never()</span><br></pre></td></tr></table></figure>

<h3 id="error-直接发送一个错误"><a href="#error-直接发送一个错误" class="headerlink" title="error() 直接发送一个错误"></a>error() 直接发送一个错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum OBError: Error &#123;</span><br><span class="line">    case abc</span><br><span class="line">&#125;</span><br><span class="line">let ob &#x3D; Observable&lt;OBError&gt;.error(OBError.abc)</span><br></pre></td></tr></table></figure>

<h3 id="interval-每一秒发送一次"><a href="#interval-每一秒发送一次" class="headerlink" title="interval() 每一秒发送一次"></a>interval() 每一秒发送一次</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br></pre></td></tr></table></figure>

<h3 id="timer-定时发送"><a href="#timer-定时发送" class="headerlink" title="timer() 定时发送"></a>timer() 定时发送</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3 秒后，仅发送一次</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.timer(3, scheduler: MainScheduler.instance)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3 秒后，每 2 秒发送一次</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.timer(3, period: 2, scheduler: MainScheduler.asyncInstance)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-发送、订阅-Subjects、Variables</title>
    <url>/2020/11/15/200-RxSwift-%E5%8F%91%E9%80%81%E3%80%81%E8%AE%A2%E9%98%85-Subjects%E3%80%81Variables/</url>
    <content><![CDATA[<h1 id="Subjects-介绍"><a href="#Subjects-介绍" class="headerlink" title="Subjects 介绍"></a>Subjects 介绍</h1><h3 id="1-Subjects-是订阅者，也是Observable"><a href="#1-Subjects-是订阅者，也是Observable" class="headerlink" title="1. Subjects 是订阅者，也是Observable"></a>1. <code>Subjects</code> 是订阅者，也是<code>Observable</code></h3><ul>
<li>订阅者：它能动态的接收新的值。</li>
<li><code>Observable</code>： 当<code>Subjects</code>有了新值后会通过<code>Event</code>将新值发出给他的所有订阅者。</li>
</ul>
<hr>
<h3 id="2-常用的方法"><a href="#2-常用的方法" class="headerlink" title="2. 常用的方法"></a>2. 常用的方法</h3><p><code>onNext(:)：</code>是<code> on(.next(:))</code> 的简便写法。该方法相当于 <code>subject</code> 接收到一个<code>.next</code> 事件。<br><code>onError(:)：</code>是<code>on(.error(:))</code>的简便写法。该方法相当于 <code>subject</code> 接收到一个<code> .error</code> 事件。<br><code>onCompleted()：</code>是 <code>on(.completed)</code>的简便写法。该方法相当于 <code>subject</code> 接收到一个 <code>.completed</code>事件。</p>
<hr>
<h3 id="3-Subjects-有四种PublishSubject、BehaviorSubject、ReplaySubject、Variable"><a href="#3-Subjects-有四种PublishSubject、BehaviorSubject、ReplaySubject、Variable" class="headerlink" title="3. Subjects 有四种PublishSubject、BehaviorSubject、ReplaySubject、Variable"></a>3. <code>Subjects</code> 有四种<code>PublishSubject</code>、<code>BehaviorSubject</code>、<code>ReplaySubject</code>、<code>Variable</code></h3><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>都是<code>Observable</code>，他们的订阅者都能接收他们发出的新的<code>Event</code></li>
<li>直到 <code>Subject</code> 发出 <code>.complete</code> 或者 <code>.error</code> 的 <code>Event</code> 后，该 <code>Subject</code> 便终结了，同时它也就不会再发出<code>.next</code>事件。</li>
<li>对于那些在<code> Subject</code> 终结后再订阅他的订阅者，也能收到 <code>subject</code>发出的一条<code> .complete</code> 或<code> .error</code>的<code> event</code>，告诉这个新的订阅者它已经终结了。<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5></li>
<li> <code>PublishSubject</code><br>最普通的<code>Subject</code>，不需要初始值就能初始化。<br>他的订阅者只能收到他们订阅后的 <code>Event</code>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;订阅之前的不能接收到&quot;)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(event.element)</span><br><span class="line">&#x2F;&#x2F;Optional(&quot;订阅之后的可以接收到&quot;)</span><br><span class="line">&#x2F;&#x2F;nil</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;订阅之后的可以接收到&quot;)</span><br><span class="line">&#x2F;&#x2F;结束</span><br><span class="line">sub.onCompleted()</span><br><span class="line">&#x2F;&#x2F;&#x2F; 结束之后添加的订阅能收到 completed</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;结束后发的都收不到&quot;)</span><br></pre></td></tr></table></figure></li>
<li><code>BehaviorSubject</code><br>需要一个默认值初始化<br>当一个订阅者订阅之后会立马收到上一个<code>Event</code>，之后就是正常情况发一个收一个。<br><code>onCompleted()</code>之后的订阅者也只能收到<code>Completed</code>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; BehaviorSubject(value: &quot;默认值&quot;)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅1&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onNext(&quot;发送1&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅2&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onCompleted()</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅3&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">订阅1 next(默认值)</span><br><span class="line">订阅1 next(发送1)</span><br><span class="line">订阅2 next(发送1)</span><br><span class="line">订阅1 completed</span><br><span class="line">订阅2 completed</span><br><span class="line">订阅3 completed</span><br></pre></td></tr></table></figure></li>
<li><code>ReplaySubject</code><br>创建的时候需要一个参数<code>bufferSize</code>设置记录个数<br>新添加的订阅会接收到之前发送的两个  <code>Event</code>，如果不足两个就只接收一个。<br>如果超过两个只接收最新的两个。<br>如果订阅时已经结束除了会接收到最新的两个<code>Event</code>外还有结束的<code>complete </code>或<code>error </code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; ReplaySubject&lt;String&gt;.create(bufferSize: 2)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅1&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onNext(&quot;发送1&quot;)</span><br><span class="line">print(&quot;-------&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅2&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;发送2&quot;)</span><br><span class="line">sub.onNext(&quot;发送3&quot;)</span><br><span class="line">sub.onNext(&quot;发送4&quot;)</span><br><span class="line">print(&quot;-------&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅3&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.onCompleted()</span><br><span class="line">print(&quot;-------&quot;)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 不仅会收到最后的两个 event 还有 Completed</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;订阅4&quot;, event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">订阅1 next(发送1)</span><br><span class="line">-------</span><br><span class="line">订阅2 next(发送1)</span><br><span class="line">订阅1 next(发送2)</span><br><span class="line">订阅2 next(发送2)</span><br><span class="line">订阅1 next(发送3)</span><br><span class="line">订阅2 next(发送3)</span><br><span class="line">订阅1 next(发送4)</span><br><span class="line">订阅2 next(发送4)</span><br><span class="line">-------</span><br><span class="line">订阅3 next(发送3)</span><br><span class="line">订阅3 next(发送4)</span><br><span class="line">订阅1 completed</span><br><span class="line">订阅2 completed</span><br><span class="line">订阅3 completed</span><br><span class="line">-------</span><br><span class="line">订阅4 next(发送3)</span><br><span class="line">订阅4 next(发送4)</span><br><span class="line">订阅4 completed</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BehaviorRelay </code><br>基本同 <code>BehaviorSubject </code>功能一样，但是不能主动调用<code>onCompleted</code>和<code>error </code>，会在<code>BehaviorRelay </code>释放前调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; BehaviorRelay(value: &quot;初始值&quot;)</span><br><span class="line"></span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;第一次订阅&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">sub.accept(&quot;新值1&quot;)</span><br><span class="line">sub.subscribe &#123; event in</span><br><span class="line">    print(&quot;第二次订阅&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>









</li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-延迟、超时、delay、timeout</title>
    <url>/2020/11/20/200-RxSwift-%E5%BB%B6%E8%BF%9F%E3%80%81%E8%B6%85%E6%97%B6%E3%80%81delay%E3%80%81timeout/</url>
    <content><![CDATA[<h1 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h1><p>对所有发送事件(包括<code>onCompleted</code>)后延迟 n 秒接收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.delay(RxTimeInterval.seconds(2), scheduler: MainScheduler.asyncInstance).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;发送了&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h1><p> 设置超时时间，超过规定时间的事件将发送  <code>error</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.timeout(RxTimeInterval.seconds(3), scheduler: MainScheduler.instance).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;发送1&quot;)</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 4) &#123;</span><br><span class="line">    ob.onNext(&quot;超时发送&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;next(发送1)</span><br><span class="line">&#x2F;&#x2F;error(Sequence timeout.)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-插入发送合并压缩-startWith、merge、zipignoreElement</title>
    <url>/2020/11/18/200-RxSwift-%E6%8F%92%E5%85%A5%E5%8F%91%E9%80%81%E5%90%88%E5%B9%B6%E5%8E%8B%E7%BC%A9-startWith%E3%80%81merge%E3%80%81zip/</url>
    <content><![CDATA[<h1 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h1><p>在订阅的时候插入发送事件，后加入的先发送。完成事件发送时不会插入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.startWith(&quot;插入1&quot;).startWith(&quot;插入2&quot;).subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;发送1&quot;)</span><br><span class="line">插入2</span><br><span class="line">插入1</span><br><span class="line">发送1</span><br></pre></td></tr></table></figure>

<h1 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h1><p>合并操作，将多个 <code>Observable</code> 合并成一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let ob2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.of(ob1,ob2).merge().subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob1.onNext(&quot;ob1 发1&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2 发1&quot;)</span><br><span class="line">ob1.onNext(&quot;ob1 发2&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2 发2&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><p>将 n 个<code>Observable</code>压缩成一个发送事件，必须每个都参与的发送完才会发送一次事件。参与的成对发送完</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let ob2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.zip(ob1,ob2).subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob1.onNext(&quot;ob1  2&quot;)</span><br><span class="line">ob1.onNext(&quot;ob1  3&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2  A&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2  B&quot;)</span><br><span class="line">ob2.onNext(&quot;ob2  C&quot;)</span><br><span class="line">ob1.onNext(&quot;ob1  1&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;next((&quot;ob1  2&quot;, &quot;ob2  A&quot;))</span><br><span class="line">&#x2F;&#x2F;next((&quot;ob1  3&quot;, &quot;ob2  B&quot;))</span><br><span class="line">&#x2F;&#x2F;next((&quot;ob1  1&quot;, &quot;ob2  C&quot;))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-绑定-bind、bindTo、Binder</title>
    <url>/2020/11/13/200-RxSwift-%E7%BB%91%E5%AE%9A-bind%E3%80%81bindTo%E3%80%81Binder/</url>
    <content><![CDATA[<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br><span class="line"></span><br><span class="line">ob.map &#123;</span><br><span class="line">&#x2F;&#x2F; 对值进一步处理然后返回</span><br><span class="line">    &quot;count &quot; + &quot;\($0)&quot;</span><br><span class="line">&#125;</span><br><span class="line">.bind &#123; text in</span><br><span class="line">    countLab.text &#x3D; text</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">ob.bind &#123; x in</span><br><span class="line">    print(x)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h3 id="Binder-bindTo"><a href="#Binder-bindTo" class="headerlink" title="Binder + bindTo"></a>Binder + bindTo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br><span class="line">let observer: Binder&lt;String&gt; &#x3D; Binder(countLab) &#123; lab, text in</span><br><span class="line">    lab.text &#x3D; text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob.map &#123;</span><br><span class="line">    &quot;c&quot; + &quot;\($0)&quot;</span><br><span class="line">&#125;</span><br><span class="line">.bind(to: observer)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-自定义可绑属性</title>
    <url>/2020/11/14/200-RxSwift-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E7%BB%91%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="对-Reactive-进行扩展"><a href="#对-Reactive-进行扩展" class="headerlink" title="对 Reactive 进行扩展"></a>对 Reactive 进行扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 给 UILabel 增加了 fontSize 可绑属性</span><br><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(base) &#123; lab, size in</span><br><span class="line">            lab.font &#x3D; UIFont.systemFont(ofSize: size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">let ob &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.asyncInstance)</span><br><span class="line">ob.map &#123; CGFloat($0) + 10.0 &#125;</span><br><span class="line">    .bind(to: lab.rx.fontSize) &#x2F;&#x2F; 这里要使用 .rx</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-订阅操作过滤1-map、buffer、filter</title>
    <url>/2020/11/16/200-RxSwift-%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C%E8%BF%87%E6%BB%A41-map%E3%80%81buffer%E3%80%81filter/</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>同 <code>Swift</code>中 <code>map</code> 用法一样，对值进行处理并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">sub.map &#123; $0 + &quot;mmmmm&quot; &#125;</span><br><span class="line">    .subscribe &#123; event in</span><br><span class="line">        print(event.element)</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">sub.onNext(&quot;a&quot;)</span><br><span class="line">&#x2F;&#x2F;Optional(&quot;ammmmm&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h1><p><code>timeSpan </code> 缓存间隔时间、              <code>count </code>缓存个数 、  <code>scheduler </code>线程<br>发送两个<code>event</code>后会触发订阅。满 2 秒也会触发订阅 ，如果<code>event</code> 没有发送空数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sub &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">sub.buffer(timeSpan: 2, count: 2, scheduler: MainScheduler.asyncInstance)</span><br><span class="line">    .subscribe &#123; event in</span><br><span class="line">        print(&quot;订阅1&quot;, event)</span><br><span class="line">    &#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sub.onNext(&quot;发送1&quot;)</span><br><span class="line">sub.onNext(&quot;发送2&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p>过滤 同<code>Swift</code>中<code>filter</code>一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(10, 11, 12, 99, 33, 55, 77)</span><br><span class="line">ob.filter &#123; $0 &gt; 20</span><br><span class="line">&#125;.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-订阅操作过滤2-distinctUntilChanged、single、elementAt、ignoreElement</title>
    <url>/2020/11/17/200-RxSwift-%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C%E8%BF%87%E6%BB%A42-distinctUntilChanged%E3%80%81single%E3%80%81elementAt%E3%80%81ignoreElement/</url>
    <content><![CDATA[<h1 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h1><p>过滤连续重复的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(1, 1, 1, 3, 5, 7, 9, 9)</span><br><span class="line">ob.distinctUntilChanged().subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#x2F;&#x2F;1 3 5 7 9</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="single"><a href="#single" class="headerlink" title="single"></a>single</h1><p>只发送一次正常事件，如果没有或者超过 1 个会发送 <code>error</code> 事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(1,2)</span><br><span class="line">ob.single().subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(&quot;错误&quot;,error)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;        1</span><br><span class="line">&#x2F;&#x2F;        错误 Sequence contains more than one element.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;----- single 增加过滤</span><br><span class="line">let ob &#x3D; Observable.of(1, 2, 1)</span><br><span class="line">ob.single &#123; $0 &#x3D;&#x3D; 2 &#125;.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(&quot;错误&quot;, error)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;        2</span><br></pre></td></tr></table></figure>

<h1 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h1><p>获取指定位置的事件，0 开始。 如果没有发生该指定位置事件 会发送错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0, 1, 2, 3, 4)</span><br><span class="line">ob.elementAt(2).subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>

<h1 id="ignoreElements"><a href="#ignoreElements" class="headerlink" title="ignoreElements"></a>ignoreElements</h1><p>会忽略所有主动发送的<code>event</code>事件，只保留 <code>error</code> 事件和 <code>Completed</code>事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0,1,2,3,4)</span><br><span class="line">ob.ignoreElements().subscribe &#123;</span><br><span class="line">    print(&quot;Completed&quot;)</span><br><span class="line">&#125; onError: &#123; (error) in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h1 id="take"><a href="#take" class="headerlink" title="take"></a>take</h1><p>只取前 n 个事件，数量达到或不足会发送 <code>Completed</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0, 1, 2, 3)</span><br><span class="line">ob.take(2).subscribe &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h1><p>只取后 n 个事件，数量达到或不足会发送 <code>Completed</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0, 1, 2, 3, 4)</span><br><span class="line">ob.takeLast(12).subscribe &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h1><p>跳过前 n 个事件，发送完剩下的事件后会发送<code>onCompleted</code>。不足 n 个直接发送<code>onCompleted</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; Observable.of(0,1,2,3,4,5)</span><br><span class="line">ob.skip(4).subscribe &#123; (element) in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; (error) in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;onCompleted&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><p>当两个事件的发送间隔大于约定时间时才会收到该事件，常用的例子是搜索时延迟搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.debounce(RxTimeInterval.seconds(1), scheduler: MainScheduler.instance).subscribe(onNext: &#123; element in</span><br><span class="line">    print(&quot;收&quot;, element, CFAbsoluteTimeGetCurrent())</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">print(&quot;发&quot;, &quot;aaa&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">ob.onNext(&quot;aaa&quot;)</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 0.5) &#123;</span><br><span class="line">    print(&quot;发&quot;, &quot;bbb&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">    ob.onNext(&quot;bbb&quot;)</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 1.5) &#123;</span><br><span class="line">    print(&quot;发&quot;, &quot;ccc&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">    ob.onNext(&quot;ccc&quot;)</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 3.5) &#123;</span><br><span class="line">    print(&quot;发&quot;, &quot;ddd&quot;, CFAbsoluteTimeGetCurrent())</span><br><span class="line">    ob.onNext(&quot;ddd&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发 aaa 627481044.719082</span><br><span class="line">&#x2F;&#x2F;发 bbb 627481045.241852</span><br><span class="line">&#x2F;&#x2F;发 ccc 627481046.231139</span><br><span class="line">&#x2F;&#x2F;收 ccc 627481047.233378</span><br><span class="line">&#x2F;&#x2F;发 ddd 627481048.552644</span><br><span class="line">&#x2F;&#x2F;收 ddd 627481049.55595</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-转数组、累计操作-toArray、reduce</title>
    <url>/2020/11/19/200-RxSwift-%E8%BD%AC%E6%95%B0%E7%BB%84%E3%80%81%E7%B4%AF%E8%AE%A1%E6%93%8D%E4%BD%9C-toArray%E3%80%81reduce/</url>
    <content><![CDATA[<h1 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h1><p>将所有的事件集合在一起作为一个数组发出，需要发送<code>onCompleted</code>事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.toArray().subscribe &#123; strArr in</span><br><span class="line">    print(strArr)</span><br><span class="line">&#125; onError: &#123; _ in</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;1&quot;)</span><br><span class="line">ob.onNext(&quot;2&quot;)</span><br><span class="line">ob.onNext(&quot;3&quot;)</span><br><span class="line">ob.onCompleted()</span><br></pre></td></tr></table></figure>

<h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><p>累计操作，将每一次的事件都累积在一起在发送<code>onCompleted</code>时统一发送。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ob &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">ob.reduce(&quot;初始值&quot;, accumulator: +).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob.onNext(&quot;1&quot;)</span><br><span class="line">ob.onNext(&quot;2&quot;)</span><br><span class="line">ob.onNext(&quot;3&quot;)</span><br><span class="line">ob.onCompleted()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift-错误处理、重试-catchError、retry</title>
    <url>/2020/11/21/200-RxSwift-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81%E9%87%8D%E8%AF%95-catchError%E3%80%81retry/</url>
    <content><![CDATA[<h1 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a>catchError</h1><p>当发送了<code>error</code>事件后可以返回一个新的序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ObError: Error &#123;</span><br><span class="line">    case error1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ob1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let ob2 &#x3D; PublishSubject.of(&quot;A&quot;, &quot;B&quot;)</span><br><span class="line"></span><br><span class="line">ob1.catchError &#123; (error) -&gt; Observable&lt;String&gt; in</span><br><span class="line">    print(error)</span><br><span class="line">    return ob2</span><br><span class="line">&#125;.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">ob1.onNext(&quot;111&quot;)</span><br><span class="line">ob1.onError(ObError.error1)</span><br><span class="line">&#x2F;&#x2F;next(111)</span><br><span class="line">&#x2F;&#x2F;error1</span><br><span class="line">&#x2F;&#x2F;next(A)</span><br><span class="line">&#x2F;&#x2F;next(B)</span><br><span class="line">&#x2F;&#x2F;completed</span><br></pre></td></tr></table></figure>
<h1 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h1><p>当发送了<code>error</code>后可以重新发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isFail &#x3D; true</span><br><span class="line">let obs &#x3D; Observable&lt;String&gt;.create &#123; (ob) -&gt; Disposable in</span><br><span class="line">    ob.onNext(&quot;成功1&quot;)</span><br><span class="line">    if isFail &#123;</span><br><span class="line">        ob.onError(ObError.error1)</span><br><span class="line">        isFail &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    ob.onNext(&quot;重试成功&quot;)</span><br><span class="line">    ob.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obs.retry(2).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">next(成功1)</span><br><span class="line">next(成功1)</span><br><span class="line">next(重试成功)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>674. 最长连续递增序列</title>
    <url>/2021/02/21/2000-001-674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a class="link"   href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" >674. 最长连续递增序列<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/a0hi84.png"
                      alt="题目描述"
                ></p>
<h1 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func findLengthOfLCIS(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        var start &#x3D; 0</span><br><span class="line">        var maxCount &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for (index, _) in nums.enumerated() &#123;</span><br><span class="line">            if index &gt; 0, nums[index] &lt;&#x3D; nums[index - 1] &#123;</span><br><span class="line">                start &#x3D; index</span><br><span class="line">            &#125;</span><br><span class="line">            let currentCount &#x3D; index - start + 1</span><br><span class="line">            maxCount &#x3D; (maxCount &gt; currentCount) ? maxCount : currentCount</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func findLengthOfLCIS(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        if nums.count &lt; 2 &#123;</span><br><span class="line">            return nums.count</span><br><span class="line">        &#125;</span><br><span class="line">        var maxCount &#x3D; 0</span><br><span class="line">        var preNumber &#x3D; nums.first</span><br><span class="line">        var tempCount &#x3D; 0</span><br><span class="line">        for item in nums &#123;</span><br><span class="line">            let isAdd &#x3D; item &gt; preNumber!</span><br><span class="line">            if isAdd &#123;</span><br><span class="line">                tempCount +&#x3D; 1</span><br><span class="line">                maxCount &#x3D; (maxCount &gt; tempCount) ? maxCount : tempCount</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tempCount &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">            preNumber &#x3D; item</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount + 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2021/02/21/2000-002-108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a class="link"   href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" >108. 将有序数组转换为二叉搜索树<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/hq8ztg.png"
                      alt="108. 将有序数组转换为二叉搜索树"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func sortedArrayToBST(_ nums: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">    return sortTree(nums, 0, nums.count - 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sortTree(_ nums: [Int], _ left: Int, _ right: Int) -&gt; TreeNode? &#123;</span><br><span class="line">    if left &gt; right &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    let mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">    let root &#x3D; TreeNode(nums[mid])</span><br><span class="line">    root.left &#x3D; sortTree(nums, left, mid - 1)</span><br><span class="line">    root.right &#x3D; sortTree(nums, mid + 1, right)</span><br><span class="line"></span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <url>/2021/02/21/2000-003-1382.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382. 将二叉搜索树变平衡"></a><a class="link"   href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" >1382. 将二叉搜索树变平衡<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/qm12q4.png"
                      alt="1382. 将二叉搜索树变平衡"
                ></p>
<h1 id="先变为有序递增数组，再平衡"><a href="#先变为有序递增数组，再平衡" class="headerlink" title="先变为有序递增数组，再平衡"></a>先变为有序递增数组，再平衡</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    func balanceBST(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        getList(root)</span><br><span class="line">        return buildTree(list, 0, list.count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func buildTree(_ nums: [Int], _ left: Int, _ right: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if left &gt; right &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">        let root &#x3D; TreeNode(nums[mid])</span><br><span class="line">        root.left &#x3D; buildTree(nums, left, mid - 1)</span><br><span class="line">        root.right &#x3D; buildTree(nums, mid + 1, right)</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉搜索树</span><br><span class="line">&#x2F;&#x2F;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； </span><br><span class="line">&#x2F;&#x2F; 所以采用中序遍历  先左 再根 最后右  刚好是递增数组</span><br><span class="line">    func getList(_ root: TreeNode?) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        getList(root.left)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        getList(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/2021/02/21/2000-004-33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" >33. 搜索旋转排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/8z9prz.png"
                      alt="33. 搜索旋转排序数组"
                ></p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func search(_ nums: [Int], _ target: Int) -&gt; Int &#123;</span><br><span class="line">        if nums.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return (nums[0] &#x3D;&#x3D; target) ? 0 : -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; nums.count - 1</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; left &lt;&#x3D; right 说明相遇了 在变就错过</span><br><span class="line">        while left &lt;&#x3D; right &#123; </span><br><span class="line">            &#x2F;&#x2F; 确定中间值</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; nums[mid] &lt; nums[right] 说明 mid 右边是有序递增的</span><br><span class="line">            if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">                &#x2F;&#x2F;如果 target 值在这个有序递增的范围内那就能确定 left 了，这里包含了右边等于 target 值的情况</span><br><span class="line">                if target &gt; nums[mid], target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right &#x3D; mid - 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; nums[mid] &gt; nums[right]  说明突变值（最小值）在 mid 右边，则 mid 左边是有序递增的</span><br><span class="line">                if target &gt;&#x3D; nums[left], target &lt; nums[mid] &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果 target 值在这个有序递增的范围内那就能确定 right 了，这里包含了左边等于 target 值的情况</span><br><span class="line">                    right &#x3D; mid - 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2021/02/21/2000-005-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a class="link"   href="https://leetcode-cn.com/problems/linked-list-cycle/" >141. 环形链表<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/3k71ua.png"
                      alt="141. 环形链表"
                ></p>
<h1 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        var slowTree &#x3D; head</span><br><span class="line">        var fastTree &#x3D; head?.next</span><br><span class="line"></span><br><span class="line">        while slowTree !&#x3D; nil || fastTree !&#x3D; nil &#123;</span><br><span class="line">            if slowTree &#x3D;&#x3D;&#x3D; fastTree &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            slowTree &#x3D; slowTree?.next</span><br><span class="line">            fastTree &#x3D; fastTree?.next?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        &#x2F;&#x2F; 注意这里使用 Set, 使用 Array 会超时</span><br><span class="line">        &#x2F;&#x2F; ListNode 需要实现 Equatable, Hashable 协议</span><br><span class="line">        var list: Set&lt;ListNode&gt; &#x3D; []</span><br><span class="line">        var head &#x3D; head</span><br><span class="line"></span><br><span class="line">        while head !&#x3D; nil &#123;</span><br><span class="line">            if list.contains(head!) &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            list.insert(head!)</span><br><span class="line">            head &#x3D; head?.next</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swift-链表-及-实现协议"><a href="#Swift-链表-及-实现协议" class="headerlink" title="Swift 链表 及 实现协议"></a>Swift 链表 及 实现协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    public var val: Int</span><br><span class="line">    public var next: ListNode?</span><br><span class="line">    public init() &#123; self.val &#x3D; 0; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int) &#123; self.val &#x3D; val; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int, _ next: ListNode?) &#123; self.val &#x3D; val; self.next &#x3D; next &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Equatable &#123;</span><br><span class="line">    public static func &#x3D;&#x3D; (l: ListNode, r: ListNode) -&gt; Bool &#123;</span><br><span class="line">        return l &#x3D;&#x3D;&#x3D; r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Hashable &#123;</span><br><span class="line">    public func hash(into hasher: inout Hasher) &#123;</span><br><span class="line">        hasher.combine(ObjectIdentifier(self))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>912. 排序数组</title>
    <url>/2021/02/22/2000-006-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/sort-an-array/" >912. 排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/stmaiz.png"
                      alt="912. 排序数组"
                ></p>
<h1 id="快速排序-递归解法"><a href="#快速排序-递归解法" class="headerlink" title="快速排序 递归解法"></a>快速排序 递归解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">        var nums &#x3D; nums</span><br><span class="line">        sort2(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort2(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        if left &lt; right &#123;</span><br><span class="line">            let p &#x3D; partition(&amp;nums, left, right)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值左边的数据 分界值的位置已经确定 所以传入 right &#x3D; p - 1</span><br><span class="line">            sort2(&amp;nums, left, p - 1)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值右边的数据 分界值的位置已经确定 所以传入 left &#x3D; p + 1</span><br><span class="line">            sort2(&amp;nums, p + 1, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func partition(_ nums: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 直接以 nums[right] 为分界值</span><br><span class="line">        let p &#x3D; nums[right]</span><br><span class="line">        &#x2F;&#x2F; 记录下一个 比分界值小的值 应该移动到哪个位置， 默认为最左边</span><br><span class="line">        var minL &#x3D; left</span><br><span class="line">        for i in left ..&lt; right &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前值 小于等于分界值，那么交换 i 和 minL 的值。否则不做处理</span><br><span class="line">            if nums[i] &lt;&#x3D; p &#123;</span><br><span class="line">                swap(&amp;nums, minL, i)</span><br><span class="line">                &#x2F;&#x2F; minL 已经被小于等于分界值的值占用，那么 +&#x3D; 1</span><br><span class="line">                minL +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 到这里，在 minL 索引 前的值都是小于等于 分界值的，在 minL 到 right - 1，包括 minL 的值都是大于 分界值的。 分界值一直在最后</span><br><span class="line">        &#x2F;&#x2F; 所以 把分界值 和 nums[minL] 交换位置</span><br><span class="line">        swap(&amp;nums, minL, right)</span><br><span class="line">        &#x2F;&#x2F; 返回分界值所在的 位置</span><br><span class="line">        return minL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func swap(_ nums: inout [Int], _ a: Int, _ b: Int) &#123;</span><br><span class="line">        let temp &#x3D; nums[a]</span><br><span class="line">        nums[a] &#x3D; nums[b]</span><br><span class="line">        nums[b] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序-迭代解法"><a href="#快速排序-迭代解法" class="headerlink" title="快速排序 迭代解法"></a>快速排序 迭代解法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">         var nums &#x3D; nums</span><br><span class="line">        sort(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        &#x2F;&#x2F; 取中间值 做为当前的 分界值</span><br><span class="line">        let pivot &#x3D; nums[(right - left) &#x2F; 2 + left]</span><br><span class="line">        var L &#x3D; left</span><br><span class="line">        var R &#x3D; right</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; L &lt; R 说明 L 和 R 没相遇</span><br><span class="line">        while L &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 左边的数小于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从左往右  所以 L +&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数大于 pivot ， 那么跳出这个循环 且这个数的索引位 L</span><br><span class="line"></span><br><span class="line">            while nums[L] &lt; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 右边的数大于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从右往左 所以 R -&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数小于 pivot ， 那么跳出这个循环 且这个数的索引位 R</span><br><span class="line"></span><br><span class="line">            while nums[R] &gt; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; L &gt;&#x3D; R 说明 pivot 左边已经是 全部小于等于 pivot ，右边 全部是 大于等于 pivot。 可以提前退出</span><br><span class="line">            if L &gt;&#x3D; R &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 跳出了上边的两个循环之后 说明 分别找到了</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 左边，但大于等于 pivot 的数，它的索引为 L</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 右边，但小于等于 pivot 的数，它的索引位 R</span><br><span class="line">            &#x2F;&#x2F; 那么交换这两个数的位置</span><br><span class="line"></span><br><span class="line">            let temp &#x3D; nums[L]</span><br><span class="line">            nums[L] &#x3D; nums[R]</span><br><span class="line">            nums[R] &#x3D; temp</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 交换完后 nums[L] 是小于等于 pivot, nums[R] 是大于等于 pivot</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[L] &#x3D;&#x3D; pivot 了,要让 R -&#x3D; 1，</span><br><span class="line">            if nums[L] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[R] &#x3D;&#x3D; pivot 了,要让 L +&#x3D; 1</span><br><span class="line">            if nums[R] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果不处理 交换完后 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 的情况，</span><br><span class="line">            &#x2F;&#x2F; 当 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 都是 true 时，</span><br><span class="line">            &#x2F;&#x2F; 上边的两个 while 也不会在执行了， 那么 L 和 R 的数值也不会再发生变化 就卡死在这里了</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 到这里 L &gt;&#x3D; R 说明相遇了</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 左边的数都是 小于等于 pivot 的</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 右边的数都是 大于等于 pivot 的</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这一步是防止对 pivot 左右分别操作时越界</span><br><span class="line">        if L &#x3D;&#x3D; R &#123;</span><br><span class="line">            L +&#x3D; 1</span><br><span class="line">            R -&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if left &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 左边的数据</span><br><span class="line">            sort(&amp;nums, left, R)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if right &gt; L &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 右边的数据</span><br><span class="line">            sort(&amp;nums, L, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子序和-简单</title>
    <url>/2021/02/23/2000-007-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a class="link"   href="https://leetcode-cn.com/problems/maximum-subarray/" >53. 最大子序和<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/o6raa6.png"
                      alt="53. 最大子序和"
                ></p>
<h1 id="动态规划-解法"><a href="#动态规划-解法" class="headerlink" title="动态规划 解法"></a>动态规划 解法</h1><ul>
<li>时间复杂度 O(n)<br>一次遍历，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li>
<li>空间复杂度 O(1)<br>只开辟了两个额外的空间，即只需要常数空间存放若干变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func maxSubArray(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为和</span><br><span class="line">        var sum &#x3D; nums[0]</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为当前最大值</span><br><span class="line">        var ans &#x3D; nums[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 因为已经把 nums[0] 计算了，所以从 nums[1] 开始</span><br><span class="line">        for i in 1 ..&lt; nums.count &#123;</span><br><span class="line">            if sum &lt; 0 &#123; &#x2F;&#x2F; 如果 sum 小于 0 ，那么 sum + nums[i] 只会让 nums[i] 更小</span><br><span class="line">                sum &#x3D; nums[i] &#x2F;&#x2F; 所以接把 num[i] 赋值给 sum</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; sum &gt;&#x3D; 0 那么就直接加 nums[i] 不用考虑 nums[i] 是大于零 还是小于零</span><br><span class="line">                sum &#x3D; sum + nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; (sum &gt; ans) ? sum : ans</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>94. 二叉树的中序遍历 - 中等</title>
    <url>/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p>
<p>二叉树中序遍历顺序为 左 根 右<br>当根节点的左子树为空时添加该根节点，即在 root.left = nil, 后 add root.val</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度 O(n)<br>空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        inorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func inorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 中序遍历 左 中 右</span><br><span class="line">        &#x2F;&#x2F; 即中序遍历，左根右。当根结点的左子树为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即前序遍历，根左右。当根节点不为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即后序遍历，左右根。当根节点的左右子树均为空时，那么 add root.val</span><br><span class="line">        inorder(root.left, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        inorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul>
<li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>
<li>空间复杂度 O(n)<br>空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var tempList: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line"></span><br><span class="line">        while root !&#x3D; nil || !tempList.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                tempList.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; tempList.popLast()</span><br><span class="line">            list.append(root!.val)</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>144. 二叉树的前序遍历 - 中等</title>
    <url>/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" >144. 二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p>
<p>二叉树的前序遍历 根 左 右</p>
<p>当根节点不为空时,直接把 root.val add list</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        preorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func preorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        preorder(root.left, &amp;list)</span><br><span class="line">        preorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>145. 二叉树的后序遍历 - 中等</title>
    <url>/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" >145. 二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p>
<p>二叉树的后序遍历 左 右 根</p>
<p>当根节点的左右子树均为空的时候 add root.val</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func postorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        postorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func postorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        postorder(root.left, &amp;list)</span><br><span class="line">        postorder(root.right, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="真迭代解法"><a href="#真迭代解法" class="headerlink" title="真迭代解法"></a>真迭代解法</h1><ul>
<li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func postorderTraversal1(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 用来记录回退的根节点 在回退的时候 要判断这个是不是刚刚回退的节点 如果不加判断会死循环</span><br><span class="line">        var lastTree: TreeNode?</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; root.right &#x3D;&#x3D; nil 时做下列操作很容易理解</span><br><span class="line">            if root?.right &#x3D;&#x3D; nil || root?.right &#x3D;&#x3D;&#x3D; lastTree &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                &#x2F;&#x2F; 这个时候要回退了，所以先记录当前的这个节点</span><br><span class="line">                lastTree &#x3D; root</span><br><span class="line">                &#x2F;&#x2F; 要把 root 置 nil 进行回退， 否则又是死循环</span><br><span class="line">                root &#x3D; nil</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="假后序解法"><a href="#假后序解法" class="headerlink" title="假后序解法"></a>假后序解法</h1><ul>
<li>时间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。 一个 n 是所有节点的遍历，另一个是最后的反转</li>
<li>空间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。一个 n 是迭代栈的开销，一个是最后反转的开销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func postorderTraversal2(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 后序遍历的顺序是  左右根</span><br><span class="line">        &#x2F;&#x2F; 反转后是 根右左，和前序遍历的 根左右 很像</span><br><span class="line">        &#x2F;&#x2F; 所以来用前序遍历的变形写法，然后把得的数据反转就行了</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.reversed()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>155. 最小栈 - 简单</title>
    <url>/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a class="link"   href="https://leetcode-cn.com/problems/min-stack/" >155. 最小栈<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/g135og.png"
                      alt="155. 最小栈"
                ></p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ul>
<li>时间复杂度<br>对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是<br>O(1)，我们定义的每个操作最多调用栈操作两次。</li>
<li>空间复杂度<br>其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;记录当前最小值</span><br><span class="line">    var minNum: Int?</span><br><span class="line">    &#x2F;&#x2F;只存最小值</span><br><span class="line">    var minNums: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    func push(_ x: Int) &#123;</span><br><span class="line">        list.append(x)</span><br><span class="line">        minNum &#x3D; min(minNum ?? .max, x)</span><br><span class="line">        if minNum &#x3D;&#x3D; x &#123;</span><br><span class="line">            minNums.append(minNum!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func pop() &#123;</span><br><span class="line">        let p &#x3D; list.removeLast()</span><br><span class="line">        if minNum &#x3D;&#x3D; p &#123;</span><br><span class="line">            minNum &#x3D; list.min()</span><br><span class="line">            minNums.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func top() -&gt; Int &#123;</span><br><span class="line">        return list.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getMin() -&gt; Int &#123;</span><br><span class="line">        return minNums.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>112. 路径总和 - 简单</title>
    <url>/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a class="link"   href="https://leetcode-cn.com/problems/path-sum/" >112. 路径总和<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/lxqfb4.png"
                      alt="112. 路径总和"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n),每个节点都要访问一次</li>
<li>空间复杂度<br>O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        if root.left &#x3D;&#x3D; nil, root.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">            return root.val &#x3D;&#x3D; targetSum</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 递归每次用当前的 sum - 当前 root.val</span><br><span class="line">        &#x2F;&#x2F; 一直 减减减 减到 叶子节点， 就判断当前的 sum 和 root.val 是否相等即可</span><br><span class="line">        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="广度优先解法"><a href="#广度优先解法" class="headerlink" title="广度优先解法"></a>广度优先解法</h1><ul>
<li>时间复杂度<br>O(n),每个节点都要访问一次</li>
<li>空间复杂度<br>O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; &#x2F;&#x2F; 如果 root &#x3D; nil 那么就一定不存在了</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var stackTree: [TreeNode] &#x3D; [root]</span><br><span class="line">        var treeVal: [Int] &#x3D; [root.val]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;           1</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;   \</span><br><span class="line">        &#x2F;&#x2F;        2     3</span><br><span class="line">        &#x2F;&#x2F;       &#x2F; \    &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;      4   5   6  7</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 1 添加 2 3,同时 treeVal 移除 1.val 添加 1+2.val ，1+3.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 2 添加 4 5,同时 treeVal 移除 2.val 添加 2+4.val ，2+5.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 3 添加 6 7,同时 treeVal 移除 3.val 添加 3+6.val ，3+7.val</span><br><span class="line">        while !stackTree.isEmpty &#123;</span><br><span class="line">            let tree: TreeNode &#x3D; stackTree.popLast()!</span><br><span class="line">            let sum &#x3D; treeVal.popLast()</span><br><span class="line">            if tree.left &#x3D;&#x3D; nil, tree.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">                if sum &#x3D;&#x3D; targetSum &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.left !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.left!)</span><br><span class="line">                treeVal.append(sum! + tree.left!.val)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.right !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.right!)</span><br><span class="line">                treeVal.append(sum! + tree.right!.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字 - 简单</title>
    <url>/2021/02/24/2000-013-%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a class="link"   href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" >剑指 Offer 11. 旋转数组的最小数字<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ftp.bmp.ovh/imgs/2021/02/f8daa4e0fade64f3.png"
                      alt="剑指 Offer 11. 旋转数组的最小数字"
                ></p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li>时间复杂度<br>O(log n) 在二分查找的过程中，大部分情况都会忽略一半的区间。</li>
<li>空间复杂度<br>O(1)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return numbers[0]</span><br><span class="line">        &#125;</span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; numbers.count - 1</span><br><span class="line">        while right &gt; left &#123;</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if numbers[mid] &gt; numbers[right] &#123;</span><br><span class="line">                &#x2F;&#x2F; numbers[mid] &gt; numbers[right] mid 已经大于 right 所以 mid 不应该包含在区间内  所以 mid + 1</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            &#125; else if numbers[mid] &lt; numbers[right] &#123;</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;  mid 和 left right 相等的情况， 就让right -&#x3D;1</span><br><span class="line">                right -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[left]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="一次遍历法"><a href="#一次遍历法" class="headerlink" title="一次遍历法"></a>一次遍历法</h1><ul>
<li>时间复杂度<br>O(n)</li>
<li>空间复杂度<br>O(1)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        var ans &#x3D; numbers[0]</span><br><span class="line">        for item in numbers &#123;</span><br><span class="line">            ans &#x3D; min(ans, item)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>81. 搜索旋转排序数组 II - 中等</title>
    <url>/2021/02/24/2000-014-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    <content><![CDATA[<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" >81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/pwhsby.png"
                      alt="81. 搜索旋转排序数组 II"
                ></p>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li><p>时间复杂度<br>O(n) 大多情况下每次都减少一般的数据</p>
</li>
<li><p>空间复杂度<br>O(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func search(_ nums: [Int], _ target: Int) -&gt; Bool &#123;</span><br><span class="line">      if nums.isEmpty &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">          return nums[0] &#x3D;&#x3D; target</span><br><span class="line">      &#125;</span><br><span class="line">      var left &#x3D; 0</span><br><span class="line">      var right &#x3D; nums.count - 1</span><br><span class="line">      &#x2F;&#x2F; [1, 2]</span><br><span class="line">      &#x2F;&#x2F; 必须是 &gt;&#x3D; 会存在 到最后左右指针相遇 才找到 目标值的情况</span><br><span class="line">      while right &gt;&#x3D; left &#123;</span><br><span class="line">          let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">          if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">              return true</span><br><span class="line">          &#125;</span><br><span class="line">          if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">              if nums[mid] &lt; target, target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if nums[mid] &gt; nums[right] &#123;</span><br><span class="line">              if nums[left] &lt;&#x3D; target, target &lt; nums[mid] &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              right -&#x3D; 1</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return false</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>236. 二叉树的最近公共祖先 - 中等</title>
    <url>/2021/02/24/2000-015-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" >236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/8s3kd1.png"
                      alt="236. 二叉树的最近公共祖先"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) 其中 N 是二叉树的节点数，所有节点都会被访问一次。</li>
<li>空间复杂度<br>O(n) 其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var commTree: TreeNode?</span><br><span class="line"></span><br><span class="line">    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        _ &#x3D; dfs(root, p, q)</span><br><span class="line">        return commTree</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfs(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        &#x2F;&#x2F; 左子树是否包含 q 或 q</span><br><span class="line">        let lson &#x3D; dfs(root.left, p, q)</span><br><span class="line">        &#x2F;&#x2F; 右子树是否包含 q 或 q</span><br><span class="line">        let rson &#x3D; dfs(root.right, p, q)</span><br><span class="line">        &#x2F;&#x2F; 左右子树包含pq || (左子树或右子树包含 且 当前root.val &#x3D;&#x3D; p.val 或 q.val)</span><br><span class="line">        if (lson &amp;&amp; rson) || ((lson || rson) &amp;&amp; (root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val)) &#123;</span><br><span class="line">            commTree &#x3D; root</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果包含 p q, 会先命中 root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val</span><br><span class="line">        &#x2F;&#x2F; 这时返回的值是 true, 后面 会命中 lson || rson</span><br><span class="line">        return root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val || lson || rson</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>70. 爬楼梯 - 简单</title>
    <url>/2021/02/24/2000-016-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a class="link"   href="https://leetcode-cn.com/problems/climbing-stairs/" >70. 爬楼梯<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/kmucz8.png"
                      alt="70. 爬楼梯"
                ></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li>时间复杂度<br>O(n) n 是输入的，循环执行 n 次</li>
<li>空间复杂度<br>O(1) 只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; n ans</span><br><span class="line">&#x2F;&#x2F; 1  1</span><br><span class="line">&#x2F;&#x2F; 2  2</span><br><span class="line">&#x2F;&#x2F; 3  3</span><br><span class="line">&#x2F;&#x2F; 4  5</span><br><span class="line">&#x2F;&#x2F;( n 的 ans) &#x3D; (n-1 的 ans) + (n-2 的 ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func climbStairs(_ n: Int) -&gt; Int &#123;</span><br><span class="line">        var b1 &#x3D; 0</span><br><span class="line">        var b2 &#x3D; 1</span><br><span class="line">        var ans &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for _ in 1 ... n &#123;</span><br><span class="line">            ans &#x3D; b1 + b2</span><br><span class="line">            b1 &#x3D; b2</span><br><span class="line">            b2 &#x3D; ans</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>226. 翻转二叉树 - 简单</title>
    <url>/2021/02/24/2000-017-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/invert-binary-tree/" >226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/spum89.png"
                      alt="226. 翻转二叉树"
                ></p>
<h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul>
<li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从根节点开始反转的</span><br><span class="line">    func invertTree2(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">        var treeRoot &#x3D; root</span><br><span class="line">        let ansRoot &#x3D; root</span><br><span class="line">        var list: [TreeNode] &#x3D; [treeRoot]</span><br><span class="line">        while !list.isEmpty &#123;</span><br><span class="line">            treeRoot &#x3D; list.popLast()!</span><br><span class="line">            let temp &#x3D; treeRoot.right</span><br><span class="line">            treeRoot.right &#x3D; treeRoot.left</span><br><span class="line">            treeRoot.left &#x3D; temp</span><br><span class="line">            if treeRoot.left !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.left!)</span><br><span class="line">            &#125;</span><br><span class="line">            if treeRoot.right !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.right!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ansRoot</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从叶子节点开始反转的</span><br><span class="line">    func invertTree(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        let left &#x3D; invertTree(root.left)</span><br><span class="line">        let right &#x3D; invertTree(root.right)</span><br><span class="line">        root.left &#x3D; right</span><br><span class="line">        root.right &#x3D; left</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树 - 中等</title>
    <url>/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/zn7zcr.png"
                      alt="105. 从前序与中序遍历序列构造二叉树"
                ></p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul>
<li>时间复杂度<br>O(n) n 是节点的个数，每个节点都访问一次</li>
<li>空间复杂度<br>O(n) 除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var inorderMap: [Int: Int] &#x3D; [:]</span><br><span class="line"></span><br><span class="line">    func buildTree(_ preorder: [Int], _ inorder: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">        let count &#x3D; preorder.count</span><br><span class="line">        &#x2F;&#x2F; 这一步是为了节省时间 但是增加了空间占用</span><br><span class="line">        for (index, val) in inorder.enumerated() &#123;</span><br><span class="line">            inorderMap[val] &#x3D; index</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, count - 1, 0, count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func myBuildTree(_ preorder: [Int], _ inorder: [Int], _ preorderLeft: Int, _ preorderRight: Int, _ inorderLeft: Int, _ inorderRight: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if preorderLeft &gt; preorderRight &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 前序遍历的第一个节点就是根节点</span><br><span class="line">        let preorderRoot &#x3D; preorderLeft</span><br><span class="line">        &#x2F;&#x2F; 找出中序遍历的根节点位置</span><br><span class="line">        let inorderRoot &#x3D; inorderMap[preorder[preorderRoot]]!</span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        let root &#x3D; TreeNode(preorder[preorderRoot])</span><br><span class="line">        &#x2F;&#x2F; 左子树的节点数目</span><br><span class="line">        let leftTreeCount &#x3D; inorderRoot - inorderLeft</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderLeft + 1 开始的 leftTreeCount 个元素就是 当前 root 左子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderLeft 开始到 inorderRoot - 1]  就是当前 root 左子树的 所有节点</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorderLeft + 1, preorderLeft + leftTreeCount, inorderLeft, inorderRoot - 1)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderRoot + 1(这个1是根节点的长度) + leftTreeCount 到 preorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderRoot + 1 到 inorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorderRoot + 1 + leftTreeCount, preorderRight, inorderRoot + 1, inorderRight)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <url>/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var treeList: [TreeNode] &#x3D; [root]</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempList: [TreeNode] &#x3D; []</span><br><span class="line">            for tree in treeList &#123;</span><br><span class="line">                valList.append(tree.val)</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(valList)</span><br><span class="line">            treeList &#x3D; tempList</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <url>/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a class="link"   href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line">        var listTree: [TreeNode] &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        var isLR &#x3D; false</span><br><span class="line">        while !listTree.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempTree: [TreeNode] &#x3D; []</span><br><span class="line">            isLR &#x3D; !isLR</span><br><span class="line">            for tree in listTree &#123;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">                if isLR &#123;</span><br><span class="line">                    valList.append(tree.val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    valList.insert(tree.val, at: 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listTree &#x3D; tempTree</span><br><span class="line">            ans.append(valList)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>199. 二叉树的右视图</title>
    <url>/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >199. 二叉树的右视图<i class="fas fa-external-link-alt"></i></a></h1><h1 id="解法一-BFS-广度优先-层序遍历"><a href="#解法一-BFS-广度优先-层序遍历" class="headerlink" title="解法一 BFS 广度优先 层序遍历"></a>解法一 BFS 广度优先 层序遍历</h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [Int] &#x3D; []</span><br><span class="line">        var treeList &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            let count &#x3D; treeList.count</span><br><span class="line">            for i in 0 ..&lt; count &#123;</span><br><span class="line">                let tree &#x3D; treeList.remove(at: 0)</span><br><span class="line">                if i &#x3D;&#x3D; count - 1 &#123;</span><br><span class="line">                    ans.append(tree.val)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="解法二-DFS-深度优先-前序遍历-变形"><a href="#解法二-DFS-深度优先-前序遍历-变形" class="headerlink" title="解法二 DFS 深度优先 前序遍历 变形"></a>解法二 DFS 深度优先 前序遍历 变形</h1><ul>
<li>时间复杂度<br>O(n) 每个节点访问一次</li>
<li>空间复杂度<br>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ans: [Int] &#x3D; []</span><br><span class="line">    func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        dfsSlideView(root, 0)</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfsSlideView(_ root: TreeNode?, _ depth: Int) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        if depth &#x3D;&#x3D; ans.count &#123;</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        let d &#x3D; depth + 1</span><br><span class="line">        dfsSlideView(root.right, d)</span><br><span class="line">        dfsSlideView(root.left, d)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>10亿个数中找出最大的10000个数（top K问题）</title>
    <url>/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="10-亿个数中找出最大的-10000-个数（top-K-问题）"><a href="#10-亿个数中找出最大的-10000-个数（top-K-问题）" class="headerlink" title="10 亿个数中找出最大的 10000 个数（top K 问题）"></a>10 亿个数中找出最大的 10000 个数（top K 问题）</h1><h2 id="1-对全部数据直接进行排序"><a href="#1-对全部数据直接进行排序" class="headerlink" title="1. 对全部数据直接进行排序"></a>1. 对全部数据直接进行排序</h2><ul>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(n)</li>
</ul>
<p>将 10 亿数据直接进行快排，然后如果大堆长度大于 10000，继续将大堆进行快排。 如果小于 10000 ，那么将最近一次的小堆再次进行快排。如果这个大堆长度加上之前的长度大于 10000，那么对这个大堆进行完整的快排。并取最大的 n 个数。</p>
<h2 id="2-局部淘汰法"><a href="#2-局部淘汰法" class="headerlink" title="2.局部淘汰法"></a>2.局部淘汰法</h2><ul>
<li>时间复杂度 O(n+m^2) m 为当前容器大小 10000</li>
<li>空间复杂度 O(m)</li>
</ul>
<p>先保存 10000 个数，然后将后续的数依次与 10000 里最小的数比较，小的直接丢弃，大的进行替换。最后这 10000 个数就是答案。</p>
<h2 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3.分治法"></a>3.分治法</h2><ul>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(max(a,b)) a 为每份的长度 这里为 100 万，b 为最后的 m 份的最大 k 这里为 100 份的最大 10000 即 100 万。</li>
</ul>
<p>先将 1 亿个数分成 100 份， 每份 100 万个数。然后对每一份进行快排找出最大的 10000 个数。<br>方法是：快排中如果大堆大于 10000 ，继续对大堆进行快排。如果小于 10000，那么对最近的小堆进行快排，如果大堆长度 + 之前的大堆长度满足。那么对大堆进行完全快排取最大的 n 个数。<br>这样找出了 100 份 最大的 10000 个数。继续上边的思路进行快排直到找出最大的 10000 个数。</p>
<h2 id="4-Hash-法"><a href="#4-Hash-法" class="headerlink" title="4.Hash 法"></a>4.Hash 法</h2><p>先将所有的数存入 hash 表中去重复，减少数据量。然后分治法。</p>
<blockquote>
<p><a class="link"   href="https://blog.csdn.net/zyq522376829/article/details/47686867" >https://blog.csdn.net/zyq522376829/article/details/47686867<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Top K</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过一个不均匀的硬币得到公平的结果？</title>
    <url>/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="如何通过一个不均匀的硬币得到公平的结果？"><a href="#如何通过一个不均匀的硬币得到公平的结果？" class="headerlink" title="如何通过一个不均匀的硬币得到公平的结果？"></a>如何通过一个不均匀的硬币得到公平的结果？</h1><p>假设 60% 概率 正面，40% 概率反面<br>那么抛两次会有下面四种结果</p>
<ul>
<li>正 正 36%</li>
<li>正 反 24%</li>
<li>反 正 24%</li>
<li>反 反 16%</li>
</ul>
<p>可以看出 正反 与 反正 的概率是相等的。<br>所以抛两次当正反面不同时，都取第一次的结果为最终结果即可。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>64匹马,8个赛道,最少比几次找出跑得最快的4匹马？</title>
    <url>/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/</url>
    <content><![CDATA[<p>11 次<br><a class="link"   href="https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2" >解析文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>树、二叉树、二叉搜索树</title>
    <url>/2021/02/06/2000-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树-LeetCode"><a href="#二叉树-LeetCode" class="headerlink" title="二叉树 LeetCode"></a><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树 LeetCode<i class="fas fa-external-link-alt"></i></a></h1><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote>
<p>是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图</p>
</blockquote>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><blockquote>
<p>是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
</blockquote>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><blockquote>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
</blockquote>
<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>二叉树</tag>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算 &lt;&lt;"></a>左移运算 &lt;&lt;</h1><p>a &lt;&lt; b<br><code>a*(2 的 b 次方)</code></p>
<p>3 &lt;&lt; 2，则是将数字 3 左移 2 位<br><code>3*(2 的 2 次方)</code></p>
<h2 id="计算过程："><a href="#计算过程：" class="headerlink" title="计算过程："></a>计算过程：</h2><p>3 &lt;&lt; 2 首先把 3 转换为二进制数字 0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移 2 位，最后在低位(右侧)的两个空位补零。则得到的最终结果是 0000 1100，则转换为十进制是 12。</p>
<h2 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义:"></a>数学意义:</h2><p>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。</p>
<h1 id="amp-与运算"><a href="#amp-与运算" class="headerlink" title="&amp; 与运算"></a>&amp; 与运算</h1><p>参加运算的两个数据，按二进制位进行“与”运算。<br>运算规则：0&amp;0=0;0&amp;1=0;1&amp;0=0;1&amp;1=1;<br>即：两位同时为“1”，结果才为“1”，否则为 0<br>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3&amp;5 的值得 1。</p>
<h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>用 2 整除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为小于 1 时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p>
<blockquote>
<p><a class="link"   href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6" >https://baike.baidu.com/item/二进制<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 基础之 类、set、get、构造函数、方法</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h1 id="类、属性、方法"><a href="#类、属性、方法" class="headerlink" title="类、属性、方法"></a>类、属性、方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;名字:$name 年龄:$age&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="默认构造函数、初始化列表"><a href="#默认构造函数、初始化列表" class="headerlink" title="默认构造函数、初始化列表"></a>默认构造函数、初始化列表</h1><blockquote>
<p>存在初始化列表就不能存在默认构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F;默认构造函数 简写</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认构造函数 全写</span><br><span class="line">  Person(String name, int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化列表</span><br><span class="line">  Person()</span><br><span class="line">      : name &#x3D; &#39;李华&#39;,</span><br><span class="line">        age &#x3D; 22 &#123;</span><br><span class="line">    print(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="匿名构造函数"><a href="#匿名构造函数" class="headerlink" title="匿名构造函数"></a>匿名构造函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  Person.newPeople() &#123;</span><br><span class="line">    name &#x3D; &quot;李四&quot;;</span><br><span class="line">    age &#x3D; 33;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 带参数匿名构造函数</span><br><span class="line">  Person.new2(String name, int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="私有属性、私有方法、set方法、get方法"><a href="#私有属性、私有方法、set方法、get方法" class="headerlink" title="私有属性、私有方法、set方法、get方法"></a>私有属性、私有方法、set方法、get方法</h1><blockquote>
<p>私有属性、私有方法  这个类必须单独在一个文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  var _money &#x3D; 999999;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK:set 方法</span><br><span class="line">  set gongzi(int value) &#123;</span><br><span class="line">    _money &#x3D; _money + value;</span><br><span class="line">    _printMoney();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK:get方法</span><br><span class="line">  int get money &#123;</span><br><span class="line">    return _money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK:   私有方法 这个类必须单独在一个文件</span><br><span class="line">  _printMoney() &#123;</span><br><span class="line">    print(money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 静态属性、静态方法</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F;MARK: 静态属性</span><br><span class="line">  static String name &#x3D; &#39;张三&#39;;</span><br><span class="line">  int age &#x3D; 20;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;MARK:静态方法</span><br><span class="line">  static getInfo() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">    &#x2F;&#x2F; print(age);  静态方法内部不能反问非静态属性</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printInfo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 非静态方法 可以访问静态成员与非静态 包括方法</span><br><span class="line">    getInfo();</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart ？可选操作 类型判断、类型转换、联缀</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%803/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;名字：$name  年龄：$age&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="？-可选操作符"><a href="#？-可选操作符" class="headerlink" title="？ 可选操作符"></a>？ 可选操作符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p2;</span><br><span class="line">&#x2F;&#x2F; p2.getInfo();  p2 未初始化  可使用 ？ 可选符操作</span><br><span class="line">&#x2F;&#x2F;MARK:     可选操作符</span><br><span class="line">p2?.getInfo();</span><br></pre></td></tr></table></figure>

<h1 id="is-操作符-类型判断"><a href="#is-操作符-类型判断" class="headerlink" title="is 操作符 类型判断"></a>is 操作符 类型判断</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 &#x3D; Person();</span><br><span class="line">&#x2F;&#x2F;MARK: is  操作符    类型判断</span><br><span class="line">  if (p1 is Person) &#123;</span><br><span class="line">    print(&#39;p1 是 person&#39;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="as-操作符-类型转换"><a href="#as-操作符-类型转换" class="headerlink" title="as 操作符 类型转换"></a>as 操作符 类型转换</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p3;</span><br><span class="line">p3 &#x3D; Person();</span><br><span class="line">&#x2F;&#x2F; p3.name;   虽然没报错  但是不知道 p3 类型</span><br><span class="line">(p3 as Person).name &#x3D; &#39;王麻子&#39;;</span><br><span class="line">(p3 as Person).age &#x3D; 11;</span><br><span class="line">(p3 as Person).getInfo();</span><br></pre></td></tr></table></figure>

<h1 id="联缀操作符"><a href="#联缀操作符" class="headerlink" title=".. 联缀操作符"></a>.. 联缀操作符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .. 联缀 操作符</span><br><span class="line">  Person p4 &#x3D; Person();</span><br><span class="line">  p4</span><br><span class="line">    ..name &#x3D; &#39;哈哈哈&#39;</span><br><span class="line">    ..age &#x3D; 40</span><br><span class="line">    ..getInfo();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 类的继承</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%804/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;$name    ---   $age&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  work() &#123;</span><br><span class="line">    print(&quot;object 努力学习&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="继承、重写父类方法"><a href="#继承、重写父类方法" class="headerlink" title="继承、重写父类方法"></a>继承、重写父类方法</h1><blockquote>
<p>使用 extends 关键字继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Zp extends Person &#123;</span><br><span class="line">  String sex;</span><br><span class="line">  Zp(String name, int age, [String sex &#x3D; &#39;男&#39;]) : super(name, age) &#123;</span><br><span class="line">    this.sex &#x3D; sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  faGongZi(&#123;int money&#125;) &#123;</span><br><span class="line">    print(&#39;发工资了 $money&#39;);</span><br><span class="line">    super.work();</span><br><span class="line">    work();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK: 重写父类方法</span><br><span class="line">  @override</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;$name 今年 $age  很有钱&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart abstract 抽象类</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%805/</url>
    <content><![CDATA[<h1 id="抽象类-相当于协议-接口"><a href="#抽象类-相当于协议-接口" class="headerlink" title="抽象类 相当于协议 接口"></a>抽象类 相当于协议 接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  &#x2F;&#x2F;抽象方法 只有方法名 没有具体实现</span><br><span class="line">  run();</span><br><span class="line"></span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;普通方法&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Animal-an-Animal-抽象类-不能被实例化"><a href="#Animal-an-Animal-抽象类-不能被实例化" class="headerlink" title="Animal an = Animal();   //抽象类 不能被实例化"></a>Animal an = Animal();   //抽象类 不能被实例化</h2><h1 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h1><blockquote>
<p>继承自抽象类必须实现抽象方法     继承自抽象类的属性不是必须实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;小狗跑&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="implements-声明、with"><a href="#implements-声明、with" class="headerlink" title="implements 声明、with"></a>implements 声明、with</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat implements Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    print(&#39;我是🐱&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;小🐱跑的快&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck with Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;小鸭跑&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 多继承</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%806/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  printA() &#123;</span><br><span class="line">    print(&#39;AAAAA&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;A run&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">  printB() &#123;</span><br><span class="line">    print(&#39;BBBBBBBBB&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; B.bbb()&#123;&#125;    作为 minxins 的类不能有构造函数</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#39;B run&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mixins-混入"><a href="#mixins-混入" class="headerlink" title="mixins 混入"></a>mixins 混入</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MARK:   mixins 的必须是单独的一个object 类 A不能继承于其他类</span><br><span class="line">class Z with A, B &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="继承-mixins-混入"><a href="#继承-mixins-混入" class="headerlink" title="继承 + mixins 混入"></a>继承 + mixins 混入</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class X extends Person with A, B &#123;</span><br><span class="line">  X.aa() : super.aa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-和-B-共有的方法后继承的覆盖之前的"><a href="#A-和-B-共有的方法后继承的覆盖之前的" class="headerlink" title="A 和 B 共有的方法后继承的覆盖之前的"></a>A 和 B 共有的方法后继承的覆盖之前的</h1>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 泛型</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%807/</url>
    <content><![CDATA[<h1 id="方法添加泛型"><a href="#方法添加泛型" class="headerlink" title="方法添加泛型"></a>方法添加泛型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T getData&lt;T&gt;(T value) &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类添加泛型"><a href="#类添加泛型" class="headerlink" title="类添加泛型"></a>类添加泛型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Pppp&lt;T&gt; &#123;</span><br><span class="line">  var list &#x3D; List&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  add(T) &#123;</span><br><span class="line">    list.add(T);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printList() &#123;</span><br><span class="line">    print(list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="泛型-接口"><a href="#泛型-接口" class="headerlink" title="泛型 接口"></a>泛型 接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class ABC&lt;T&gt; &#123;</span><br><span class="line">  addObject(String key);</span><br><span class="line">  setValue(String key, T value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实现泛型接口"><a href="#实现泛型接口" class="headerlink" title="实现泛型接口"></a>实现泛型接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Wq&lt;T&gt; implements ABC&lt;T&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  addObject(String key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  setValue(String key, T value) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Dart 导入库</title>
    <url>/2020/12/27/300-Dart%E5%9F%BA%E7%A1%808/</url>
    <content><![CDATA[<blockquote>
<p>如果库冲突了 使用 as 重命名   show 导入部分  hide不导入的部分</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;XXX.dart&#39; as lib show Person;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 开发错误 StatefulWidget createState must return a subtype of State</title>
    <url>/2020/12/01/400-Flutter-%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF-StatefulWidget-createState-must-return-a-subtype-of-State/</url>
    <content><![CDATA[<p>报错如下:</p>
<p>StatefulWidget.createState must return a subtype of State</p>
<p>The createState function for XXXX2 returned a state of type _XXXXState, which is not a subtype of State<XXXX2>, violating the contract for createState.</p>
<p>错误分析：<br>其实就是返回的 Widget 类型不对，<br>大意了，修改正确即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-a44eecc36a9468ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="错误图"
                ></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 本地图片配置工具 FlutterGen</title>
    <url>/2020/12/02/400-Flutter-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7-FlutterGen/</url>
    <content><![CDATA[<h1 id="github-gt-FlutterGen"><a href="#github-gt-FlutterGen" class="headerlink" title="github -&gt; FlutterGen"></a><a class="link"   href="https://github.com/FlutterGen" >github -&gt; FlutterGen<i class="fas fa-external-link-alt"></i></a></h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 推荐使用 Homebrew 安装</span><br><span class="line">$ brew install FlutterGen&#x2F;tap&#x2F;fluttergen</span><br></pre></td></tr></table></figure>

<p>#使用前先把 assets: 配置好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets:</span><br><span class="line">    - assets&#x2F;images&#x2F;cat.png</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fluttergen -c example&#x2F;pubspec.yaml</span><br></pre></td></tr></table></figure>

<h1 id="VSCode-中-终端使用"><a href="#VSCode-中-终端使用" class="headerlink" title="VSCode 中 终端使用"></a>VSCode 中 终端使用</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-645686099e6124e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="VSCode"
                ></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 配置相关</title>
    <url>/2020/12/03/400-Flutter-%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><blockquote>
<p>CocoaPods requires your terminal to be using UTF-8 encoding<br>Consider adding the following to ~/.profile:<br>export LANG=en_US.UTF-8</p>
</blockquote>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.打开终端 输入命令open -e .bash_profile</span><br><span class="line">2.在终端输入 export LANG&#x3D;en_US.UTF-8 保存</span><br><span class="line">3.重启VSCode</span><br><span class="line"></span><br><span class="line">⚠️⚠️安装zsh导致全局配置还不行的话⚠️⚠️</span><br><span class="line">1. vim ~&#x2F;.zshrc</span><br><span class="line">2. 按E进入编辑 （大写E）</span><br><span class="line">3. 在最后一行加入  export LANG&#x3D;en_US.UTF-8</span><br><span class="line">4. 按ESC退出编辑  键入 :wq 保存退出</span><br><span class="line">5. 重启VSCode</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><blockquote>
<p>-bash: flutter: command not found</p>
</blockquote>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.打开终端 输入命令open -e .bash_profile</span><br><span class="line">2.在终端输入 </span><br><span class="line"></span><br><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;Users&#x2F;(你的用户名)&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;Users&#x2F;(你的用户名)&#x2F;flutter&#x2F;bin</span><br><span class="line">export NO_PROXY&#x3D;localhost,127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.终端输入 source ~&#x2F;.bash_profile保存</span><br><span class="line"></span><br><span class="line">⚠️⚠️安装zsh导致全局配置还不行的话⚠️⚠️</span><br><span class="line">1. vim ~&#x2F;.zshrc</span><br><span class="line">2. 按E进入编辑 （大写E）</span><br><span class="line">3. 在最后一行加入  </span><br><span class="line">export PATH&#x3D;&#x2F;Users&#x2F;z&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">export NO_PROXY&#x3D;localhost,127.0.0.1</span><br><span class="line"></span><br><span class="line">4. 按ESC退出编辑  键入 :wq 保存退出</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 工程修复</title>
    <url>/2020/12/04/400-Flutter%E5%B7%A5%E7%A8%8B%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>Flutter工程 误删iOS、误删Android等文件时</p>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开终端输入</span><br><span class="line">flutter create 工程目录</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 依赖库查询</title>
    <url>/2020/12/05/400-Flutter%E6%9F%A5%E8%AF%A2%E4%BE%9D%E8%B5%96%E5%BA%93%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p>地址为 <a class="link"   href="https://pub.flutter-io.cn/packages" >https://pub.flutter-io.cn/packages<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p><a class="link"   href="https://pub.flutter-io.cn/packages" >点我前往查询<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 AspectRatio、Card</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6AspectRatio%E3%80%81Card/</url>
    <content><![CDATA[<h1 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h1><blockquote>
<p>设置自身比例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AspectRatio(</span><br><span class="line">        aspectRatio: 5.0 &#x2F; 1.0,</span><br><span class="line">        child: Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            &#39;AspectRatio 宽高比 5&#x2F;1&#39;,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            style: TextStyle(fontSize: 30),</span><br><span class="line">          ),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>

<h1 id="Card"><a href="#Card" class="headerlink" title="Card"></a>Card</h1><blockquote>
<p>卡片样式</p>
</blockquote>
<p>```<br>Card(<br>      margin: EdgeInsets.all(10),<br>      shape: RoundedRectangleBorder(<br>          side: BorderSide(color: Colors.orange, width: 2),<br>          borderRadius: BorderRadius.circular(10)),<br>      child: Column(<br>        children: [<br>          AspectRatio(<br>            aspectRatio: 16 / 9,<br>            child: Image.network(<br>              randomImgSrc(),<br>              fit: BoxFit.cover,<br>            ),<br>          ),<br>          Padding(<br>            padding: EdgeInsets.all(12),<br>            child: Row(<br>              crossAxisAlignment: CrossAxisAlignment.baseline,<br>              children: [<br>                ClipOval(<br>                  child: Image.network(randomImgSrc(),<br>                      width: 60, fit: BoxFit.cover),<br>                ),<br>                Container(<br>                  padding: EdgeInsets.fromLTRB(10, 0, 0, 0),<br>                  height: 60,<br>                  child: Stack(<br>                    children: [<br>                      Align(<br>                        alignment: Alignment.topLeft,<br>                        child: Text(<br>                          ‘我是一只大猫’,<br>                          style: TextStyle(<br>                              fontWeight: FontWeight.bold, fontSize: 22),<br>                        ),<br>                      ),<br>                      Align(<br>                        alignment: Alignment.bottomLeft,<br>                        child: Text(‘啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦’),<br>                      )<br>                    ],<br>                  ),<br>                ),<br>                CircleAvatar(<br>                  backgroundImage: NetworkImage(randomImgSrc()),<br>                ),<br>              ],<br>            ),<br>          ),<br>        ],<br>      ),<br>    );<br>``</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 BottomNavigationBar</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6BottomNavigationBar/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int index &#x3D; 0;</span><br><span class="line">var pages &#x3D; [HomePage(), SearchPage(), SetPage()];</span><br><span class="line">var titls &#x3D; [Text(&#39;首页&#39;), Text(&#39;搜索&#39;), Text(&#39;设置&#39;)];</span><br></pre></td></tr></table></figure>


<h1 id="BottomNavigationBar"><a href="#BottomNavigationBar" class="headerlink" title="BottomNavigationBar"></a>BottomNavigationBar</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BottomNavigationBar(</span><br><span class="line">        selectedItemColor: Colors.orangeAccent,</span><br><span class="line">        iconSize: 34,</span><br><span class="line">        &#x2F;&#x2F; type: BottomNavigationBarType.shifting,</span><br><span class="line">        unselectedItemColor: Colors.grey,</span><br><span class="line">        &#x2F;&#x2F; showSelectedLabels: false,</span><br><span class="line">        &#x2F;&#x2F; showUnselectedLabels: false,</span><br><span class="line">        currentIndex: index,</span><br><span class="line">        onTap: (index) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            this.index &#x3D; index;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        items: [</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">              icon: Icon(Icons.home),</span><br><span class="line">              label: &#39;首页&#39;,</span><br><span class="line">              activeIcon: Icon(</span><br><span class="line">                Icons.home,</span><br><span class="line">                color: Colors.orangeAccent,</span><br><span class="line">              )),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">              icon: Icon(Icons.search),</span><br><span class="line">              label: &#39;搜索&#39;,</span><br><span class="line">              activeIcon: Icon(</span><br><span class="line">                Icons.search,</span><br><span class="line">                color: Colors.orangeAccent,</span><br><span class="line">              )),</span><br><span class="line">          BottomNavigationBarItem(</span><br><span class="line">              icon: Icon(Icons.settings),</span><br><span class="line">              label: &#39;设置&#39;,</span><br><span class="line">              activeIcon: Icon(</span><br><span class="line">                Icons.settings,</span><br><span class="line">                color: Colors.orangeAccent,</span><br><span class="line">              )),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter UI 组件 Container、Text</title>
    <url>/2020/12/28/400-Flutter%E7%BB%84%E4%BB%B6Container%E3%80%81Text/</url>
    <content><![CDATA[<blockquote>
<p>Text、Container 组件较为基础同时使用也很频繁，建议自行封装一套使用，避免每次都要输入很多属性。</p>
</blockquote>
<h1 id="Text-文本组件"><a href="#Text-文本组件" class="headerlink" title="Text 文本组件"></a>Text 文本组件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text(</span><br><span class="line">      &#39;文本组件&#39;,</span><br><span class="line">      textAlign: TextAlign.center,</span><br><span class="line">      overflow: TextOverflow.ellipsis,</span><br><span class="line">      maxLines: 2,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">        fontSize: 20,</span><br><span class="line">        color: Colors.orange,</span><br><span class="line">        fontWeight: FontWeight.bold,</span><br><span class="line">        fontStyle: FontStyle.italic,</span><br><span class="line">        decoration: TextDecoration.underline,</span><br><span class="line">        decorationColor: Colors.black,</span><br><span class="line">        decorationStyle: TextDecorationStyle.dotted,</span><br><span class="line">        letterSpacing: 2,</span><br><span class="line">      ),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h1 id="Container-组件"><a href="#Container-组件" class="headerlink" title="Container 组件"></a>Container 组件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">      child: Text(&#39;Container 组件&#39;),</span><br><span class="line">      width: 300,</span><br><span class="line">      height: 300,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        color: Colors.redAccent,</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(18)),</span><br><span class="line">        border: Border.all(</span><br><span class="line">          color: Colors.blueAccent,</span><br><span class="line">          width: 7,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      &#x2F;&#x2F;内边距</span><br><span class="line">      padding: EdgeInsets.all(18),</span><br><span class="line">      &#x2F;&#x2F;外边距</span><br><span class="line">      margin: EdgeInsets.fromLTRB(50, 50, 0, 0),</span><br><span class="line">      &#x2F;&#x2F; transform: Matrix4.translationValues(100, 0, 0),</span><br><span class="line">      transform: Matrix4.rotationZ(0.1),</span><br><span class="line">      alignment: Alignment.bottomLeft,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 GridView</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6GridView/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">   var widgetList &#x3D; List&lt;Widget&gt;();</span><br><span class="line">   for (var i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">     var c &#x3D; Container(</span><br><span class="line">       &#x2F;&#x2F; alignment: Alignment.topCenter,</span><br><span class="line">       color: Colors.green[100],</span><br><span class="line">       child: Column(</span><br><span class="line">         children: [</span><br><span class="line">           Image(image: Assets.images.cat),</span><br><span class="line">           SizedBox(</span><br><span class="line">             height: 12,</span><br><span class="line">           ),</span><br><span class="line">           Text(</span><br><span class="line">             &#39;哈哈哈 $i&#39;,</span><br><span class="line">             textAlign: TextAlign.center,</span><br><span class="line">             style: TextStyle(fontSize: 24),</span><br><span class="line">           ),</span><br><span class="line">         ],</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">     widgetList.add(c);</span><br><span class="line">   &#125;</span><br><span class="line">   return widgetList;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="GridView-count"><a href="#GridView-count" class="headerlink" title="GridView.count"></a>GridView.count</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">      scrollDirection: Axis.vertical,</span><br><span class="line">      padding: EdgeInsets.fromLTRB(16, 20, 16, 20),</span><br><span class="line">      crossAxisCount: 2,</span><br><span class="line">      crossAxisSpacing: 8,</span><br><span class="line">      mainAxisSpacing: 10,</span><br><span class="line">      childAspectRatio: 0.8,</span><br><span class="line">      children: this._getData(),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h1 id="GridView-builder"><a href="#GridView-builder" class="headerlink" title="GridView.builder"></a>GridView.builder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GridView.builder(</span><br><span class="line">      padding: EdgeInsets.all(10),</span><br><span class="line">      itemCount: _getData().length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        return _getData()[index];</span><br><span class="line">      &#125;,</span><br><span class="line">      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">        crossAxisCount: 2,</span><br><span class="line">        childAspectRatio: 0.8,</span><br><span class="line">        mainAxisSpacing: 10,</span><br><span class="line">        crossAxisSpacing: 10,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Image</title>
    <url>/2020/12/28/400-Flutter%E7%BB%84%E4%BB%B6Image/</url>
    <content><![CDATA[<h1 id="Image-本地图片"><a href="#Image-本地图片" class="headerlink" title="Image 本地图片"></a>Image 本地图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">        image: Assets.images.cat,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<h1 id="Image-network-显示网络图片"><a href="#Image-network-显示网络图片" class="headerlink" title="Image.network 显示网络图片"></a>Image.network 显示网络图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">      &#39;图片url&#39;,</span><br><span class="line">      &#x2F;&#x2F;充满不变形</span><br><span class="line">      fit: BoxFit.cover,</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      color: Colors.blueGrey,</span><br><span class="line">      colorBlendMode: BlendMode.difference,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="结合-ClipOval-组件-展示圆图"><a href="#结合-ClipOval-组件-展示圆图" class="headerlink" title="结合 ClipOval 组件 展示圆图"></a>结合 ClipOval 组件 展示圆图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClipOval(</span><br><span class="line">      clipBehavior: Clip.antiAliasWithSaveLayer,</span><br><span class="line">      child: Image.network(</span><br><span class="line">        imageUrl,</span><br><span class="line">        &#x2F;&#x2F; width: 200,</span><br><span class="line">        &#x2F;&#x2F; height: 200,ß</span><br><span class="line">        fit: BoxFit.cover,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h1 id="Container-BoxDecoration-属性生成-圆图"><a href="#Container-BoxDecoration-属性生成-圆图" class="headerlink" title="Container BoxDecoration 属性生成 圆图"></a>Container BoxDecoration 属性生成 圆图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">      &#x2F;&#x2F; child: networkImage,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        borderRadius: BorderRadius.circular(150),</span><br><span class="line">        image: DecorationImage(</span><br><span class="line">          image: NetworkImage(imageUrl),</span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      width: 300,</span><br><span class="line">      height: 300,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 ListView</title>
    <url>/2020/12/28/400-Flutter%E7%BB%84%E4%BB%B6ListView/</url>
    <content><![CDATA[<h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListView(</span><br><span class="line">      padding: EdgeInsets.fromLTRB(18, 20, 18, 50),</span><br><span class="line">      &#x2F;&#x2F; 滑动方向</span><br><span class="line">      scrollDirection: Axis.horizontal,</span><br><span class="line">      children: [</span><br><span class="line">        ListTile(</span><br><span class="line">          leading: Icon(</span><br><span class="line">            Icons.tv,</span><br><span class="line">            color: Colors.amberAccent,</span><br><span class="line">          ),</span><br><span class="line">          trailing: Icon(Icons.ac_unit),</span><br><span class="line">          title: Text(&#39;标题&#39;),</span><br><span class="line">          subtitle: Text(&#39;二级标题啦啦啦啦啦&#39;),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">    List&lt;Widget&gt; widgetList &#x3D; List();</span><br><span class="line">    for (var i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">      widgetList.add(Text(</span><br><span class="line">        &#39;$i 哈哈哈哈哈&#39;,</span><br><span class="line">        style: TextStyle(fontSize: 30),</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return widgetList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ListView.builder(</span><br><span class="line">      itemCount: _getData().length,</span><br><span class="line">      itemBuilder: (BuildContext context, int index) &#123;</span><br><span class="line">        return _getData()[index];</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Row、Column、Expanded</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Row%E3%80%81Column%E3%80%81Expanded/</url>
    <content><![CDATA[<h1 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h1><blockquote>
<p>水平布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ow(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        children: [</span><br><span class="line">          MyIconWidget(Icons.tv, color: Colors.redAccent),</span><br><span class="line">          MyIconWidget(Icons.ac_unit, color: Colors.blueAccent),</span><br><span class="line">          MyIconWidget(Icons.access_alarms, color: Colors.orangeAccent)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>
<h1 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h1><blockquote>
<p>垂直布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">        children: [</span><br><span class="line">          MyIconWidget(Icons.tv, color: Colors.redAccent),</span><br><span class="line">          MyIconWidget(Icons.ac_unit, color: Colors.blueAccent),</span><br><span class="line">          MyIconWidget(Icons.access_alarms, color: Colors.orangeAccent)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>
<h1 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h1><blockquote>
<p>扩展组件 比例分配</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expanded(</span><br><span class="line">          child: MyIconWidget(Icons.games, color: Colors.blueGrey),</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Row(</span><br><span class="line">      children: [</span><br><span class="line">        Expanded(</span><br><span class="line">          flex: 2,</span><br><span class="line">          child: MyIconWidget(Icons.ac_unit, color: Colors.red),</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          flex: 1,</span><br><span class="line">          child: MyIconWidget(Icons.ac_unit, color: Colors.amberAccent),</span><br><span class="line">        ),</span><br><span class="line">        Expanded(</span><br><span class="line">          flex: 2,</span><br><span class="line">          child: MyIconWidget(Icons.ac_unit, color: Colors.red),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 StatefulWidget</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Sft/</url>
    <content><![CDATA[<h1 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h1><blockquote>
<p>动态组件，页面可变化 使用  setState(() {});</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyStfWidget extends StatefulWidget implements PageRouterProtocol &#123;</span><br><span class="line">  @override</span><br><span class="line">  final Map arguments;</span><br><span class="line">  MyStfWidget(&#123;Key key, this.arguments&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyStfWidgetState createState() &#x3D;&gt; _MyStfWidgetState(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyStfWidgetState extends State&lt;MyStfWidget&gt; &#123;</span><br><span class="line">  final Map arguments;</span><br><span class="line"></span><br><span class="line">  List dataList &#x3D; [];</span><br><span class="line"></span><br><span class="line">  _MyStfWidgetState(this.arguments);</span><br><span class="line">  addData() &#123;</span><br><span class="line">    List singleList &#x3D; List();</span><br><span class="line">    for (var i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">      singleList.add(&#39;增加数据了&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.dataList.addAll(singleList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    RaisedButton addBtn &#x3D; RaisedButton(</span><br><span class="line">        child: Text(&#39;加载更多&#39;),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            this.addData();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(arguments[&#39;title&#39;] ?? &#39;默认标题&#39;),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView.builder(</span><br><span class="line">        itemCount: dataList.length + 1,</span><br><span class="line">        itemBuilder: (BuildContext context, int index) &#123;</span><br><span class="line">          if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return addBtn;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return Text(&#39;data  $index&#39;);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Stack、Align、Positioned</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Stack%E3%80%81Align%E3%80%81Positioned/</url>
    <content><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">      &#x2F;&#x2F; alignment: Alignment(-1,-1),</span><br><span class="line">      alignment: Alignment.bottomLeft,</span><br><span class="line">      children: [</span><br><span class="line">        Container(color: Colors.orange, height: 100),</span><br><span class="line">        Text(&#39;单独 Stack 布局只有两个组件&#39;,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: 20)),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h1 id="Stack-结合-Align-布局"><a href="#Stack-结合-Align-布局" class="headerlink" title="Stack 结合 Align 布局"></a>Stack 结合 Align 布局</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment.center,</span><br><span class="line">            child: Text(</span><br><span class="line">              &#39;Stack 结合 Align 布局&#39;,</span><br><span class="line">              style: TextStyle(color: Colors.white, fontSize: 30),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment.topLeft,</span><br><span class="line">            child: Icon(Icons.ac_unit),</span><br><span class="line">          ),</span><br><span class="line">          Align(</span><br><span class="line">            alignment: Alignment.bottomLeft,</span><br><span class="line">            child: Icon(Icons.ac_unit),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br></pre></td></tr></table></figure>

<h1 id="Stack-结合-Positioned-布局"><a href="#Stack-结合-Positioned-布局" class="headerlink" title="Stack 结合 Positioned 布局"></a>Stack 结合 Positioned 布局</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Positioned(</span><br><span class="line">              top: 16,</span><br><span class="line">              left: 16,</span><br><span class="line">              child: Text(</span><br><span class="line">                &#39; Stack 结合 Positioned 布局&#39;,</span><br><span class="line">                style: TextStyle(color: Colors.white, fontSize: 30),</span><br><span class="line">              )),</span><br><span class="line">          Positioned(</span><br><span class="line">              bottom: 10,</span><br><span class="line">              right: 10,</span><br><span class="line">              width: 100,</span><br><span class="line">              height: 100,</span><br><span class="line">              child: Container(</span><br><span class="line">                color: Colors.red,</span><br><span class="line">                child: Icon(Icons.tv),</span><br><span class="line">              ))</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 组件 Wrap</title>
    <url>/2020/12/29/400-Flutter%E7%BB%84%E4%BB%B6Wrap/</url>
    <content><![CDATA[<h1 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h1><blockquote>
<p>流式布局</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wrap(</span><br><span class="line">      spacing: 10,</span><br><span class="line">      runSpacing: 10,</span><br><span class="line">      alignment: WrapAlignment.end,</span><br><span class="line">      children: [</span><br><span class="line">        MyButton(&#39;哈哈哈&#39;),</span><br><span class="line">        MyButton(&#39;阿斯顿萨达撒&#39;),</span><br><span class="line">        MyButton(&#39;苏打水萨达撒&#39;),</span><br><span class="line">        MyButton(&#39;阿瑟&#39;),</span><br><span class="line">        MyButton(&#39;萨发送个人舒服舒服当发送的&#39;),</span><br><span class="line">        MyButton(&#39;title&#39;),</span><br><span class="line">        &#x2F;&#x2F;MARK:       MaterialButton</span><br><span class="line">        MaterialButton(</span><br><span class="line">          child: Text(&#39;MaterialButton 风格 btn&#39;),</span><br><span class="line">          shape: CircleBorder(side: BorderSide(width: 100)),</span><br><span class="line">          color: Colors.orange,</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            print(&#39;object&#39;);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        &#x2F;&#x2F;MARK:IconButton</span><br><span class="line">        IconButton(icon: Icon(Icons.ac_unit), onPressed: null),</span><br><span class="line">        &#x2F;&#x2F;MARK: FlatButton</span><br><span class="line">        FlatButton(onPressed: () &#123;&#125;, child: Text(&#39;扁平化按钮&#39;)),</span><br><span class="line">        FloatingActionButton(</span><br><span class="line">          onPressed: () &#123;&#125;,</span><br><span class="line">          child: Text(&#39;FloatingActionButton&#39;),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter 路由跳转</title>
    <url>/2020/12/29/400-Flutter%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="基本路由跳转-加传值"><a href="#基本路由跳转-加传值" class="headerlink" title="基本路由跳转  加传值"></a>基本路由跳转  加传值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).push(MaterialPageRoute(</span><br><span class="line">                builder: (context) &#x3D;&gt; MyRouterPage(title: &#39;首页&#39;),</span><br><span class="line">              ));</span><br></pre></td></tr></table></figure>

<h1 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode Flutter 配置</title>
    <url>/2020/11/19/400-VSCode-Flutter-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>Dart</li>
<li>Flutter</li>
<li>Flutter Generators</li>
<li>Flutter Widget Snippets</li>
<li>Flutter Helpers</li>
<li>[FF] Flutter Files</li>
<li>Awesome Flutter Snippets<h1 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h1><code>shift + cmd + d</code> 添加以下配置，这样就不用每次都在终端输入命令了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-c47d75e75723b671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="操作图"
                ></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;debug&quot;, &#x2F;&#x2F;debug 模式</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;dart&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;profile&quot;, &#x2F;&#x2F;profile 模式 可解决非联机调试白屏</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;dart&quot;,</span><br><span class="line">            &quot;flutterMode&quot;: &quot;profile&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;release&quot;, &#x2F;&#x2F;release 模式 可解决非联机调试白屏</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;dart&quot;,</span><br><span class="line">            &quot;flutterMode&quot;: &quot;release&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="搜索关键词"><a href="#搜索关键词" class="headerlink" title="搜索关键词"></a>搜索关键词</h3><p>VSCode 插件<br>VSCode Flutter 调试配置<br>VSCode Flutter release 模式<br>Flutter release<br>Flutter 启动白屏</p>
<h1 id="如果有帮助求点赞！"><a href="#如果有帮助求点赞！" class="headerlink" title="如果有帮助求点赞！"></a>如果有帮助求点赞！</h1>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>SnapKit适配刘海屏、异形屏</title>
    <url>/2020/11/20/500-SnapKit%E9%80%82%E9%85%8D%E5%88%98%E6%B5%B7%E5%B1%8F%E3%80%81%E5%BC%82%E5%BD%A2%E5%B1%8F/</url>
    <content><![CDATA[<h3 id="🌰-适配底部安全距离"><a href="#🌰-适配底部安全距离" class="headerlink" title="🌰 适配底部安全距离"></a>🌰 适配底部安全距离</h3><p>在 ViewController 的 view 中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make.bottom.equalTo(view.snp.bottomMargin)</span><br><span class="line">make.top.equalTo(view.snp.topMargin)</span><br><span class="line">make.left.equalTo(view.snp.leftMargin)</span><br><span class="line">make.right.equalTo(view.snp.rightMargin)</span><br></pre></td></tr></table></figure>

<p>如果 view 的 superView 没有适配，那么 view 布局需要通过上面的写法适配<br>如果 view 的 superView 已经适配，那么 view 布局也会自动适配</p>
<h3 id="完整🌰"><a href="#完整🌰" class="headerlink" title="完整🌰"></a>完整🌰</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        let redView &#x3D; UIView()</span><br><span class="line">        redView.backgroundColor &#x3D; .red</span><br><span class="line">        view.addSubview(redView)</span><br><span class="line">        redView.snp.makeConstraints &#123; make in</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.bottomMargin.equalToSuperview()  &#x2F;&#x2F;没适配</span><br><span class="line">&#x2F;&#x2F;            make.bottom.equalToSuperview()    &#x2F;&#x2F;没适配</span><br><span class="line">            make.bottom.equalTo(view.snp.bottomMargin)    &#x2F;&#x2F;适配</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.topMargin.equalToSuperview()   &#x2F;&#x2F;没适配导航栏高度</span><br><span class="line">&#x2F;&#x2F;            make.top.equalToSuperview()   &#x2F;&#x2F;没适配导航栏高度</span><br><span class="line">            make.top.equalTo(view.snp.topMargin)    &#x2F;&#x2F;适配导航栏高度</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.leftMargin.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">&#x2F;&#x2F;            make.left.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">                      make.left.equalTo(view.snp.leftMargin)    &#x2F;&#x2F;适配</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F;            make.rightMargin.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">&#x2F;&#x2F;            make.right.equalToSuperview()   &#x2F;&#x2F;没适配</span><br><span class="line">                      make.right.equalTo(view.snp.rightMargin)    &#x2F;&#x2F;适配</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果 redView 已经适配   那么下边的都会适配</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果 redView 没适配   那么只有最后一个会适配</span><br><span class="line">        let blackView &#x3D; UIView()</span><br><span class="line">        blackView.backgroundColor &#x3D; .black</span><br><span class="line">        redView.addSubview(blackView)</span><br><span class="line">        blackView.snp.makeConstraints &#123; make in</span><br><span class="line">            make.left.right.equalToSuperview()</span><br><span class="line">            make.height.equalTo(150)</span><br><span class="line">&#x2F;&#x2F;            make.bottomMargin.equalToSuperview()  &#x2F;&#x2F;适配</span><br><span class="line">&#x2F;&#x2F;            make.bottom.equalTo(view.snp.bottomMargin)    &#x2F;&#x2F;适配</span><br><span class="line">            make.bottom.equalToSuperview()    &#x2F;&#x2F;没适配</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SnapKit</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 常用代码块</title>
    <url>/2020/11/21/500-Xcode-%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<p>一些常用的代码块</p>
<h1 id="点我直达"><a href="#点我直达" class="headerlink" title="点我直达"></a><a class="link"   href="https://github.com/xxxIxxxx/CodeSnippets" >点我直达<i class="fas fa-external-link-alt"></i></a></h1><h1 id="Xcode-路径"><a href="#Xcode-路径" class="headerlink" title="Xcode 路径"></a>Xcode 路径</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;UserData&#x2F;CodeSnippets</span><br></pre></td></tr></table></figure>

<p>打开路径将文件拖进去<br>代码块添加后需要重启 Xcode</p>
<h1 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>lazytab</td>
<td>懒加载属性 tableView</td>
</tr>
<tr>
<td>mk</td>
<td>//MARK: -</td>
</tr>
<tr>
<td>snpmake</td>
<td>SnapKit make 布局</td>
</tr>
<tr>
<td>snpremake</td>
<td>SnapKit remake 布局</td>
</tr>
<tr>
<td>initBtn</td>
<td>UIButton 初始化</td>
</tr>
<tr>
<td>initCCell</td>
<td>UICollectionViewCell 初始化</td>
</tr>
<tr>
<td>initImgV</td>
<td>UIImageView 初始化</td>
</tr>
<tr>
<td>initLab</td>
<td>UILable 初始化</td>
</tr>
<tr>
<td>initTCell</td>
<td>UITableViewCell 初始化</td>
</tr>
<tr>
<td>initView</td>
<td>UIView 初始化</td>
</tr>
<tr>
<td>ssself</td>
<td>guard let  strongSelf = self</td>
</tr>
</tbody></table>
<h1 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>initBtn</td>
<td>UIButton 初始化</td>
</tr>
<tr>
<td>initImgV</td>
<td>UIImageView 初始化</td>
</tr>
<tr>
<td>initLab</td>
<td>UILable 初始化</td>
</tr>
<tr>
<td>initCell</td>
<td>UITableViewCell 初始化</td>
</tr>
<tr>
<td>initView</td>
<td>UIView 初始化</td>
</tr>
<tr>
<td>initTextF</td>
<td>UITextField 初始化</td>
</tr>
<tr>
<td>pna</td>
<td>@property (nonatomic, assign)</td>
</tr>
<tr>
<td>pns</td>
<td>@property (nonatomic, strong)</td>
</tr>
<tr>
<td>pnc</td>
<td>@property (nonatomic, copy)</td>
</tr>
<tr>
<td>td</td>
<td>//TODO:</td>
</tr>
<tr>
<td>mas_make</td>
<td>Masonry make 布局</td>
</tr>
<tr>
<td>mas_remake</td>
<td>Masonry remake 布局</td>
</tr>
<tr>
<td>mas_update</td>
<td>Masonry update 布局</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 代码块</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode-快捷键，Xcode12-打开控制台</title>
    <url>/2020/11/22/500-Xcode-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%8CXcode12-%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command + shift + y</td>
<td>打开控制台</td>
</tr>
<tr>
<td>command + shift + j</td>
<td>定位当前文件在导航</td>
</tr>
<tr>
<td>command + shift + o</td>
<td>输入后快速跳转到对应文件，还可输入方法名</td>
</tr>
<tr>
<td>command + shift + L</td>
<td>打开资源文件</td>
</tr>
<tr>
<td>command + shift + f</td>
<td>搜索项目</td>
</tr>
<tr>
<td>command + shift + k</td>
<td>clean 项目</td>
</tr>
<tr>
<td>command + shift + t</td>
<td>新开当前项目</td>
</tr>
<tr>
<td>command + shift + ,</td>
<td>编辑scheme</td>
</tr>
<tr>
<td>command + shift + 2</td>
<td>打开可用调试设备</td>
</tr>
<tr>
<td>command + shift + w</td>
<td>关闭项目</td>
</tr>
<tr>
<td>command + r</td>
<td>运行项目</td>
</tr>
<tr>
<td>command + b</td>
<td>build 项目</td>
</tr>
<tr>
<td>command + .</td>
<td>停止当前操作</td>
</tr>
<tr>
<td>command + 0</td>
<td>开启/关闭 导航</td>
</tr>
<tr>
<td>command + 1，2 … 9</td>
<td>实操看下效果吧</td>
</tr>
<tr>
<td>command + f</td>
<td>搜索当前文件</td>
</tr>
<tr>
<td>command + L</td>
<td>跳转到对应行</td>
</tr>
<tr>
<td>command + w</td>
<td>关闭当前文件</td>
</tr>
<tr>
<td>command + y</td>
<td>关闭断点调试</td>
</tr>
<tr>
<td>command + \</td>
<td>打断点</td>
</tr>
<tr>
<td>command + ,</td>
<td>偏好设置</td>
</tr>
<tr>
<td>command + return</td>
<td>仅编辑器</td>
</tr>
<tr>
<td>control + 6</td>
<td>显示当前文件的方法，然后可以继续输方法名回车跳转</td>
</tr>
<tr>
<td>control + 0</td>
<td>切换 Target</td>
</tr>
<tr>
<td>control + 4</td>
<td>切换项目</td>
</tr>
<tr>
<td>command + option + w</td>
<td>保留当前打开，关闭其他文件</td>
</tr>
</tbody></table>
<p>欢迎补充比较实用的快捷键！</p>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS OC 与 Swift 混编</title>
    <url>/2020/12/06/500-iOS-OC-%E4%B8%8E-Swift-%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h1 id="1-XXX-Bridging-Header-h"><a href="#1-XXX-Bridging-Header-h" class="headerlink" title="1. XXX-Bridging-Header.h"></a>1. XXX-Bridging-Header.h</h1><p>新建Swift文件时一般会自动提示创建<code>XXX-Bridging-Header.h</code>文件。如果没有那么自己新建一个 Header 文件，命名为<code>项目名-Bridging-Header.h</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-40814d95e9d8b2f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="新建 Header 文件"
                ></p>
<h1 id="2-打开-Target-gt-BuildSettings-搜索-Header"><a href="#2-打开-Target-gt-BuildSettings-搜索-Header" class="headerlink" title="2. 打开 Target -&gt; BuildSettings 搜索 Header"></a>2. 打开 Target -&gt; BuildSettings 搜索 <code>Header</code></h1><h2 id="User-Header-Search-Paths-填写-SRCROOT"><a href="#User-Header-Search-Paths-填写-SRCROOT" class="headerlink" title="User Header Search Paths 填写 $(SRCROOT)"></a><code>User Header Search Paths</code> 填写 <code>$(SRCROOT)</code></h2><h2 id="Enable-Modules-c-and-objective-C-填写-YES"><a href="#Enable-Modules-c-and-objective-C-填写-YES" class="headerlink" title="Enable Modules(c and objective-C) 填写 YES"></a><code>Enable Modules(c and objective-C)</code> 填写 <code>YES</code></h2><h2 id="Objective-C-Bridging-Header-填写-项目名称-项目名称-Bridging-Header-h-⚠️这里是个路径"><a href="#Objective-C-Bridging-Header-填写-项目名称-项目名称-Bridging-Header-h-⚠️这里是个路径" class="headerlink" title="Objective-C Bridging Header 填写 项目名称/项目名称-Bridging-Header.h ⚠️这里是个路径"></a><code>Objective-C Bridging Header</code> 填写 <code>项目名称/项目名称-Bridging-Header.h</code> ⚠️这里是个路径</h2><h2 id="Objective-C-Generated-Interface-Header-Name-填写-项目名称-Swift-h-这里是-OC-引用-Swift-需要用到的。"><a href="#Objective-C-Generated-Interface-Header-Name-填写-项目名称-Swift-h-这里是-OC-引用-Swift-需要用到的。" class="headerlink" title="Objective-C Generated Interface Header Name 填写 项目名称-Swift.h 这里是 OC 引用 Swift 需要用到的。"></a><code>Objective-C Generated Interface Header Name</code> 填写 <code>项目名称-Swift.h</code> 这里是 OC 引用 Swift 需要用到的。</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-c91b49763e023f54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="BuildSettings 需要修改的地方"
                ></p>
<h1 id="3-pod-需要修改的地方"><a href="#3-pod-需要修改的地方" class="headerlink" title="3. pod 需要修改的地方"></a>3. pod 需要修改的地方</h1><p>Podfile 增加 <code>use_frameworks!</code> 后重新 <code>pod install</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target&#39;XXXXX&#39; do</span><br><span class="line">use_frameworks!</span><br></pre></td></tr></table></figure>
<p><strong>⚠️并把所有 <code>pod</code> 导入的库 使用 <code>&lt;&gt;</code> 导入 而不是<code>&quot;&quot;</code> 例如<code>#import &lt;AFNetworking.h&gt;</code></strong></p>
<blockquote>
<p>⚠️第三库报错大多都是导入方式不对引起的⚠️</p>
</blockquote>
<h1 id="4-OC-引用-Swift"><a href="#4-OC-引用-Swift" class="headerlink" title="4. OC 引用 Swift"></a>4. OC 引用 Swift</h1><p>在需要的地方导入 <code>#import &quot;项目名-Swift.h&quot;</code> 然后在需要被引用的属性、方法前增加 <code>@objc</code><br>⚠️ <code> 项目名-Swift.h 这个是隐藏文件看不到</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class XXXViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @objc var name:String &#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">    &#125;  </span><br><span class="line">    @objc func data()  &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-Swift-引用-OC"><a href="#5-Swift-引用-OC" class="headerlink" title="5. Swift 引用 OC"></a>5. Swift 引用 OC</h1><p>把需要引用的文件导入到 <code>项目名-Bridging-Header.h</code> ，即可在 Swift 中引用。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS混编</tag>
      </tags>
  </entry>
  <entry>
    <title>解决导入 objc/Runtime.h 和 objc/message.h 头文件后，敲击代码不提示 / Runtime 代码不提示</title>
    <url>/2020/12/02/500-iOS-Runtime/</url>
    <content><![CDATA[<h1 id="解决导入-objc-Runtime-h-和-objc-message-h-头文件后，敲击代码不提示-Runtime-代码不提示"><a href="#解决导入-objc-Runtime-h-和-objc-message-h-头文件后，敲击代码不提示-Runtime-代码不提示" class="headerlink" title="解决导入 objc/Runtime.h 和 objc/message.h 头文件后，敲击代码不提示 / Runtime 代码不提示"></a>解决导入 <code>objc/Runtime.h</code> 和 <code>objc/message.h</code> 头文件后，敲击代码不提示 / Runtime 代码不提示</h1><p>Build Settings 搜索 <code>objc_msg</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-d1f64b02dd132e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="Build Settings 修改"
                ></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView 加载 html</title>
    <url>/2020/12/17/500-iOS-WKWebView-loadHTMLString-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87-%E4%B8%BA%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>本文主要是针对后台返回数据是 html 标签的数据加载。异步加载 html 标签内的 img 标签，给 img 标签添加点击事件</p>
</blockquote>
<h1 id="例如返回的数据格式如下"><a href="#例如返回的数据格式如下" class="headerlink" title="例如返回的数据格式如下"></a>例如返回的数据格式如下</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  一、《望天门山》 作者：唐代李白 1、原文</span><br><span class="line">  天门中断楚江开，碧水东流至此回。两岸青山相对出，孤帆一bai片日边来。 2、译文</span><br><span class="line">  天门山从中间断裂是楚江把它冲开，碧水向东浩然奔流到这里折回。</span><br><span class="line">  两岸高耸的青山隔着长江相峙而立，江面上一叶孤舟像从日边驶来。</span><br><span class="line">  &lt;img</span><br><span class="line">    src&#x3D;&quot;https:&#x2F;&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;006CHHsBly1gkxrs7785ej31402eoe84.jpg&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">完整的 html 标签数据</span><br></pre></td></tr></table></figure>
<p> 这些数据一般都是使用了富文本编辑器编辑的内容，而且各种标签样式都有可能使用到，所以最好还是使用 WKWebView 来加载！<br> 但是如果内容含有 img 标签的话就会等待所有的图片加载完才会展示出整体的样式，这样比较影响体验。<br> 所以应该考虑异步加载图片，而不影响文字等标签样式的展示。</p>
<h1 id="Demo下载"><a href="#Demo下载" class="headerlink" title="Demo下载"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXWebView" >Demo下载<i class="fas fa-external-link-alt"></i></a></h1><h4 id="1-先将图片链接中的-scheme-替换为自定义的-scheme"><a href="#1-先将图片链接中的-scheme-替换为自定义的-scheme" class="headerlink" title="1.先将图片链接中的 scheme 替换为自定义的 scheme"></a>1.先将图片链接中的 scheme 替换为自定义的 scheme</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)changeImageScheme &#123;</span><br><span class="line">    self.htmlString &#x3D; [self.htmlString stringByReplacingOccurrencesOfString:self.oriImageUrl withString:self.xxxCustomImageUrl];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在-html-标签中添加函数"><a href="#2-在-html-标签中添加函数" class="headerlink" title="2.在 html 标签中添加函数"></a>2.在 html 标签中添加函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addJsScript &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *htmlLab &#x3D; @&quot;&lt;&#x2F;html&gt;&quot;;</span><br><span class="line">    NSString *scriptLab1 &#x3D; @&quot;&lt;&#x2F;script&gt;&quot;;</span><br><span class="line">    </span><br><span class="line">    NSString *jsFunctionString &#x3D; @&quot;function xxxGetAllImg() &#123; return document.getElementsByTagName(\&quot;img\&quot;); &#125;\</span><br><span class="line">    function xxxUpdateImage(url, imgData) &#123;  var list &#x3D; Array.from(xxxGetAllImg()); for (let item of list) &#123;  if ((item.src &#x3D;&#x3D; url)) &#123; item.src &#x3D; imgData;   break; &#125; &#125; &#125;        &quot;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (![self.htmlString containsString:htmlLab]) &#123;</span><br><span class="line">        [self addHtmlLab];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if ([self.htmlString containsString:scriptLab1]) &#123;</span><br><span class="line">     </span><br><span class="line">        NSString *scriptString &#x3D; [NSString stringWithFormat:@&quot;%@%@&quot;,jsFunctionString,scriptLab1];</span><br><span class="line">        self.htmlString &#x3D; [self.htmlString stringByReplacingOccurrencesOfString:scriptLab1 withString:scriptString];</span><br><span class="line">        </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSString *scriptLab0 &#x3D; @&quot;&lt;script&gt;&quot;;</span><br><span class="line">        NSString *scriptString &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@&quot;,scriptLab0,jsFunctionString,scriptLab1,htmlLab];</span><br><span class="line">        self.htmlString &#x3D; [self.htmlString stringByReplacingOccurrencesOfString:htmlLab withString:scriptString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-定义一个实现-WKURLSchemeHandler-协议的类"><a href="#3-定义一个实现-WKURLSchemeHandler-协议的类" class="headerlink" title="3.定义一个实现 WKURLSchemeHandler 协议的类"></a>3.定义一个实现 WKURLSchemeHandler 协议的类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface XXXCustomSchemeHanlder : NSObject &lt;WKURLSchemeHandler&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *oriImageUrl;</span><br><span class="line">@property (nonatomic, copy) NSString *oriImageScheme;</span><br><span class="line">@property (nonatomic, strong) UIImage *placeholderImage;</span><br><span class="line">@property (nonatomic, copy) void(^updateImageBlock)(void);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="4-实现协议方法-用于拦截图片加载"><a href="#4-实现协议方法-用于拦截图片加载" class="headerlink" title="4.实现协议方法 用于拦截图片加载"></a>4.实现协议方法 用于拦截图片加载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)webView:(nonnull WKWebView *)webView startURLSchemeTask:(nonnull id&lt;WKURLSchemeTask&gt;)urlSchemeTask &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UIImage *image &#x3D; self.placeholderImage;</span><br><span class="line">    NSData *data &#x3D; UIImageJPEGRepresentation(image, 1.0);</span><br><span class="line">    NSURLResponse *response &#x3D; [[NSURLResponse alloc] initWithURL:urlSchemeTask.request.URL MIMEType:@&quot;image&#x2F;jpeg&quot; expectedContentLength:data.length textEncodingName:nil];</span><br><span class="line">    [urlSchemeTask didReceiveResponse:response];</span><br><span class="line">    [urlSchemeTask didReceiveData:data];</span><br><span class="line">    [urlSchemeTask didFinish];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (self.updateImageBlock) &#123;</span><br><span class="line">        self.updateImageBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *htmlImageUrlStr &#x3D; [NSString stringWithFormat:@&quot;%@&quot;,urlSchemeTask.request.URL];</span><br><span class="line">    NSString *dloadImageUrlStr &#x3D; [htmlImageUrlStr stringByReplacingOccurrencesOfString:XXXCustomImageScheme withString:self.oriImageScheme];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [self readImageForKey:dloadImageUrlStr htmlImageUrlStr:htmlImageUrlStr webView:webView];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)readImageForKey:(NSString *)dloadImageUrlStr htmlImageUrlStr:(NSString *)htmlImageUrlStr webView:(WKWebView *)webView &#123;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:dloadImageUrlStr];</span><br><span class="line">    [[SDWebImageManager sharedManager] loadImageWithURL:url options:SDWebImageRetryFailed progress:nil completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123;</span><br><span class="line">        if (image || data) &#123;</span><br><span class="line">            NSData *imgData &#x3D; data;</span><br><span class="line">            if (!imgData) &#123;</span><br><span class="line">                imgData &#x3D; UIImageJPEGRepresentation(image, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [weakSelf callJsUpdateImage:webView imageData:imgData htmlImageUrlStr:htmlImageUrlStr];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (error) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)callJsUpdateImage:(WKWebView *)webView imageData:(NSData *)imageData htmlImageUrlStr:(NSString *)imageUrlString &#123;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    NSString *imageDataStr &#x3D; [NSString stringWithFormat:@&quot;data:image&#x2F;png;base64,%@&quot;,[imageData base64EncodedString]];</span><br><span class="line">    NSString *func &#x3D; [NSString stringWithFormat:@&quot;xxxUpdateImage(&#39;%@&#39;,&#39;%@&#39;)&quot;,imageUrlString,imageDataStr];</span><br><span class="line">    [webView evaluateJavaScript:func completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        if (weakSelf.updateImageBlock &amp;&amp; !error) &#123;</span><br><span class="line">            weakSelf.updateImageBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-初始化-WKWebView-并配置拦截信息"><a href="#5-初始化-WKWebView-并配置拦截信息" class="headerlink" title="5.初始化 WKWebView 并配置拦截信息"></a>5.初始化 WKWebView 并配置拦截信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WKWebViewConfiguration *config &#x3D; [[WKWebViewConfiguration alloc] init];</span><br><span class="line">XXXCustomSchemeHanlder *schemeHandler &#x3D; XXXCustomSchemeHanlder.new;</span><br><span class="line"></span><br><span class="line">schemeHandler.oriImageScheme &#x3D; self.oriImageScheme;</span><br><span class="line">schemeHandler.oriImageUrl &#x3D; self.oriImageUrl;</span><br><span class="line">schemeHandler.placeholderImage &#x3D; self.placeholderImage;</span><br><span class="line"></span><br><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">schemeHandler.updateImageBlock &#x3D; ^ &#123;</span><br><span class="line">    [weakSelf updateHeight];</span><br><span class="line">&#125;;</span><br><span class="line">[config setURLSchemeHandler:schemeHandler forURLScheme:XXXCustomImageScheme];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WKWebView  *webView &#x3D; [[WKWebView alloc]initWithFrame:CGRectMake(0, 0, self.width, self.height) configuration:config];</span><br></pre></td></tr></table></figure>

<h4 id="6-更新高度"><a href="#6-更新高度" class="headerlink" title="6. 更新高度"></a>6. 更新高度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)updateHeight &#123;</span><br><span class="line">    [self nowUpdateHeight];</span><br><span class="line">    [self delayUpdateHeight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)nowUpdateHeight &#123;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    [self.webView evaluateJavaScript:@&quot;document.body.offsetHeight&quot; completionHandler:^(id _Nullable result,NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 高度会有一点少 ，手动补上 20</span><br><span class="line">        CGFloat height &#x3D; [result floatValue] + 20.0;</span><br><span class="line">        weakSelf.webView.height &#x3D; height;</span><br><span class="line">        weakSelf.height &#x3D; height;</span><br><span class="line">        if (weakSelf.loadOverHeight) &#123;</span><br><span class="line">            weakSelf.loadOverHeight(height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)delayUpdateHeight &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, DelayTime * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self nowUpdateHeight];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Demo下载-1"><a href="#Demo下载-1" class="headerlink" title="Demo下载"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXWebView" >Demo下载<i class="fas fa-external-link-alt"></i></a></h1>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Widget 不显示无法添加、iOS Widget 加载网络图片</title>
    <url>/2020/12/07/500-iOS-Widget-%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%A0%E6%B3%95%E6%B7%BB%E5%8A%A0-%E3%80%81iOS-Widget-%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="Intent-Widget-开发"><a href="#Intent-Widget-开发" class="headerlink" title="Intent Widget 开发"></a><a class="link"   href="https://www.jianshu.com/p/029c85bdf16b" >Intent Widget 开发<i class="fas fa-external-link-alt"></i></a></h3><h3 id="Static-Widget-开发"><a href="#Static-Widget-开发" class="headerlink" title="Static Widget 开发"></a><a class="link"   href="https://www.jianshu.com/p/84c180963ac6" >Static Widget 开发<i class="fas fa-external-link-alt"></i></a></h3><h3 id="Demo下载"><a href="#Demo下载" class="headerlink" title="Demo下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo下载<i class="fas fa-external-link-alt"></i></a></h3><h1 id="Widget-在添加时找不到"><a href="#Widget-在添加时找不到" class="headerlink" title="Widget 在添加时找不到"></a>Widget 在添加时找不到</h1><p> 出现这种情况，可能是只配置了可编辑的 <code>Widget</code>。<br>导致<code>NSExtensionPointIdentifier</code>只有这一种类型 <code>com.apple.intents-service</code> 会被识别为 Siri 扩展。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>再添加一个不可编辑的 <code>Widget</code> 即可。不需要展示出，在 <code>@main</code>方法里不添加就好。<br>确定新添加的<code>NSExtensionPointIdentifier</code>类型为 <code>com.apple.widgetkit-extension</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-7fe44d27ed6af214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="plist"
                ></p>
<hr>
<h1 id="Widget-是不能做动画也不能异步刷新的，所以图片加载必须同步"><a href="#Widget-是不能做动画也不能异步刷新的，所以图片加载必须同步" class="headerlink" title="Widget 是不能做动画也不能异步刷新的，所以图片加载必须同步"></a>Widget 是不能做动画也不能异步刷新的，所以图片加载必须同步</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 同步下载图片，Widget 不能异步刷新</span><br><span class="line"></span><br><span class="line">funcgetImage(_imgUrlString:String) -&gt;UIImage? &#123;</span><br><span class="line"></span><br><span class="line"> guardletdata &#x3D;try?Data(contentsOf:URL(string: imgUrlString)!)else&#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;图片下载失败&quot;)</span><br><span class="line"></span><br><span class="line"> returnnil&#125;</span><br><span class="line"></span><br><span class="line">    print(&quot;图片下载成功&quot;)</span><br><span class="line"></span><br><span class="line"> returnUIImage(data: data)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line"></span><br><span class="line">Image(uiImage:getImage(entry.imageUrlStr) ??UIImage(named:&quot;aaaa&quot;)!)</span><br><span class="line"></span><br><span class="line">                        .resizable()</span><br><span class="line"></span><br><span class="line">                        .frame(width:60,</span><br><span class="line"></span><br><span class="line">                               height:60,</span><br><span class="line"></span><br><span class="line">                               alignment: .center)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
        <tag>iOS小组件</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 与 web 交互传图</title>
    <url>/2020/12/07/500-iOS-%E4%B8%8E-web-%E4%BA%A4%E4%BA%92-%E4%BC%A0%E5%9B%BE/</url>
    <content><![CDATA[<p>web 端将图片 base64 编码后传给 iOS 端，会在 base64 编码前加上 <code>data:image/png;base64,</code> 需要先把这一串给去掉后进行解码，然后转 data 再转为 image </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 修改状态栏的颜色 preferredStatusBarStyle</title>
    <url>/2020/11/02/500-iOS-%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%A0%8F%E7%9A%84%E9%A2%9C%E8%89%B2-preferredStatusBarStyle/</url>
    <content><![CDATA[<h3 id="⚠️⚠️⚠️首先要在项目的-Info-plist-文件里设置-View-controller-based-status-bar-appearance-为-YES，如果没有就不用添加⚠️-⚠️⚠️"><a href="#⚠️⚠️⚠️首先要在项目的-Info-plist-文件里设置-View-controller-based-status-bar-appearance-为-YES，如果没有就不用添加⚠️-⚠️⚠️" class="headerlink" title="⚠️⚠️⚠️首先要在项目的 Info.plist 文件里设置 View controller-based status bar appearance 为 YES，如果没有就不用添加⚠️ ⚠️⚠️"></a>⚠️⚠️⚠️首先要在项目的 Info.plist 文件里设置 View controller-based status bar appearance 为 YES，如果没有就不用添加⚠️ ⚠️⚠️</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">1. 重写 UINavigationController 的 childViewControllerForStatusBarStyle</span><br><span class="line">可以写在基类的 UINavigationController 中，也可以使用Category</span><br><span class="line">*&#x2F;</span><br><span class="line">- (UIViewController *)childViewControllerForStatusBarStyle &#123;</span><br><span class="line">    return self.topViewController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Swift </span><br><span class="line">override var childForStatusBarStyle: UIViewController? &#123;</span><br><span class="line">        return topViewController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">2.  在需要改变状态栏颜色的 UIViewController 中实现 preferredStatusBarStyle</span><br><span class="line">*&#x2F;</span><br><span class="line">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</span><br><span class="line">   return UIStatusBarStyleLightContent;</span><br><span class="line">   &#x2F;&#x2F; return UIStatusBarStyleDefault;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Swift</span><br><span class="line">override var preferredStatusBarStyle: UIStatusBarStyle &#123;</span><br><span class="line">      return .lightContent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">3. 当触发某个条件需要改变状态栏颜色时在 UIViewController 中调用</span><br><span class="line">然后在 - (UIStatusBarStyle)preferredStatusBarStyle; 中判断你的条件是否满足改变颜色</span><br><span class="line">*&#x2F;</span><br><span class="line">[self setNeedsStatusBarAppearanceUpdate];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Swift</span><br><span class="line">setNeedsStatusBarAppearanceUpdate()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>iOS修改状态栏颜色<br>OC 修改状态栏颜色<br>Swift修改状态栏颜色</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 多 Target CocoaPods 管理</title>
    <url>/2020/11/28/500-iOS-%E5%A4%9A-Target-CocoaPods-%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-iOS-多-Target-CocoaPods-管理，直接来看例子"><a href="#1-iOS-多-Target-CocoaPods-管理，直接来看例子" class="headerlink" title="1. iOS 多 Target CocoaPods 管理，直接来看例子"></a>1. iOS 多 Target CocoaPods 管理，直接来看例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &quot;11.0&quot;</span><br><span class="line">source &quot;https:&#x2F;&#x2F;cdn.cocoapods.org&#x2F;&quot;</span><br><span class="line">#source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"></span><br><span class="line">#定义公共库</span><br><span class="line">def commonPods</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &quot;KakaJSON&quot;, &quot;~&gt; 1.1.2&quot;</span><br><span class="line">  pod &quot;SnapKit&quot;, &quot;~&gt; 5.0.1&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#为 Target1 配置自己独有的库</span><br><span class="line">target &quot;Target1&quot; do</span><br><span class="line">  commonPods</span><br><span class="line">  pod &quot;YYCategories&quot;</span><br><span class="line">  pod &quot;Alamofire&quot;, &quot;~&gt; 5.2.2&quot;</span><br><span class="line">end</span><br><span class="line">#为 Target2 配置自己独有的库</span><br><span class="line">target &quot;Target2&quot; do</span><br><span class="line">  commonPods</span><br><span class="line">  pod &quot;Moya&quot;, &quot;~&gt; 14.0.0&quot;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-判断在哪一个-Target，iOS-Target-判断"><a href="#2-判断在哪一个-Target，iOS-Target-判断" class="headerlink" title="2. 判断在哪一个 Target，iOS Target 判断"></a>2. 判断在哪一个 Target，iOS Target 判断</h1><h3 id="Swift-设置"><a href="#Swift-设置" class="headerlink" title="Swift 设置"></a>Swift 设置</h3><p>Build Settings 搜索 <code>swift compiler</code> 具体看图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-da3235308811d72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="添加 Target 判断条件"
                ></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if MAINTARGET</span><br><span class="line">tipLab.text &#x3D; &quot;mmmm&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="OC-设置"><a href="#OC-设置" class="headerlink" title="OC 设置"></a>OC 设置</h3><p>Build Settings 搜索 <code>macros</code> 具体看图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-3ae5817bcb53187d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="OC 操作图"
                ></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #ifdef TARGETMAIN</span><br><span class="line">NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;TARGETMAIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>Target</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-报错-&#39;sharedApplication&#39;-is-unavailable--not-available-on-iOS</title>
    <url>/2020/11/20/500-iOS-%E6%8A%A5%E9%94%99-&#39;sharedApplication&#39;-is-unavailable--not-available-on-iOS-(App-E/</url>
    <content><![CDATA[<p>这是因为使用了在 App Extension 内不安全的API</p>
<h3 id="解决办法见下图"><a href="#解决办法见下图" class="headerlink" title="解决办法见下图"></a>解决办法见下图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-2161dedfa7242b3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="操作步骤图"
                ></p>
<h3 id="CocoapPods-第三方库-报错同样的解决办法见下图"><a href="#CocoapPods-第三方库-报错同样的解决办法见下图" class="headerlink" title="CocoapPods 第三方库 报错同样的解决办法见下图"></a>CocoapPods 第三方库 报错同样的解决办法见下图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-0b33c4b741a47ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="操作步骤图"
                ></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
        <tag>App Extension</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 用户可编辑的 Widget</title>
    <url>/2020/11/27/500-iOS14-Widget-%E5%BC%80%E5%8F%91-1/</url>
    <content><![CDATA[<h3 id="本篇是用户可编辑的-Widget"><a href="#本篇是用户可编辑的-Widget" class="headerlink" title="本篇是用户可编辑的 Widget"></a>本篇是用户可编辑的 Widget</h3><h3 id="用户不可编辑的-Widget，点我去看"><a href="#用户不可编辑的-Widget，点我去看" class="headerlink" title="用户不可编辑的 Widget，点我去看"></a><a class="link"   href="https://www.jianshu.com/p/84c180963ac6" >用户不可编辑的 Widget，点我去看<i class="fas fa-external-link-alt"></i></a></h3><h3 id="编辑屏幕-Widget-不显示，Widget-加载网络图片"><a href="#编辑屏幕-Widget-不显示，Widget-加载网络图片" class="headerlink" title="编辑屏幕 Widget 不显示，Widget 加载网络图片"></a><a class="link"   href="https://www.jianshu.com/p/a80d59c94442" >编辑屏幕 Widget 不显示，Widget 加载网络图片<i class="fas fa-external-link-alt"></i></a></h3><h1 id="Demo-下载"><a href="#Demo-下载" class="headerlink" title="Demo 下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo 下载<i class="fas fa-external-link-alt"></i></a></h1><h1 id="先来看效果图"><a href="#先来看效果图" class="headerlink" title="先来看效果图"></a>先来看效果图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-196fcdf3f96e1360.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="效果图"
                ></p>
<h1 id="建议将-demo-下载下来对照着看对应-demo-里的-AnimalWidget-文件"><a href="#建议将-demo-下载下来对照着看对应-demo-里的-AnimalWidget-文件" class="headerlink" title="建议将 demo 下载下来对照着看对应 demo 里的 AnimalWidget 文件"></a>建议将 demo 下载下来对照着看对应 demo 里的 AnimalWidget 文件</h1><h3 id="1-新建-Widget-Extension，勾选-Intent。"><a href="#1-新建-Widget-Extension，勾选-Intent。" class="headerlink" title="1. 新建 Widget Extension，勾选 Intent。"></a>1. 新建 Widget Extension，勾选 Intent。</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-4c736e922128a5f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="1. 新建 Widget Extension，勾选 Intent"
                ></p>
<h3 id="2-点击-AnimalWidget-intentdefinition-文件-添加可编辑的数据类型-具体操作看图吧"><a href="#2-点击-AnimalWidget-intentdefinition-文件-添加可编辑的数据类型-具体操作看图吧" class="headerlink" title="2. 点击 AnimalWidget.intentdefinition 文件 添加可编辑的数据类型 具体操作看图吧"></a>2. 点击 AnimalWidget.intentdefinition 文件 添加可编辑的数据类型 具体操作看图吧</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-e26dffe1a81d1a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="2. 点击 AnimalWidget.intentdefinition 文件 具体操作看图吧"
                ></p>
<h3 id="3-为第二步新增的数据类型-设置对应的值"><a href="#3-为第二步新增的数据类型-设置对应的值" class="headerlink" title="3. 为第二步新增的数据类型 设置对应的值"></a>3. 为第二步新增的数据类型 设置对应的值</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-6c898cf25193f0c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="image.png"
                ></p>
<h3 id="4-编辑-Info-plist-️是-widget-extension-的-Info-plist"><a href="#4-编辑-Info-plist-️是-widget-extension-的-Info-plist" class="headerlink" title="4. 编辑 Info.plist (️是 widget extension 的 Info.plist )"></a>4. 编辑 Info.plist (️是 widget extension 的 Info.plist )</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSExtension&lt;&#x2F;key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;IntentsSupported&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;string&gt;AnimalWidgetConfigurationIntent&lt;&#x2F;string&gt;</span><br><span class="line">		&lt;&#x2F;array&gt;</span><br><span class="line">		&lt;key&gt;NSExtensionAttributes&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;dict&gt;</span><br><span class="line">			&lt;key&gt;IntentsRestrictedWhileLocked&lt;&#x2F;key&gt;</span><br><span class="line">			&lt;array&#x2F;&gt;</span><br><span class="line">			&lt;key&gt;IntentsRestrictedWhileProtectedDataUnavailable&lt;&#x2F;key&gt;</span><br><span class="line">			&lt;array&#x2F;&gt;</span><br><span class="line">			&lt;key&gt;IntentsSupported&lt;&#x2F;key&gt;</span><br><span class="line">			&lt;array&gt;</span><br><span class="line">				&lt;string&gt;AnimalWidgetConfigurationIntent&lt;&#x2F;string&gt;</span><br><span class="line">			&lt;&#x2F;array&gt;</span><br><span class="line">		&lt;&#x2F;dict&gt;</span><br><span class="line">		&lt;key&gt;NSExtensionPointIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;string&gt;com.apple.intents-service&lt;&#x2F;string&gt;</span><br><span class="line">		&lt;key&gt;NSExtensionPrincipalClass&lt;&#x2F;key&gt;</span><br><span class="line">		&lt;string&gt;$(PRODUCT_MODULE_NAME).IntentHandler&lt;&#x2F;string&gt;</span><br><span class="line">	&lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-8bb6ff14aab5c9eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="4. 编辑 Info.plist (️是 widget extension 的 Info.plist )"
                ></p>
<h3 id="5-创建-IntentHandler-swift-添加一下代码-可能会报错-找不到-AnimalWidgetConfigurationIntentHandling-、AnimalWidgetConfigurationIntent-先不管先把别的配置好"><a href="#5-创建-IntentHandler-swift-添加一下代码-可能会报错-找不到-AnimalWidgetConfigurationIntentHandling-、AnimalWidgetConfigurationIntent-先不管先把别的配置好" class="headerlink" title="5. 创建 IntentHandler.swift 添加一下代码 (可能会报错 找不到 AnimalWidgetConfigurationIntentHandling 、AnimalWidgetConfigurationIntent  先不管先把别的配置好)"></a>5. 创建 IntentHandler.swift 添加一下代码 (可能会报错 找不到 AnimalWidgetConfigurationIntentHandling 、AnimalWidgetConfigurationIntent  先不管先把别的配置好)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Intents</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 自己创建的文件</span><br><span class="line">class IntentHandler: INExtension, AnimalWidgetConfigurationIntentHandling &#123; &#x2F;&#x2F; AnimalWidgetConfigurationIntentHandling 是第二步的名字 加上 IntentHandling 后缀</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 配置给用户可选的列表                    AnimalWidgetConfigurationIntent 是第二步的名字 加上 Intent 后缀</span><br><span class="line">    func provideAnimalOptionsCollection(for intent: AnimalWidgetConfigurationIntent, searchTerm: String?, with completion: @escaping (INObjectCollection&lt;Animal&gt;?, Error?) -&gt; Void) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 这里可以去请求网络拿数据</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;&#x2F;搜索词 searchTerm 搜索cat</span><br><span class="line">        if searchTerm &#x3D;&#x3D; &quot;cat&quot; &#123;</span><br><span class="line">            completion(INObjectCollection(items: [Animal(identifier: &quot;cat&quot;, display: &quot;cat&quot;)]), nil)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let animals: [Animal] &#x3D; XXXAnimal.zoo.map &#123; (xxxAnimal) in</span><br><span class="line">            return Animal(identifier: xxxAnimal.id, display: xxxAnimal.name)</span><br><span class="line">        &#125;</span><br><span class="line">        completion(INObjectCollection(items: animals), nil)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func handler(for intent: INIntent) -&gt; Any &#123;</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-修改-AnimalWidget-swift-内容"><a href="#6-修改-AnimalWidget-swift-内容" class="headerlink" title="6. 修改 AnimalWidget.swift 内容"></a>6. 修改 AnimalWidget.swift 内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你的工程已经存在了一个 Widget 将 @main 去掉</span><br><span class="line">使用下面</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我的这部分代码在 XXXWidget.swift</span><br><span class="line">@main</span><br><span class="line">struct AllWidget: WidgetBundle &#123;</span><br><span class="line">    </span><br><span class="line">    @WidgetBundleBuilder</span><br><span class="line">    var body: some Widget &#123;</span><br><span class="line">        XXXWidget()</span><br><span class="line">        AnimalWidget()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="修改-TimelineEntry"><a href="#修改-TimelineEntry" class="headerlink" title="修改 TimelineEntry"></a>修改 TimelineEntry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct SimpleEntry: TimelineEntry &#123;</span><br><span class="line">    let date: Date</span><br><span class="line">    let configuration: ConfigurationIntent</span><br><span class="line">&#125;</span><br><span class="line">--------------原️----新️-----------------</span><br><span class="line">&#x2F;&#x2F;&#x2F; 重新命名 去掉 let configuration: ConfigurationIntent  （也可以保留但类型是 AnimalWidgetConfigurationIntent）</span><br><span class="line">&#x2F;&#x2F;&#x2F;增加自己需要的参数</span><br><span class="line">struct AnimalSimpleEntry: TimelineEntry &#123;</span><br><span class="line">    let date: Date</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 新加自己需要的参数</span><br><span class="line">    let animal: XXXAnimal</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="修改-IntentTimelineProvider"><a href="#修改-IntentTimelineProvider" class="headerlink" title="修改 IntentTimelineProvider"></a>修改 IntentTimelineProvider</h4><h4 id="️-涉及到-AnimalWidgetConfigurationIntent-可能会报错-先不管-️"><a href="#️-涉及到-AnimalWidgetConfigurationIntent-可能会报错-先不管-️" class="headerlink" title="️ 涉及到 AnimalWidgetConfigurationIntent 可能会报错 先不管 ️"></a><strong>️ 涉及到 AnimalWidgetConfigurationIntent 可能会报错 先不管 ️</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct Provider: IntentTimelineProvider &#123;</span><br><span class="line">    func placeholder(in context: Context) -&gt; SimpleEntry &#123;</span><br><span class="line">        SimpleEntry(date: Date(), configuration: ConfigurationIntent())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getSnapshot(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (SimpleEntry) -&gt; ()) &#123;</span><br><span class="line">        let entry &#x3D; SimpleEntry(date: Date(), configuration: configuration)</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getTimeline(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123;</span><br><span class="line">        var entries: [SimpleEntry] &#x3D; []</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Generate a timeline consisting of five entries an hour apart, starting from the current date.</span><br><span class="line">        let currentDate &#x3D; Date()</span><br><span class="line">        for hourOffset in 0 ..&lt; 5 &#123;</span><br><span class="line">            let entryDate &#x3D; Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!</span><br><span class="line">            let entry &#x3D; SimpleEntry(date: entryDate, configuration: configuration)</span><br><span class="line">            entries.append(entry)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let timeline &#x3D; Timeline(entries: entries, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------原️----新️-----------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重新命名</span><br><span class="line">struct AnimalProvider: IntentTimelineProvider &#123;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 按照要求增加  Entry 和 Intent</span><br><span class="line">    typealias Entry &#x3D; AnimalSimpleEntry</span><br><span class="line">    typealias Intent &#x3D; AnimalWidgetConfigurationIntent</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    func placeholder(in context: Context) -&gt; AnimalSimpleEntry &#123;</span><br><span class="line">        AnimalSimpleEntry(date: Date(), animal: .lion)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getSnapshot(for configuration: AnimalWidgetConfigurationIntent, in context: Context, completion: @escaping (AnimalSimpleEntry) -&gt; ()) &#123;</span><br><span class="line">        let entry &#x3D; AnimalSimpleEntry(date: Date(), animal: .lion)</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    func getTimeline(for configuration: AnimalWidgetConfigurationIntent, in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        let currentDate &#x3D; Date()</span><br><span class="line">        </span><br><span class="line">        guard let id &#x3D; configuration.animal?.identifier, let entryDate &#x3D; Calendar.current.date(byAdding: .minute, value: 1, to: currentDate) else &#123;</span><br><span class="line">            let timeline &#x3D; Timeline(entries: [AnimalSimpleEntry(date: currentDate, animal: .lion)], policy: .atEnd)</span><br><span class="line">            completion(timeline)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let entry &#x3D; AnimalSimpleEntry(date: entryDate, animal: XXXAnimal.animal(id, color: configuration.color))</span><br><span class="line">        </span><br><span class="line">        let timeline &#x3D; Timeline(entries: [entry], policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他地方对照-demo-修改就可以了"><a href="#其他地方对照-demo-修改就可以了" class="headerlink" title="其他地方对照 demo 修改就可以了"></a>其他地方对照 demo 修改就可以了</h2><h1 id="️如果有-Cannot-find-type-‘AnimalWidgetConfigurationIntent’-in-scope-报错-尝试多-build-几次或者-重启-Xcode️"><a href="#️如果有-Cannot-find-type-‘AnimalWidgetConfigurationIntent’-in-scope-报错-尝试多-build-几次或者-重启-Xcode️" class="headerlink" title="️如果有  Cannot find type ‘AnimalWidgetConfigurationIntent’ in scope 报错 尝试多 build 几次或者 重启 Xcode️"></a>️如果有  Cannot find type ‘AnimalWidgetConfigurationIntent’ in scope 报错 尝试多 build 几次或者 重启 Xcode️</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-194231fd2ac108f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="其他注意"
                ></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS14 Widget</title>
    <url>/2020/11/26/500-iOS14-Widget-%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Demo-下载"><a href="#Demo-下载" class="headerlink" title="Demo 下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo 下载<i class="fas fa-external-link-alt"></i></a></h1><h3 id="这个是用户不可配置的，没有编辑选项的-widget"><a href="#这个是用户不可配置的，没有编辑选项的-widget" class="headerlink" title="这个是用户不可配置的，没有编辑选项的 widget"></a>这个是用户不可配置的，没有编辑选项的 widget</h3><h3 id="Intent-用户可编辑的点我去看"><a href="#Intent-用户可编辑的点我去看" class="headerlink" title="Intent 用户可编辑的点我去看"></a><a class="link"   href="https://www.jianshu.com/p/029c85bdf16b" >Intent 用户可编辑的点我去看<i class="fas fa-external-link-alt"></i></a></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-126d13797dd4e2de.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="效果图"
                ></p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 时间线</span><br><span class="line">struct XXXProvider: TimelineProvider &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 占位的展示</span><br><span class="line">    func placeholder(in context: Context) -&gt; XXXSimpleEntry &#123;</span><br><span class="line">        XXXSimpleEntry(date: Date(), displayTime: XXXData.displayData())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 快照</span><br><span class="line">    func getSnapshot(in context: Context, completion: @escaping (XXXSimpleEntry) -&gt; ()) &#123;</span><br><span class="line">        let entry &#x3D; XXXSimpleEntry(date: Date(), displayTime: XXXData.displayData())</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;根据时间线提供需要展示的状态</span><br><span class="line">    func getTimeline(in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;时间线刷新了&quot; + &quot;\(Date())&quot;)</span><br><span class="line">        </span><br><span class="line">        var entrys: [XXXSimpleEntry] &#x3D; []</span><br><span class="line">        let currentData &#x3D; Date()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 提供当前时间后 1个小时内  每一秒的状态 (已经提供了3600个状态，太多会不展示卡死)</span><br><span class="line">        for i in 0...60*60 &#123;</span><br><span class="line">            guard let entryDate &#x3D; Calendar.current.date(byAdding: .second, value: i, to: currentData) else &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            entrys.append(XXXSimpleEntry(date: entryDate, displayTime: XXXData.displayData(entryDate)))</span><br><span class="line">        &#125;</span><br><span class="line">        let timeline &#x3D; Timeline(entries: entrys, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 每一个时间线的实体</span><br><span class="line">struct XXXSimpleEntry: TimelineEntry &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;展示该状态的时间</span><br><span class="line">    let date: Date</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 自己配置的数据</span><br><span class="line">    let displayTime: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; widget 展示 view</span><br><span class="line">struct XXXWidgetEntryView : View &#123;</span><br><span class="line">    var entry: XXXProvider.Entry</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 返回在这个时间 (entry.date)    你想要展示的widegt样式</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ZStack &#123;</span><br><span class="line">            </span><br><span class="line">            Color.orange.edgesIgnoringSafeArea(.all)</span><br><span class="line">            VStack &#123;</span><br><span class="line">                Text(entry.displayTime)</span><br><span class="line">                    .multilineTextAlignment(.center)</span><br><span class="line">                    .foregroundColor(.blue)</span><br><span class="line">                    &#x2F;&#x2F;&#x2F;配置点击链接会在主工程收到拉起事件</span><br><span class="line">                    .widgetURL(URL(string: &quot;widgetDemo:&#x2F;&#x2F;789&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;widget</span><br><span class="line">struct XXXWidget: Widget &#123;</span><br><span class="line">    let kind: String &#x3D; &quot;XXXWidget&quot;</span><br><span class="line"></span><br><span class="line">    var body: some WidgetConfiguration &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; StaticConfiguration 是静态的，用户不可配置的 长按不会出现编辑</span><br><span class="line">        StaticConfiguration(kind: kind, provider: XXXProvider()) &#123; entry in</span><br><span class="line">            XXXWidgetEntryView(entry: entry)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(&quot;添加时的标题&quot;)</span><br><span class="line">        .description(&quot;添加时的描述&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;提供预览状态</span><br><span class="line">struct XXXWidget_Previews: PreviewProvider &#123;</span><br><span class="line">    </span><br><span class="line">    static var previews: some View &#123;</span><br><span class="line">        XXXWidgetEntryView(entry: XXXSimpleEntry(date: Date(), displayTime: XXXData.displayData()))</span><br><span class="line">            .previewContext(WidgetPreviewContext(family: .systemSmall))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;主入口</span><br><span class="line">@main</span><br><span class="line">struct AllWidget: WidgetBundle &#123;</span><br><span class="line">    </span><br><span class="line">    @WidgetBundleBuilder</span><br><span class="line">    var body: some Widget &#123;</span><br><span class="line">        XXXWidget()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="部分操作的详细截图"><a href="#部分操作的详细截图" class="headerlink" title="部分操作的详细截图"></a>部分操作的详细截图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-d4e70bcacfcacc7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="File -&gt; New -&gt; Target"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-b19a4ce4f064179c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="这个是用户不可配置的widget，勾选的是用户可配置的。我们先来做不可配置的"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-786376718471b3c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="调整最低运行系统"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-5fcaf3ede4232577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="关联主工程数据"
                ></p>
<h1 id="Demo-下载-1"><a href="#Demo-下载-1" class="headerlink" title="Demo 下载"></a><a class="link"   href="https://github.com/xxxIxxxx/WidgetDemo" >Demo 下载<i class="fas fa-external-link-alt"></i></a></h1>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS占位图、空白页面</title>
    <url>/2020/11/24/500-iOS%E5%8D%A0%E4%BD%8D%E5%9B%BE%E3%80%81%E7%A9%BA%E7%99%BD%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="iOS占位图、空白页面-Github直达"><a href="#iOS占位图、空白页面-Github直达" class="headerlink" title="iOS占位图、空白页面 Github直达"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXPlaceholder" >iOS占位图、空白页面 Github直达<i class="fas fa-external-link-alt"></i></a></h1><h1 id="iOS占位图、空白页面-适用于view、tableView、collectionView、scrollvew"><a href="#iOS占位图、空白页面-适用于view、tableView、collectionView、scrollvew" class="headerlink" title="iOS占位图、空白页面 适用于view、tableView、collectionView、scrollvew"></a>iOS占位图、空白页面 适用于view、tableView、collectionView、scrollvew</h1><h1 id="😄😄😄"><a href="#😄😄😄" class="headerlink" title="😄😄😄"></a>😄😄😄</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-337781e6ecaac4ae.gif?imageMogr2/auto-orient/strip"
                      alt="tableView使用效果"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-37d81ba5477c72c3.gif?imageMogr2/auto-orient/strip"
                      alt="view使用效果"
                ></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a><em>注意</em></h1><h5 id="1-当tableView、collectionView-有数据时（row-gt-0，item-gt-0）不显示占位图"><a href="#1-当tableView、collectionView-有数据时（row-gt-0，item-gt-0）不显示占位图" class="headerlink" title="1.当tableView、collectionView 有数据时（row&gt;0，item&gt;0）不显示占位图"></a>1.当tableView、collectionView 有数据时（row&gt;0，item&gt;0）不显示占位图</h5><h5 id="2-当scrollView-contentSize-height-gt-scrollView-frame-size-height-时临时禁用滑动属性（tableView、collectionView优先遵循第一条）"><a href="#2-当scrollView-contentSize-height-gt-scrollView-frame-size-height-时临时禁用滑动属性（tableView、collectionView优先遵循第一条）" class="headerlink" title="2.当scrollView.contentSize.height &gt; scrollView.frame.size.height 时临时禁用滑动属性（tableView、collectionView优先遵循第一条）"></a>2.当scrollView.contentSize.height &gt; scrollView.frame.size.height 时临时禁用滑动属性（tableView、collectionView优先遵循第一条）</h5><h5 id="3-建议导入demo中的XXXPlaceholderEX文件夹"><a href="#3-建议导入demo中的XXXPlaceholderEX文件夹" class="headerlink" title="3.建议导入demo中的XXXPlaceholderEX文件夹"></a>3.建议导入demo中的XXXPlaceholderEX文件夹</h5><h5 id="4-占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件"><a href="#4-占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件" class="headerlink" title="4.占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件"></a>4.占位图中的button会自动添加点击事件，无需添加。没有button会给整个占位图添加点击事件</h5><h5 id="5-我觉得用法还是挺简单的，看下demo吧😂"><a href="#5-我觉得用法还是挺简单的，看下demo吧😂" class="headerlink" title="5.我觉得用法还是挺简单的，看下demo吧😂"></a>5.我觉得用法还是挺简单的，看下demo吧😂</h5><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo update</span><br><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json  (清除搜索缓存)</span><br><span class="line">pod &#39;XXXPlaceholder&#39;, &#39;~&gt; 0.0.1&#39;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>参照demo创建占位图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;self为tableView</span><br><span class="line">self.xxx_emptyView &#x3D; [XXXPlaceholderView emptyView];</span><br><span class="line">self.xxx_noNetworkView &#x3D; [XXXPlaceholderView noNetworkView];</span><br><span class="line">&#x2F;&#x2F;占位图会自动添加点击事件</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>tableView、collectionView 展示占位图调用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">刷新数据源 tableView、collectionView专用</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_reloadData;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line">刷新数据源 tableView、collectionView专用</span><br><span class="line">@param clickBlock 占位图点击事件Block</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_reloadDataWithClickBlock:  (nullable   XXXPlaceholderClickBlock)clickBlock;</span><br><span class="line"></span><br><span class="line">[self.tableView xxx_reloadDataWithClickBlock:^&#123;</span><br><span class="line">           &#x2F;&#x2F;这里做再次请求</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></li>
<li><p>view使用 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> 展示无数据占位图</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)xxx_showEmptyView;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">展示无数据占位图</span><br><span class="line">@param clickBlock 占位图点击事件Block</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_showEmptyViewWithClickBlock:(nullable XXXPlaceholderClickBlock)clickBlock;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">展示无网络占位图</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_showNoNetWorkView;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">展示无网络占位图</span><br><span class="line">@param clickBlock 占位图点击事件Block</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)xxx_showNoNetWorkViewWithClickBlock:(nullable XXXPlaceholderClickBlock)clickBlock;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line"> 移出所有占位图</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)xxx_removePlaceholderView;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="Github直达"><a href="#Github直达" class="headerlink" title="Github直达"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXPlaceholder" >Github直达<i class="fas fa-external-link-alt"></i></a></h1></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS拖拽卡片</title>
    <url>/2020/11/22/500-iOS%E6%8B%96%E6%8B%BD%E5%8D%A1%E7%89%87%E5%8F%A0%E5%8A%A0%E5%8D%A1%E7%89%87/</url>
    <content><![CDATA[<h1 id="github-XXXCardStore"><a href="#github-XXXCardStore" class="headerlink" title="github XXXCardStore"></a><a class="link"   href="https://github.com/xxxIxxxx/XXXCardStore" >github XXXCardStore<i class="fas fa-external-link-alt"></i></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-86f449d502adaa19.gif?imageMogr2/auto-orient/strip"
                      alt="效果图"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://upload-images.jianshu.io/upload_images/2331323-70de1ba83f9ad822.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="说明图"
                ></p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol>
<li>pod search XXXCardStore<br>如未搜索到 请执行 pod repo update 进行更新，然后清除搜索缓存 rm ~/Library/Caches/CocoaPods/search_index.json</li>
<li>pod ‘XXXCardStore’</li>
<li>import &lt; XXXCardStore .h&gt;</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">XXXCardStore *xxx &#x3D; [XXXCardStore new];</span><br><span class="line">    [self.view addSubview:xxx];</span><br><span class="line">    xxx.frame &#x3D; CGRectMake(50, 100, 300, 200);</span><br><span class="line">    xxx.cardOffset &#x3D; 10.0;</span><br><span class="line">    xxx.isInfiniteLoop &#x3D;YES;</span><br><span class="line">    xxx.delegate &#x3D; self;</span><br><span class="line">    xxx.imgUrlStrArr &#x3D; @[@&quot;http:&#x2F;&#x2F;f.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;203fb80e7bec54e7c340af43b2389b504fc26a3b.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;d.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;0d338744ebf81a4c6231d43ddb2a6059242da6c6.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;a.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;4e4a20a4462309f788a28152790e0cf3d6cad6a4.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;d.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;810a19d8bc3eb135101902e6ad1ea8d3fc1f4494.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;f.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;86d6277f9e2f0708a5559f5de224b899a901f21f.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;h.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;ca1349540923dd5441e81235da09b3de9d8248d7.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;c.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;faedab64034f78f09d3f2eae72310a55b3191cb2.jpg&quot;,</span><br><span class="line">                         @&quot;http:&#x2F;&#x2F;d.hiphotos.baidu.com&#x2F;image&#x2F;pic&#x2F;item&#x2F;622762d0f703918f037f88975a3d269758eec4c5.jpg&quot;</span><br><span class="line">                         ];</span><br><span class="line">    [xxx reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tapCard:(NSInteger)index cardStore:(UIView *)xxxCardStore&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;--- tap   &#x3D;&#x3D;&#x3D;  %ld&quot;,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="自定义卡片内容"><a href="#自定义卡片内容" class="headerlink" title="自定义卡片内容"></a>自定义卡片内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 自定义卡片内容</span><br><span class="line"> </span><br><span class="line"> @param customCard 你的customView 内部试图未清除</span><br><span class="line"> @param index 需要准备的 card的 index</span><br><span class="line"> @param xxxCardStore xxxCardStore 主体</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)customCardView:(UIView *)customCard index:(NSInteger)index cardStore:(UIView *)xxxCardStore;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 代理检测</title>
    <url>/2021/04/14/500-iOS%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary *proxySettings &#x3D; CFBridgingRelease(CFNetworkCopySystemProxySettings());</span><br><span class="line">    NSArray *proxies &#x3D; CFBridgingRelease(CFNetworkCopyProxiesForURL((__bridge CFURLRef)[NSURL URLWithString:@&quot;https:&#x2F;&#x2F;www.baidu.com&quot;], (__bridge CFDictionaryRef)proxySettings));</span><br><span class="line">    if (proxies.count &gt; 0) &#123;</span><br><span class="line">        NSDictionary *settings &#x3D; proxies[0];</span><br><span class="line">        NSString *type &#x3D; [settings objectForKey:(NSString *)kCFProxyTypeKey];</span><br><span class="line">        if (![type isEqualToString:(NSString *)kCFProxyTypeNone]) &#123;</span><br><span class="line">            NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 开启代理&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 未开启代理&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS mask 遮罩，彩色文本</title>
    <url>/2020/11/20/500-iOS%E6%B8%90%E5%8F%98%E5%BD%A9%E8%89%B2%E6%96%87%E5%AD%97%E3%80%81iOS-mask-%E9%81%AE%E7%BD%A9/</url>
    <content><![CDATA[<h1 id="iOS-渐变彩色文字、iOS-mask-遮罩"><a href="#iOS-渐变彩色文字、iOS-mask-遮罩" class="headerlink" title="iOS 渐变彩色文字、iOS mask 遮罩"></a>iOS 渐变彩色文字、iOS mask 遮罩</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://upload-images.jianshu.io/upload_images/2331323-2f3e46c5908444fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                      alt="效果图"
                ></p>
<p><a class="link"   href="https://github.com/ibireme/YYCategories" >使用到了 YYCategories<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="彩色文字"><a href="#彩色文字" class="headerlink" title="彩色文字"></a>彩色文字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIView *colorBgView &#x3D; [UIView new];</span><br><span class="line">    [self.view addSubview:colorBgView];</span><br><span class="line">    colorBgView.frame &#x3D; CGRectMake(0, 300, UIScreen.mainScreen.bounds.size.width, 40);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里用了YYCategories</span><br><span class="line">    UIBezierPath *colorTextPath &#x3D; [UIBezierPath bezierPathWithText:@&quot;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&quot; font:[UIFont systemFontOfSize:28]];</span><br><span class="line">    CAShapeLayer *colorTextLayer &#x3D; [CAShapeLayer layer];</span><br><span class="line">    colorTextLayer.path &#x3D; colorTextPath.CGPath;</span><br><span class="line">    colorTextLayer.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">    colorBgView.layer.mask &#x3D; colorTextLayer;</span><br><span class="line"></span><br><span class="line">    CAGradientLayer *colorLayer &#x3D; CAGradientLayer.new;</span><br><span class="line">    colorLayer.colors &#x3D; @[(__bridge id)UIColor.redColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.orangeColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.greenColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.blueColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.yellowColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.purpleColor.CGColor,</span><br><span class="line">                          (__bridge id)UIColor.blackColor.CGColor,];</span><br><span class="line">    colorLayer.startPoint &#x3D; CGPointMake(0, 0.5);</span><br><span class="line">    colorLayer.endPoint &#x3D; CGPointMake(1, 0.5);</span><br><span class="line">    colorLayer.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 40);</span><br><span class="line">    [colorBgView.layer addSublayer:colorLayer];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="过渡遮罩"><a href="#过渡遮罩" class="headerlink" title="过渡遮罩"></a>过渡遮罩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> &#x2F;&#x2F;&#x2F;黑色背景view</span><br><span class="line">    UIView *indicatorView &#x3D; [UIView new];</span><br><span class="line">    [self.view addSubview:indicatorView];</span><br><span class="line">    indicatorView.backgroundColor &#x3D; UIColor.blackColor;</span><br><span class="line">    indicatorView.layer.cornerRadius &#x3D; 20;</span><br><span class="line">    indicatorView.layer.masksToBounds &#x3D; YES;</span><br><span class="line">    indicatorView.frame &#x3D; CGRectMake(0, 195, 100, 40);</span><br><span class="line">    self.indicatorView &#x3D; indicatorView;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;这里用了YYCategories</span><br><span class="line">    UIBezierPath *textPath &#x3D; [UIBezierPath bezierPathWithText:@&quot;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&quot; font:[UIFont systemFontOfSize:28]];</span><br><span class="line">    CAShapeLayer *textLayer &#x3D; [CAShapeLayer layer];</span><br><span class="line">    textLayer.path &#x3D; textPath.CGPath;</span><br><span class="line">    textLayer.frame &#x3D; CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UIView *darkView &#x3D; [UIView new];</span><br><span class="line">    [self.view addSubview:darkView];</span><br><span class="line">    darkView.backgroundColor &#x3D; UIColor.darkGrayColor;</span><br><span class="line">    darkView.frame &#x3D; CGRectMake(0, 200, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">    darkView.layer.mask &#x3D; textLayer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    UIView *whiteView &#x3D; [UIView new];</span><br><span class="line">    [darkView addSubview:whiteView];</span><br><span class="line">    whiteView.backgroundColor &#x3D; UIColor.whiteColor;</span><br><span class="line">    whiteView.layer.cornerRadius &#x3D; 20;</span><br><span class="line">    whiteView.layer.masksToBounds &#x3D; YES;</span><br><span class="line">    whiteView.frame &#x3D; CGRectMake(0, -5, 100, 40);</span><br><span class="line">    self.whiteView &#x3D; whiteView;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;也可以使用layer</span><br><span class="line">&#x2F;&#x2F;    CALayer *darkLayer &#x3D; CALayer.new;</span><br><span class="line">&#x2F;&#x2F;    [self.view.layer addSublayer:darkLayer];</span><br><span class="line">&#x2F;&#x2F;    darkLayer.backgroundColor &#x3D; UIColor.darkGrayColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    darkLayer.frame &#x3D; CGRectMake(0, 200, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line">&#x2F;&#x2F;    darkLayer.mask &#x3D; textLayer;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    CAShapeLayer *whiteLayer &#x3D; CAShapeLayer.new;</span><br><span class="line">&#x2F;&#x2F;    [darkLayer addSublayer:whiteLayer];</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.backgroundColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.fillColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.strokeColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.borderColor &#x3D; UIColor.whiteColor.CGColor;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.cornerRadius &#x3D; 20;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.masksToBounds &#x3D; YES;</span><br><span class="line">&#x2F;&#x2F;    whiteLayer.frame &#x3D; CGRectMake(0, -5, 100, 40);</span><br><span class="line">&#x2F;&#x2F;    self.whiteLayer &#x3D; whiteLayer;</span><br><span class="line"></span><br><span class="line">    UISlider *slider &#x3D; UISlider.new;</span><br><span class="line">    [self.view addSubview:slider];</span><br><span class="line">    [slider addTarget:self action:@selector(changeFrame:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line">    slider.frame &#x3D; CGRectMake(0, 260, UIScreen.mainScreen.bounds.size.width, 30);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">- (void)changeFrame:(UISlider *)slider &#123;</span><br><span class="line"></span><br><span class="line">    CGFloat x &#x3D; UIScreen.mainScreen.bounds.size.width *slider.value;</span><br><span class="line">    self.indicatorView.frame &#x3D; CGRectMake(x, 195, 100, 40);</span><br><span class="line">    self.whiteView.frame &#x3D; CGRectMake(x, -5, 100, 40);</span><br><span class="line">    self.whiteLayer.frame &#x3D; CGRectMake(x, -5, 100, 40);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>在 M1 芯片的 Mac 上使用 CocoaPods</title>
    <url>/2021/05/17/500-%E5%9C%A8%20M1%E8%8A%AF%E7%89%87%E7%9A%84%20Mac%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20CocoaPods/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近换了 M1 芯片的 MacBook Pro，在配置环境完成后 <code>pod install</code> 操作发现出错了。</p>
<h1 id="在-M1-上使用-CocoaPods-的方法。"><a href="#在-M1-上使用-CocoaPods-的方法。" class="headerlink" title="在 M1 上使用 CocoaPods 的方法。"></a>在 M1 上使用 CocoaPods 的方法。</h1><h2 id="1-首先执行一次"><a href="#1-首先执行一次" class="headerlink" title="1. 首先执行一次"></a>1. 首先执行一次</h2><p><code>sudo arch -x86_64 gem install ffi</code></p>
<h2 id="2-然后再替换之前-pod-install"><a href="#2-然后再替换之前-pod-install" class="headerlink" title="2. 然后再替换之前 pod install"></a>2. 然后再替换之前 pod install</h2><p><code>arch -x86_64 pod install</code></p>
<h1 id="如何查找解决方案"><a href="#如何查找解决方案" class="headerlink" title="如何查找解决方案"></a>如何查找解决方案</h1><p>第一时间想到去 <a class="link"   href="https://github.com/CocoaPods/CocoaPods/issues" >CocoaPods issues<i class="fas fa-external-link-alt"></i></a> 搜索相关问题。<br>然后果然在 <a class="link"   href="https://github.com/CocoaPods/CocoaPods/issues/10220" >Got error while trying pod install<i class="fas fa-external-link-alt"></i></a> 中找到了解决方案。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序引入模块，App.js</title>
    <url>/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="创建一个模块-utils-appConfig-js"><a href="#创建一个模块-utils-appConfig-js" class="headerlink" title="创建一个模块 utils/appConfig.js"></a>创建一个模块 utils/appConfig.js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const appConfig &#x3D; &#123;</span><br><span class="line">  host: &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">  sayHi(e) &#123;</span><br><span class="line">    console.log(&#39;hi&#39; + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default appConfig</span><br></pre></td></tr></table></figure>

<h1 id="导入创建的模块使用-其他-js-文件内"><a href="#导入创建的模块使用-其他-js-文件内" class="headerlink" title="导入创建的模块使用     其他 .js 文件内"></a>导入创建的模块使用     其他 .js 文件内</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import appConfig from &#39;..&#x2F;..&#x2F;..&#x2F;utils&#x2F;appConfig.js&#39;;</span><br><span class="line">console.log(appConfig.host);</span><br><span class="line">appConfig.sayHi(&#39;朱小明&#39;)</span><br></pre></td></tr></table></figure>


<h1 id="获取-App-js"><a href="#获取-App-js" class="headerlink" title="获取 App.js"></a>获取 App.js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  userToken:&#39;zhu xiao ming&#39;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; 省略其他</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let app &#x3D; getApp();</span><br><span class="line">console.log(app.userToken);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序界面跳转传值、反向传值</title>
    <url>/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h1 id="page1-点击事件-wxml"><a href="#page1-点击事件-wxml" class="headerlink" title="page1 点击事件 .wxml"></a>page1 点击事件 .wxml</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text bind:tap&#x3D;&quot;pushNav&quot;&gt;界面跳转传值&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure>
<h1 id="page1-跳转方法实现-js"><a href="#page1-跳转方法实现-js" class="headerlink" title="page1 跳转方法实现 .js"></a>page1 跳转方法实现 .js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushNav(e) &#123;</span><br><span class="line">    </span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      &#x2F;&#x2F; 跳转传值方式 1</span><br><span class="line">      url: &#39;..&#x2F;page2?carName&#x3D;&#39; + &#39;特斯拉&#39;,</span><br><span class="line"></span><br><span class="line">      events: &#123;</span><br><span class="line">        &#x2F;&#x2F; 反向传值 page2 回调给 page1 接收处</span><br><span class="line">        getuserInfoClick(e) &#123;</span><br><span class="line">          console.log(e);</span><br><span class="line">          that.setData(&#123; userName: e.userName &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        &#x2F;&#x2F; 跳转传值方式 2</span><br><span class="line">        &#x2F;&#x2F; 这个其实有点类似于通知的意思 定义通知名称 和 参数</span><br><span class="line">        res.eventChannel.emit(&#39;diyfunName&#39;, &#123; parKey: &#39;我是通过 eventChannel 传递的另一个数据&#39; &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h1 id="page2-接收传值，并回传-js"><a href="#page2-接收传值，并回传-js" class="headerlink" title="page2 接收传值，并回传  .js"></a>page2 接收传值，并回传  .js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过方式1 传值接收</span><br><span class="line">    this.setData(&#123; carName: options.carName &#125;);</span><br><span class="line"></span><br><span class="line">    const eventChannel &#x3D; this.getOpenerEventChannel();</span><br><span class="line">    </span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 反向传值 page2 传给 page1</span><br><span class="line">    eventChannel.emit(&#39;getuserInfoClick&#39;, &#123; userName: &#39;朱小明&#39; &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F; 通过方式2 传值接收</span><br><span class="line">    eventChannel.on(&#39;diyfunName&#39;, function (params) &#123;</span><br><span class="line">      that.setData(&#123; otherPar: params.parKey &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序自定义组件、父子组件相互调用传值</title>
    <url>/2021/01/15/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-创建-header-组件"><a href="#1-创建-header-组件" class="headerlink" title="1.创建 header 组件"></a>1.创建 header 组件</h1><h2 id="1-1-选中文件夹，右键新建-Component。-暂命名为-header"><a href="#1-1-选中文件夹，右键新建-Component。-暂命名为-header" class="headerlink" title="1.1 选中文件夹，右键新建 Component。 暂命名为 header"></a>1.1 选中文件夹，右键新建 Component。 暂命名为 header</h2><h2 id="1-2-header-js-文件配置组件属性与方法"><a href="#1-2-header-js-文件配置组件属性与方法" class="headerlink" title="1.2 header.js 文件配置组件属性与方法"></a>1.2 header.js 文件配置组件属性与方法</h2><blockquote>
<p>交互关键方法⚠️ this.triggerEvent(‘subClickEvent’, ‘来自 子组件 的信号这个是 参数’)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;组件的属性列表</span><br><span class="line">  properties: &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 属性名 简化写法</span><br><span class="line">    name: String,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 属性名</span><br><span class="line">    car: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      value: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生命周期函数，可以为函数，或一个在methods段中定义的方法名</span><br><span class="line">  lifetimes: &#123;</span><br><span class="line">    attached: function () &#123; &#125;,</span><br><span class="line">    moved: function () &#123; &#125;,</span><br><span class="line">    detached: function () &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件所在页面的生命周期函数</span><br><span class="line">  pageLifetimes: &#123;</span><br><span class="line">    show: function () &#123; &#125;,</span><br><span class="line">    hide: function () &#123; &#125;,</span><br><span class="line">    resize: function () &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件的初始数据</span><br><span class="line">  data: &#123;</span><br><span class="line">    color: &#39;彩色&#39;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件的方法列表</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    logP() &#123;</span><br><span class="line">      console.log(&#39;pppppp&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组件内部先调用该方法 再调用父方法</span><br><span class="line">    cllParentClick() &#123;</span><br><span class="line">      &#x2F;&#x2F;  触发 subClickEvent 事件， 间接通知在 父组件中 subClickEvent 绑定的 subClick 方法</span><br><span class="line">      &#x2F;&#x2F;  建议  subClickEvent 与  subClick 命名相同，这个刚接触感觉会有一点混乱</span><br><span class="line">      &#x2F;&#x2F; subClickEvent 就是通知名。subClickEvent 这个通知在使用该组件时绑定的，绑定了父组件的 subClick 方法。然后在这里触发了 subClickEvent 通知</span><br><span class="line">      this.triggerEvent(&#39;subClickEvent&#39;, &#39;来自 子组件 的信号这个是 参数&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    btnClick(e) &#123;</span><br><span class="line">      console.log(&#39;开车开车&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 私有方法 下划线开头</span><br><span class="line">    _saySelfName() &#123;</span><br><span class="line">      console.log(&#39;header&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-header-wxml"><a href="#1-3-header-wxml" class="headerlink" title="1.3 header.wxml"></a>1.3 header.wxml</h2><p>header 组件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">  &lt;text&gt;name:&#123;&#123;name&#125;&#125;  car:&#123;&#123;car&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;button size&#x3D;&quot;default&quot; type&#x3D;&quot;primary&quot; bind:tap&#x3D;&quot;btnClick&quot;&gt;开车开车&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;button size&#x3D;&quot;default&quot; type&#x3D;&quot;primary&quot; bind:tap&#x3D;&quot;cllParentClick&quot;&gt;调用父组件 subClick 方法&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>
<p>header.wxss</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-使用-header-组件"><a href="#2-使用-header-组件" class="headerlink" title="2. 使用 header 组件"></a>2. 使用 header 组件</h1><h2 id="2-1-page-json"><a href="#2-1-page-json" class="headerlink" title="2.1 page.json"></a>2.1 page.json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;header&quot;: &quot;..&#x2F;..&#x2F;..&#x2F;components&#x2F;header&#x2F;header&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-page-wxml"><a href="#2-2-page-wxml" class="headerlink" title="2.2 page.wxml"></a>2.2 page.wxml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;header id&#x3D;&#39;comHeader&#39; name&#x3D;&#39;朱小明&#39; car&#x3D;&#39;自行车&#39; bind:subClickEvent&#x3D;&#39;subClick&#39;&gt;&lt;&#x2F;header&gt;</span><br><span class="line">&lt;button bind:tap&#x3D;&quot;getHeaderInfo&quot;&gt;获取组件属性&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里注册的 subClickEvent 事件，当 header 组件触发 subClickEvent 时，调用 page 的  subClick 方法。 建议将 subClickEvent 与 subClick 命名相同</p>
</blockquote>
<h2 id="2-3-page-js"><a href="#2-3-page-js" class="headerlink" title="2.3 page.js"></a>2.3 page.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; header 组件间接调用该方法</span><br><span class="line">  subClick(e) &#123;</span><br><span class="line">    console.log(e.detail);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 主动获取 header 组件实例对象</span><br><span class="line">  getHeaderInfo() &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取组件实例对象  记得加 # </span><br><span class="line">    let header &#x3D; this.selectComponent(&#39;#comHeader&#39;);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取属性</span><br><span class="line">    console.log(header.properties.color);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 调用方法</span><br><span class="line">    header.logP();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>shell 配置</title>
    <url>/2021/08/11/700-shell/</url>
    <content><![CDATA[<h1 id="安装-iterm2"><a href="#安装-iterm2" class="headerlink" title="安装 iterm2"></a>安装 iterm2</h1><p><strong><a class="link"   href="https://iterm2.com/" >前往官网 https://iterm2.com<i class="fas fa-external-link-alt"></i></a></strong></p>
<h1 id="安装-ohmyzsh"><a href="#安装-ohmyzsh" class="headerlink" title="安装 ohmyzsh"></a>安装 ohmyzsh</h1><p><strong><a class="link"   href="https://github.com/ohmyzsh/ohmyzsh" >ohmyzsh 介绍<i class="fas fa-external-link-alt"></i></a></strong></p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a class="link"   href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" >主题预览列表<i class="fas fa-external-link-alt"></i></a></p>
<ol>
<li>打开 zshrc，推荐 VSCode 可格式化<br><code>open ~/.zshrc</code></li>
<li>添加主题<br><code>ZSH_THEME=&quot;robbyrussell&quot;</code></li>
<li>保存<br><code>source ~/.zshrc</code></li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="高亮插件"><a href="#高亮插件" class="headerlink" title="高亮插件"></a>高亮插件</h3><ol>
<li><p>下载<br><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></p>
</li>
<li><p>打开 zshrc，推荐 VSCode 可格式化<br><code>open ~/.zshrc</code></p>
</li>
<li><p>添加插件描述</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(</span><br><span class="line">#高亮</span><br><span class="line">zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure></li>
<li><p>保存<br> <code>source ~/.zshrc</code></p>
</li>
</ol>
<h3 id="输入建议插件"><a href="#输入建议插件" class="headerlink" title="输入建议插件"></a>输入建议插件</h3><ol>
<li><p>下载<br><code>git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></p>
</li>
<li><p>打开 zshrc，推荐 VSCode 可格式化<br><code>open ~/.zshrc</code></p>
</li>
<li><p>添加插件描述</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(</span><br><span class="line">#高亮</span><br><span class="line">zsh-syntax-highlighting</span><br><span class="line">#输入建议</span><br><span class="line">zsh-autosuggeestions)</span><br></pre></td></tr></table></figure></li>
<li><p>保存<br> <code>source ~/.zshrc</code></p>
</li>
</ol>
<h1 id="zshrc-样例"><a href="#zshrc-样例" class="headerlink" title=".zshrc 样例"></a>.zshrc 样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Path to your oh-my-zsh installation.</span><br><span class="line">export ZSH&#x3D;&quot;&#x2F;Users&#x2F;z&#x2F;.oh-my-zsh&quot;</span><br><span class="line"></span><br><span class="line"># See https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;Themes</span><br><span class="line">ZSH_THEME&#x3D;&quot;robbyrussell&quot;</span><br><span class="line"></span><br><span class="line">plugins&#x3D;(git</span><br><span class="line">    #自动建议</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    #高亮</span><br><span class="line">    zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line">source $ZSH&#x2F;oh-my-zsh.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>从输入 URL 到展现页面的全过程</title>
    <url>/2021/02/03/1000-000%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E5%B1%95%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从输入-URL-到展现页面的全过程"><a href="#从输入-URL-到展现页面的全过程" class="headerlink" title="从输入 URL 到展现页面的全过程"></a>从输入 URL 到展现页面的全过程</h1><blockquote>
<p>8 个过程</p>
</blockquote>
<ul>
<li>URL 输入</li>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求</li>
<li>服务器相应请求</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<h2 id="1-URL-输入"><a href="#1-URL-输入" class="headerlink" title="1. URL 输入"></a>1. URL 输入</h2><blockquote>
<p>URL中文名叫做统一资源定位符，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
</blockquote>
<p><strong>主要组成部分：protocol :// hostname[:port] / path / [;parameters][?query]#fragment</strong></p>
<ul>
<li>protocol 协议</li>
<li>hostname 主机名</li>
<li>port 端口号</li>
<li>path 路径</li>
<li>parameters 参数</li>
<li>query 查询</li>
<li>fragment 信息片段<blockquote>
<p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>
</blockquote>
<h2 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h2><blockquote>
<p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如<a class="link"   href="http://www.baidu.com,其实不是百度网站真正意义上的地址.互联网上每一台计算机的唯一标识是它的ip地址,但是ip地址并不方便记忆.用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机,也就是上面提到的百度的网址.所以互联网设计者需要在用户的方便性与可用性方面做一个权衡,这个权衡就是一个网址到ip地址的转换,这个过程就是dns解析.它实际上充当了一个翻译的角色,实现了网址到ip地址的转换.网址到ip地址转换的过程是如何进行的/" >www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的<i class="fas fa-external-link-alt"></i></a>?</p>
</blockquote>
</li>
</ul>
<p><strong>查找顺序： 浏览器缓存–&gt; 操作系统缓存–&gt; 本地host文件 –&gt; 路由器缓存–&gt; ISP DNS缓存 –&gt; 顶级DNS服务器/根DNS服务器</strong></p>
<p><strong>1. 浏览器缓存：</strong> 首先会向浏览器的缓存中读取上一次访问的记录，在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看缓存的当前状态 。</p>
<p><strong>2. 操作系统缓存：</strong>  查找存储在系统运行内存中的缓存。在mac中可以通过下面的命令清除系统中的DNS缓存。<br><code>dscacheutil -flushcache</code></p>
<p><strong>3. 本地 host 文件：</strong> 查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
<p><strong>4. 路由器缓存：</strong> 有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。</p>
<p><strong>5. ISP DNS 缓存：</strong> 互联网服务提供商（如中国电信）也会提供DNS服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向根域名服务器请求查询。</p>
<p><strong>6. 顶级 DNS 服务器 / 根 DNS 服务器：</strong> 根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的DNS服务器IP（baidu.com），本机继续查找，直到服务器找到(<a class="link"   href="http://www.baidu.com)的主机./" >www.baidu.com)的主机。<i class="fas fa-external-link-alt"></i></a><br>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/t5awpd.png"
                      alt="过程图"
                ></p>
<p>上述图片是查找 <a class="link"   href="http://www.google.com/" >www.google.com<i class="fas fa-external-link-alt"></i></a> 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为</a>: . -&gt; .com -&gt; google.com. -&gt; <a class="link"   href="http://www.google.com../" >www.google.com.。<i class="fas fa-external-link-alt"></i></a></p>
<p>补充：</p>
<ol>
<li><p>什么是 DNS ？<br>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<br>  通俗的讲，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p>
</li>
<li><p>DNS 查询的两种方式：递归查询和迭代查询</p>
<p> 2.1 递归解析<br> 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/4vqiqy.png"
                      alt="DNS 递归解析查询"
                ></p>
<p> 2.2 迭代解析<br> 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/rnsyzp.png"
                      alt="DNS 迭代解析查询"
                ></p>
</li>
<li><p>DNS 域名称空间的组织方式<br>我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>名称类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>根域</td>
<td>DNS 域名中使用时，规模由尾部句点(.) 来指定名称位于根或更高级别的域层次结构</td>
<td>单个句点(.)或句点用于末尾的名称</td>
</tr>
<tr>
<td>顶级域</td>
<td>用来指示某个国家/地区或组织的名称</td>
<td>.com</td>
</tr>
<tr>
<td>第二层域</td>
<td>个人或组织在 Internet 上使用的注册名称</td>
<td>qq.com</td>
</tr>
<tr>
<td>子域</td>
<td>已注册的二级域名派生的域名，通俗的讲就是网站名</td>
<td><a class="link"   href="http://www.qq.com/" >www.qq.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>主机名</td>
<td>通常情况下，DNS 域名的最左侧的标签标示网络上的特定计算机 如 h1</td>
<td>h1.<a class="link"   href="http://www.qq.com/" >www.qq.com<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<ol start="4">
<li><p>DNS 优化<br>了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。</p>
<p> 4.1 DNS 缓存<br> DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。<br> 4.2 DNS 负载均衡<br> 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
</li>
</ol>
<h2 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/bnd17b.png"
                      alt="TCP 连接图"
                ></p>
<p>三次握手以建立 TCP 连接<br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p><strong>为什需要三次握手？</strong><br>《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>
<h2 id="4-发送HTTP请求"><a href="#4-发送HTTP请求" class="headerlink" title="4. 发送HTTP请求"></a>4. 发送HTTP请求</h2><p>建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。   </p>
<p>客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>
<ul>
<li>请求方法URI协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<h2 id="5-服务器永久重定向"><a href="#5-服务器永久重定向" class="headerlink" title="5.服务器永久重定向"></a>5.服务器永久重定向</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<a class="link"   href="http://www.google.com/" >http://www.google.com/<i class="fas fa-external-link-alt"></i></a> 而非<a class="link"   href="http://google.com/%E3%80%82" >http://google.com/。<i class="fas fa-external-link-alt"></i></a>   <br>​    为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a class="link"   href="http://www.yy.com/%E5%92%8Chttp://yy.com/%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%9A%E8%AE%A4%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%80%A0%E6%88%90%E6%AF%8F%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%93%BE%E6%8E%A5%E9%83%BD%E5%87%8F%E5%B0%91%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%8E%92%E5%90%8D%E3%80%82%E8%80%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9F%A5%E9%81%93301%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E6%8A%8A%E8%AE%BF%E9%97%AE%E5%B8%A6www%E7%9A%84%E5%92%8C%E4%B8%8D%E5%B8%A6www%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%92%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8E%92%E5%90%8D%E4%B8%8B%E3%80%82%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E6%80%A7%E5%8F%98%E5%B7%AE%EF%BC%8C%E5%BD%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%90%8D%E5%AD%97%E6%97%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E9%87%8C%E5%87%BA%E7%8E%B0%E5%A5%BD%E5%87%A0%E6%AC%A1%E3%80%82" >http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>补充</li>
</ul>
<ol>
<li>301和302的区别：</li>
</ol>
<p>301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。<br>  他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；<br>  302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</p>
<ol start="2">
<li><p>重定向原因：<br>(1)网站调整（如改变网页目录结构）；<br>(2)网页被移到一个新地址；<br>(3)网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>
</li>
<li><p>什么时候进行301或者302跳转呢？<br>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下：</p>
</li>
</ol>
<ul>
<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
<li>空间服务器不稳定，换空间的时候。</li>
</ul>
<h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？   </p>
<p>后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。   <br>一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/pn6p43.png"
                      alt="示例图"
                ></p>
<ul>
<li>补充：</li>
</ul>
<ol>
<li>什么是反向代理？<br>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/ysfjxn.png"
                      alt="示例图"
                ></li>
</ol>
<h2 id="7-服务器返回一个-HTTP-响应"><a href="#7-服务器返回一个-HTTP-响应" class="headerlink" title="7. 服务器返回一个 HTTP 响应"></a>7. 服务器返回一个 HTTP 响应</h2><p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。 HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>空行</li>
<li>响应正文</li>
</ul>
<p><strong>状态行：</strong><br>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。<br>格式: HTTP-Version Status-Code Reason-Phrase CRLF<br>例如: HTTP/1.1 200 OK \r\n<br>| -协议版本：是用http1.0还是其他版本<br>| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok<br>| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<p>==1xx：== 信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p>
<ul>
<li>100 Continue</li>
<li>101 Switching Protocols</li>
</ul>
<p>==2xx：== 成功状态码，表示服务器已成功接收到请求并进行处理。</p>
<ul>
<li>200 OK 表示客户端请求成功</li>
<li>204 No Content 成功，但不返回任何实体的主体部分</li>
<li>206 Partial Content 成功执行了一个范围（Range）请求</li>
</ul>
<p>==3xx：== 重定向状态码，表示服务器要求客户端重定向。</p>
<ul>
<li>301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</li>
<li>302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</li>
<li>303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</li>
<li>307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</li>
</ul>
<p>==4xx：== 客户端错误状态码，表示客户端的请求有非法内容。</p>
<ul>
<li>400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li>
</ul>
<p>==5xx：== 服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p>
<ul>
<li>500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li>503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>
</ul>
<p><strong>响应头：</strong><br>响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/m1chic.png"
                      alt="响应头"
                ></p>
<p><strong>响应正文：</strong><br>包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/0qw5o5.png"
                      alt="响应正文"
                ></p>
<h2 id="8-浏览器显示-html"><a href="#8-浏览器显示-html" class="headerlink" title="8. 浏览器显示 html"></a>8. 浏览器显示 html</h2><blockquote>
<p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p>
</blockquote>
<p><strong>构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</strong><br>渲染过程：</p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br>​    当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。<br>​    JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。<br>​    JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/we6f9l.png"
                      alt="渲染过程"
                ></p>
<h2 id="9-连接结束"><a href="#9-连接结束" class="headerlink" title="9. 连接结束"></a>9. 连接结束</h2><p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭，过程如下。<br>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：<br>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。<br>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。<br>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。<br>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p>
<p><strong>补充：</strong><br><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<blockquote>
<p>摘录于 <a class="link"   href="https://juejin.cn/post/6844903616101220366" >https://juejin.cn/post/6844903616101220366<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>DNS</tag>
        <tag>HTTP 请求</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime 相关知识</title>
    <url>/2021/03/08/6666-001-runtime/</url>
    <content><![CDATA[<h1 id="1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"><a href="#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）" class="headerlink" title="1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"></a>1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</h1><ul>
<li><strong>对象(实例)</strong><br>OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object *id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。</li>
<li><strong>类(Class)</strong><ol>
<li>在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class *Class.</li>
<li>OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;</li>
<li>当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。</li>
</ol>
</li>
<li><strong>OC 对象、类、元类之间的关系</strong><br>对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/kj1q75.png"
                      alt="OC 对象、类、元类之间的关系"
                ></li>
</ul>
<h1 id="2-为什么要设计-metaclass"><a href="#2-为什么要设计-metaclass" class="headerlink" title="2.为什么要设计 metaclass?"></a>2.为什么要设计 metaclass?</h1><ul>
<li>类对象、元类对象能够复用消息发送流程机制；</li>
<li>单一职责原则<br>metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。</li>
</ul>
<h1 id="3-class-copyIvarList-amp-class-copyPropertyList-区别"><a href="#3-class-copyIvarList-amp-class-copyPropertyList-区别" class="headerlink" title="3.class_copyIvarList &amp; class_copyPropertyList 区别"></a>3.class_copyIvarList &amp; class_copyPropertyList 区别</h1><ul>
<li><strong>class_copyIvarList</strong><br>会返回所有的成员变量，包括属性生成的成员变量。<br>获取类对象中的所有实例变量信息，从 class_ro_t 中获取。</li>
<li><strong>class_copyPropertyList</strong><br>获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_ddd;</span><br><span class="line">    NSString *_ccc;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *abc1;</span><br><span class="line">@property (nonatomic, copy) NSString *abc2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyIvarList</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar * ivars &#x3D; class_copyIvarList(self.class, &amp;count);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">      const char *name &#x3D; ivar_getName(ivars[i]);</span><br><span class="line">      NSLog(@&quot;name &#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:name]);</span><br><span class="line">  &#125;</span><br><span class="line">free(ivars);</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ddd</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ccc</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc1</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyPropertyList</span><br><span class="line">unsigned int outCount &#x3D; 0;</span><br><span class="line">objc_property_t *prs &#x3D; class_copyPropertyList(self.class, &amp;outCount);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; outCount; i++) &#123;</span><br><span class="line">    const char *pname &#x3D;  property_getName(prs[i]);</span><br><span class="line">    NSLog(@&quot;pname &#x3D;&#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:pname]);</span><br><span class="line">&#125;</span><br><span class="line">free(prs);</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc1</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc2</span><br></pre></td></tr></table></figure>

<h1 id="4-class-rw-t-和-class-ro-t-的区别"><a href="#4-class-rw-t-和-class-ro-t-的区别" class="headerlink" title="4.class_rw_t 和 class_ro_t 的区别"></a>4.class_rw_t 和 class_ro_t 的区别</h1><ul>
<li><p>class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only</p>
</li>
<li><p>class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write</p>
</li>
</ul>
<h1 id="5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序"><a href="#5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序" class="headerlink" title="5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序"></a>5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序</h1><p>+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看<br>分类添加到了 rw = cls-&gt;data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。同名方法调用后编译的。</p>
<h1 id="6-initialize-amp-amp-Load"><a href="#6-initialize-amp-amp-Load" class="headerlink" title="6.initialize &amp;&amp; Load"></a>6.initialize &amp;&amp; Load</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot; load &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D;&#x3D; [self class]) &#123;</span><br><span class="line">        NSLog(@&quot; initialize &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，<strong>如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。</strong>。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。</p>
<p>不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。<br>调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。</p>
<h1 id="7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何"><a href="#7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何" class="headerlink" title="7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何"></a>7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何</h1><ul>
<li>category 可以给类添加方法和属性(需要借助 runtime<br><code>objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</code><br>及<code>objc_getAssociatedObject(self, &amp;redXXKey);</code>)</li>
<li>extension 可以给类添加成员变量和方法，但是是私有的在 .m 内(只有在.m 里才是私有的)。</li>
<li>不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m</li>
</ul>
<h1 id="8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么"><a href="#8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么" class="headerlink" title="8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么"></a>8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</h1><p>OC 中的方法调用，编译后的代码最终都会转成 <code>objc_msgSend(id , SEL, ...)</code> 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用<code>_objc_msgForward(id, SEL, ...)</code>进行消息转发。</p>
<h1 id="9-IMP、SEL、Method-的区别和使用场景"><a href="#9-IMP、SEL、Method-的区别和使用场景" class="headerlink" title="9.IMP、SEL、Method 的区别和使用场景"></a>9.IMP、SEL、Method 的区别和使用场景</h1><ul>
<li><p>IMP:IMP 定义为 <code>id (*IMP) (id, SEL, …)</code>。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。</p>
</li>
<li><p>SEL:是“selector”的一个类型，表示一个方法的名字</p>
</li>
<li><p>Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关</p>
</li>
</ul>
<h1 id="10-load、initialize-方法的区别什么？在继承关系中他们有什么区别"><a href="#10-load、initialize-方法的区别什么？在继承关系中他们有什么区别" class="headerlink" title="10.load、initialize 方法的区别什么？在继承关系中他们有什么区别"></a>10.load、initialize 方法的区别什么？在继承关系中他们有什么区别</h1><p>load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。</p>
<p>继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。</p>
<h1 id="11-说说消息转发机制的优劣"><a href="#11-说说消息转发机制的优劣" class="headerlink" title="11.说说消息转发机制的优劣"></a>11.说说消息转发机制的优劣</h1><ul>
<li>优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。</li>
<li>劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。</li>
</ul>
<h2 id="消息转发三部曲"><a href="#消息转发三部曲" class="headerlink" title="消息转发三部曲"></a>消息转发三部曲</h2><p><strong>1. 第一步动态添加一个实现方法。</strong> 如果是实例对象会调用这个实例所属的类方法<br><code>resolveInstanceMethod</code>，如果是类方法会调用<code>+ (BOOL)resolveClassMethod:(SEL)sel;</code></p>
<p>我们可以动态的给该对象添加该方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F;v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        class_addMethod(self, sel, (IMP)aaa, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C 方法</span><br><span class="line">void aaa (id self,SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;添加了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 消息转发，可以将消息转发给实现了该方法的对象。</strong> 系统会调用下面的这个方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个实现了该方法的对象</span><br><span class="line">        return [SubViewController new];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 完整的消息转发</strong><br>先调用 <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code><br>获取一个方法签名，如果没有返回一个有效的签名则直接调用<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector;</code>抛出异常。<br>如果获取到则将签名包装成<code>NSInvocation</code><br>传给<code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code><br>进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个方法签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果返回了有效的签名将调用这个方法进行转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取方法</span><br><span class="line">    SEL selector &#x3D; [anInvocation selector];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象</span><br><span class="line">    &#x2F;&#x2F; 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃</span><br><span class="line"></span><br><span class="line">    SubViewController *subVC &#x3D; [SubViewController new];</span><br><span class="line">    if ([subVC respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:subVC];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ABC *abc &#x3D; [ABC new];</span><br><span class="line">    if ([abc respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:abc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-weak-的实现原理？SideTable-的结构是什么样的"><a href="#12-weak-的实现原理？SideTable-的结构是什么样的" class="headerlink" title="12.weak 的实现原理？SideTable 的结构是什么样的"></a>12.weak 的实现原理？SideTable 的结构是什么样的</h1><p>runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，<br>value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.<br>runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数<br>weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.</p>
<p>SideTable 结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">     spinlock_t slock;&#x2F;&#x2F;操作SideTable时用到的自旋锁</span><br><span class="line">     RefcountMap refcnts;&#x2F;&#x2F;引用计数器的 map</span><br><span class="line">     weak_table_t weak_table;&#x2F;&#x2F;存放weak指针的哈希表</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="13-关联对象的应用？系统如何实现关联对象的"><a href="#13-关联对象的应用？系统如何实现关联对象的" class="headerlink" title="13.关联对象的应用？系统如何实现关联对象的"></a>13.关联对象的应用？系统如何实现关联对象的</h1><ul>
<li>应用：给 category 添加属性。</li>
<li>如何实现关联的？<br>首先系统中有一个全局 AssociationsManager,里面有个 AssociationsHashMap 哈希表，哈希表中的 key 是对象的内存地址，value 是 ObjectAssociationMap,也是一个哈希表。<br>ObjectAssociationMap 中的 key 是我们设置关联对象时所设置的唯一 key，value 是 ObjcAssociation,里面存放着关联对象设置的值和内存管理的策略。<br>以<code>void objc_setAssociatedObject(id object, const void * key,id value, objc_AssociationPolicy policy)</code>为例，<br>首先会通过 AssociationsManager 获取 AssociationsHashMap，然后以 object 的内存地址为 key，从 AssociationsHashMap 中取出 ObjectAssociationMap，若没有，则新创建一个 ObjectAssociationMap，<br>然后通过 key 获取旧值，以及通过 key 和 policy 生成新值 ObjcAssociation(policy, new_value)，把新值存放到 ObjectAssociationMap 中，<br>若新值不为 nil，并且内存管理策略为 retain，则会对新值进行一次 retain，若新值为 nil，则会删除旧值，若旧值不为空并且内存管理的策略是 retain，则对旧值进行一次 release.</li>
<li>其被释放的时候需要手动将所有的关联对象的指针置空么？<br>对这个问题我的理解是：当对象被释放时，需要手动移除该对象所设置的关联对象吗？ 不需要，因为在对象的 dealloc 中，若发现对象有关联对象时，会调用<code>_object_remove_assocations</code> 方法来移除所有的关联对象，并根据内存策略，来判断是否需要对关联对象的值进行 release</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface UIView (XX)</span><br><span class="line">@property (nonatomic, copy) NSString *redXX;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIView (XX)</span><br><span class="line">static char redXXKey;</span><br><span class="line">- (void)setRedXX:(NSString *)redXX &#123;</span><br><span class="line">    &#x2F;&#x2F; 被关联的对象、关联的key唯一、关联的对象、内存管理策略</span><br><span class="line">    objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)redXX &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;redXXKey);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h1 id="14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性"><a href="#14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性" class="headerlink" title="14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性"></a>14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性</h1><p>在关联对象时又一个参数<code>objc_AssociationPolicy policy</code>设置内存管理策略<br>OBJC_ASSOCIATION_ASSIGN 类型的关联对象和 weak 有一定差别，而更加接近于 unsafe_unretained，<br>即当目标对象遭到摧毁时，属性值不会自动清空。<br>然后内部封装一个 weak 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil 操作。</p>
<h1 id="15-Autoreleasepool-的原理？所使用的的数据结构是什么"><a href="#15-Autoreleasepool-的原理？所使用的的数据结构是什么" class="headerlink" title="15.Autoreleasepool 的原理？所使用的的数据结构是什么"></a>15.Autoreleasepool 的原理？所使用的的数据结构是什么</h1><ul>
<li>Autoreleasepool 是由多个 AutoreleasePoolPage 以双向链表的形式连接起来的。</li>
<li>释放时机: 当前 RunLoop 迭代结束时候释放。</li>
<li>Autoreleasepool 的基本原理：在每个自动释放池创建的时候，会在当前的 AutoreleasePoolPage 中设置一个标记位，在此期间，当有对象调用 autorelsease 时，会把对象添加到 AutoreleasePoolPage 中，若当前页添加满了，会初始化一个新页，然后用双向量表链接起来，并把新初始化的这一页设置为 hotPage,当自动释放池 pop 时，从最下面依次往上 pop，调用每个对象的 release 方法，直到遇到标志位。</li>
<li>AutoreleasePoolPage 结构如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">     magic_t const magic;</span><br><span class="line">     id *next;&#x2F;&#x2F;下一个存放autorelease对象的地址</span><br><span class="line">     pthread_t const thread; &#x2F;&#x2F;AutoreleasePoolPage 所在的线程</span><br><span class="line">     AutoreleasePoolPage * const parent;&#x2F;&#x2F;父节点</span><br><span class="line">     AutoreleasePoolPage *child;&#x2F;&#x2F;子节点</span><br><span class="line">     uint32_t const depth;&#x2F;&#x2F;深度,也可以理解为当前page在链表中的位置</span><br><span class="line">     uint32_t hiwat;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化"><a href="#16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化" class="headerlink" title="16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化"></a>16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化</h1><ul>
<li>Automatic Reference Counting，自动引用计数，即 ARC,ARC 会自动帮你插入 retain 和 release 语句,<br>ARC 编译器有两部分，分别是前端编译器和优化器</li>
<li>前端编译器:前端编译器会为“拥有的”每一个对象插入相应的 release 语句。如果对象的所有权修饰符是<code>__strong</code>，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入 release 语句以销毁它。而类拥有的对象（实例变量/属性）会在 dealloc 方法内被释放。事实上，你并不需要写 dealloc 方法或调用父类的 dealloc 方法，ARC 会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的 release 语句的性能还要好，因为编辑器可以作出一些假设。在 ARC 中，没有类可以覆盖 release 方法，也没有调用它的必要。ARC 会通过直接使用 objc_release 来优化调用过程。而对于 retain 也是同样的方法。ARC 会调用 objc_retain 来取代保留消息</li>
<li>ARC 优化器: 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对 retain 和 release 的重复调用。ARC 优化器负责移除多余的 retain 和 release 语句，确保生成的代码运行速度高于手动引用计数的代码</li>
</ul>
<h1 id="17-ARC-下哪些情况会造成内存泄漏"><a href="#17-ARC-下哪些情况会造成内存泄漏" class="headerlink" title="17.ARC 下哪些情况会造成内存泄漏"></a>17.ARC 下哪些情况会造成内存泄漏</h1><ul>
<li>循环引用</li>
<li>注册通知，不移除</li>
</ul>
<h1 id="18-Method-Swizzle-注意事项"><a href="#18-Method-Swizzle-注意事项" class="headerlink" title="18. Method Swizzle 注意事项"></a>18. Method Swizzle 注意事项</h1><p>如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议先添加：class_addMethod</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AFNetworking 源码涉及代码</span><br><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod &#x3D; class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod &#x3D; class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-iOS-中内省的几个方法有哪些？内部实现原理是什么"><a href="#19-iOS-中内省的几个方法有哪些？内部实现原理是什么" class="headerlink" title="19. iOS 中内省的几个方法有哪些？内部实现原理是什么"></a>19. iOS 中内省的几个方法有哪些？内部实现原理是什么</h1><p>对象在运行时获取其类型的能力称为内省</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例</span><br><span class="line">-(BOOL) isMemberOfClass:      判断是否是这个类的实例</span><br><span class="line">-(BOOL) respondsToSelector:            判读实例是否实现了该方法</span><br><span class="line">+(BOOL) instancesRespondToSelector:    判断类的实例是否实现了这个方法</span><br></pre></td></tr></table></figure>

<h1 id="20-属性修饰符-atomic-的内部实现是怎么样的-能保证线程安全吗"><a href="#20-属性修饰符-atomic-的内部实现是怎么样的-能保证线程安全吗" class="headerlink" title="20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗"></a>20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗</h1><ul>
<li><p>实现机制：atomic 是 property 的修饰词之一，表示是原子性的，使用方式为@property(atomic)int age;,此时编译器会自动生成 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法来进行存取属性。若此时属性用 atomic 修饰的话，在这两个方法内部使用 os_unfair_lock 来进行加锁，来保证读写的原子性。锁都在 PropertyLocks 中保存着（在 iOS 平台会初始化 8 个，mac 平台 64 个），在用之前，会把锁都初始化好，在需要用到时，用对象的地址加上成员变量的偏移量为 key，去 PropertyLocks 中去取。因此存取时用的是同一个锁，所以 atomic 能保证属性的存取时是线程安全的。注：由于锁是有限的，不用对象，不同属性的读取用的也可能是同一个锁</p>
</li>
<li><p>不能保证：atomic 在 getter/setter 方法中加锁，仅保证了存取时的线程安全，假设我们的属性是 @property(atomic)NSMutableArray *array;可变的容器时,无法保证对容器的修改是线程安全的</p>
</li>
<li><p>在编译器自动生产的 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法存取属性，在此方法内部保证了读写时的线程安全的，当我们重写 getter/setter 方法时，就只能依靠自己在 getter/setter 中保证线程安全</p>
</li>
<li><p>os_unfair_lock(互斥锁) 锁，iOS 10 之前使用 OSSpinLock(自旋锁)不能完全保证。</p>
</li>
<li><p>OSSpinLock 忙等 是会一直循环等待，循环等待的时候会消耗 cpu 的性能</p>
</li>
<li><p>os_unfair_lock 线程休眠，cpu 线程调度的时候会消耗 cpu 性能</p>
</li>
</ul>
<h1 id="21-class、objc-getClass、object-getclass-方法有什么区别"><a href="#21-class、objc-getClass、object-getclass-方法有什么区别" class="headerlink" title="21. class、objc_getClass、object_getclass 方法有什么区别?"></a>21. class、objc_getClass、object_getclass 方法有什么区别?</h1><ul>
<li>object_getClass:获得的是 isa 的指向</li>
<li>self.class:当 self 是实例对象的时候，返回的是类对象，否则则返回自身。</li>
<li>类方法 class，返回的是 self，所以当查找 meta class 时，需要对类对象调用 object_getClass 方法</li>
</ul>
<h1 id="22-NSNotification"><a href="#22-NSNotification" class="headerlink" title="22.NSNotification"></a>22.NSNotification</h1><h2 id="1-通知的发送时同步的，还是异步的"><a href="#1-通知的发送时同步的，还是异步的" class="headerlink" title="1. 通知的发送时同步的，还是异步的"></a>1. 通知的发送时同步的，还是异步的</h2><p>同步发送，所有接受者处理完后，才会走发送后下边的代码。</p>
<h2 id="2-NSNotificationCenter-接受消息和发送消息是在一个线程里吗？如何异步发送消息"><a href="#2-NSNotificationCenter-接受消息和发送消息是在一个线程里吗？如何异步发送消息" class="headerlink" title="2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息"></a>2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息</h2><p>NSNotificationQueue</p>
<h2 id="3-NSNotificationQueue-是异步还是同步发送？在哪个线程响应"><a href="#3-NSNotificationQueue-是异步还是同步发送？在哪个线程响应" class="headerlink" title="3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应"></a>3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应</h2><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用 NSNotificationCenter 的发送接口进行发送通知，这么看 NSNotificationQueue 最终还是调用 NSNotificationCenter 进行消息的分发。</p>
<ul>
<li>依赖 runloop，所以如果在其他子线程使用 NSNotificationQueue，需要开启 runloop</li>
<li>最终还是通过 NSNotificationCenter 进行发送通知，所以这个角度讲它还是同步的</li>
<li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程</li>
</ul>
<h2 id="4-如何保证通知接收的线程在主线程"><a href="#4-如何保证通知接收的线程在主线程" class="headerlink" title="4.如何保证通知接收的线程在主线程"></a>4.如何保证通知接收的线程在主线程</h2><p>使用 addObserverForName: object: queue: usingBlock 方法注册通知，指定在 mainqueue 上响应 block</p>
<h2 id="5-下面的方式能接收到通知吗？为什么"><a href="#5-下面的方式能接收到通知吗？为什么" class="headerlink" title="5.下面的方式能接收到通知吗？为什么"></a>5.下面的方式能接收到通知吗？为什么</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">&#x2F;&#x2F; 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure>

<p>不会<br>存储是以 name 和 object 为维度的，即判定是不是同一个通知要从 name 和 object 区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的</p>
<h1 id="23-runloop"><a href="#23-runloop" class="headerlink" title="23.runloop"></a>23.runloop</h1><h2 id="1-app-如何接收到触摸事件的"><a href="#1-app-如何接收到触摸事件的" class="headerlink" title="1.app 如何接收到触摸事件的"></a>1.app 如何接收到触摸事件的</h2><h3 id="1-系统响应阶段-SpringBoad-app-是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。"><a href="#1-系统响应阶段-SpringBoad-app-是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。" class="headerlink" title="1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)"></a>1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)</h3><ul>
<li>指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。</li>
<li>IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoad 进程。</li>
<li>SpringBoard 进程因接收到触摸事件，将触摸事件交给前台 app 进程来处理。</li>
</ul>
<h3 id="2-APP-响应阶段"><a href="#2-APP-响应阶段" class="headerlink" title="2.APP 响应阶段"></a>2.APP 响应阶段</h3><ul>
<li>APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。</li>
<li>source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。</li>
<li>source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 hit-testing，另外，此处开始便是与我们平时开发相关的工作了。</li>
<li>寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。</li>
<li>触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</li>
</ul>
<h2 id="2-事件响应者链"><a href="#2-事件响应者链" class="headerlink" title="2.事件响应者链"></a>2.事件响应者链</h2><p>这个传递的过程叫做 hit-Testing</p>
<ul>
<li>事件是自上而下传递的即<br>UIApplication -&gt; UIWindow -&gt; 子试图 -&gt; ..-&gt;子试图中的子试图</li>
<li>后加试图响应程度更高，即最靠近我们的试图。</li>
</ul>
<ol>
<li>首先调用当前视图的 pointInside:withEvent:方法判断触摸点是否在当前视图内</li>
<li>若 pointInside:withEvent:方法返回 NO，说明触摸点不在当前视图内，则当前视图的 hitTest:withEvent:返回 nil</li>
<li>若 pointInside:withEvent:方法返回 YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的 hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从 top 到 bottom，即从 subviews 数组的末尾向前遍历，直到有子视图的 hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕。</li>
<li>若第一次有子视图的 hitTest:withEvent:方法返回非空对象,则当前视图的 hitTest:withEvent:方法就返回此对象，处理结束</li>
<li>若所有子视图的 hitTest:withEvent:方法都返回 nil，则当前视图的 hitTest:withEvent:方法返回当前视图自身(self)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断点击的位置是不是在视图内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;返回点击的视图</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIView _)hitTest:(CGPoint)point withEvent:(UIEvent _)event&#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 前置条件要满足</span><br><span class="line">   if (self.userInteractionEnabled &#x3D;&#x3D; NO ||</span><br><span class="line">  self.hidden &#x3D;&#x3D; YES ||</span><br><span class="line">   self.alpha &lt;&#x3D; 0.01) return nil;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2. 判断点是否在视图内部 这是最起码的 note point 是在当前视图坐标系的点位置</span><br><span class="line">  if ([self pointInside:point withEvent:event] &#x3D;&#x3D; NO) return nil;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3. 现在起码能确定当前视图能够是响应者 接下去询问子视图</span><br><span class="line">  int count &#x3D; (int)self.subviews.count;</span><br><span class="line">  for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">  &#123;</span><br><span class="line">  &#x2F;&#x2F; 子视图</span><br><span class="line">  UIView *childView &#x3D; self.subviews[i];</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 点需要先转换坐标系</span><br><span class="line">   CGPoint childP &#x3D; [self convertPoint:point toView:childView];</span><br><span class="line">   &#x2F;&#x2F; 子视图开始询问</span><br><span class="line">  UIView *fitView &#x3D; [childView hitTest:childP withEvent:event];</span><br><span class="line">  if (fitView)</span><br><span class="line">  &#123;</span><br><span class="line">  return fitView;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   return self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-为什么只有主线程的-runloop-是开启的"><a href="#3-为什么只有主线程的-runloop-是开启的" class="headerlink" title="3.为什么只有主线程的 runloop 是开启的"></a>3.为什么只有主线程的 runloop 是开启的</h2><ul>
<li>主线程需要维持一份 RunLoop，保持 App 在 Main 后不会直接退出。</li>
<li>其他线程默认并没有调用 NSRunLoop *runloop = [NSRunLoop currentRunLoop]</li>
</ul>
<h2 id="4-runloop-的-mode-作用是什么？"><a href="#4-runloop-的-mode-作用是什么？" class="headerlink" title="4.runloop 的 mode 作用是什么？"></a>4.runloop 的 mode 作用是什么？</h2><p>mode 主要是用来指定事件在运行循环中的优先级分为:</p>
<ul>
<li>NSDefaultRunLoopMode：默认，空闲状态</li>
<li>UITrackingRunLoopMode: ScrollView 滑动</li>
<li>UIInitializationRunloopMode: 启动时</li>
<li>NSRunloopCommonModes：Mode 集合</li>
</ul>
<p>苹果公开的有 2 个：<br>NSDefaultRunLoopMode<br>NSRunLoopCommonModes</p>
<p>定时在 scrollview 滑动时通过添加到 NSRunLoopCommonModes<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>
<h2 id="5-为什么只在主线程刷新-UI"><a href="#5-为什么只在主线程刷新-UI" class="headerlink" title="5.为什么只在主线程刷新 UI"></a>5.为什么只在主线程刷新 UI</h2><ul>
<li>UIKit 并不是一个 线程安全 的类，UI 操作涉及到渲染访问各种 View 对象的属性</li>
<li>如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度</li>
<li>另一方面因为整个程序的起点 UIApplication 是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以 view 只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以 60 帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</li>
</ul>
<h2 id="6-PerformSelector-和-runloop-的关系"><a href="#6-PerformSelector-和-runloop-的关系" class="headerlink" title="6.PerformSelector 和 runloop 的关系"></a>6.PerformSelector 和 runloop 的关系</h2><ul>
<li><p>perform 有几种方式，如 [self performSelector:@selector(perform) withObject:nil] 同步执行的，等同于 objc_msgSend 方法执行调用方法。</p>
</li>
<li><p><code>[self performSelector:@selector(perform) withObject:nil afterDelay:0]</code> 则是会在当前 runloop 中起一个 timer，如果当前线程没有起 runloop(也就是上面说的没有调用 <code>[NSRunLoop currentRunLoop]</code> 方法的话)，则不会有输出</p>
</li>
</ul>
<h2 id="7-如何使线程保活"><a href="#7-如何使线程保活" class="headerlink" title="7.如何使线程保活"></a>7.如何使线程保活</h2><p>线程保活就是不让线程退出，所以往简单说就是搞个 “while(1)” 自己实现一套处理流程，事件派发就可以了。<br>runloop 线程保活前提就是有事情要处理，这里指 timer，source0，source1 事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Timer</span><br><span class="line">NSTimer *timer &#x3D; [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">   NSLog(@&quot;timer 定时任务&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">[runloop addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runloop run];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Port</span><br><span class="line">NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runLoop run];</span><br></pre></td></tr></table></figure>

<h2 id="8-runloop-和线程有什么关系？"><a href="#8-runloop-和线程有什么关系？" class="headerlink" title="8.runloop 和线程有什么关系？"></a>8.runloop 和线程有什么关系？</h2><p>runloop 为线程而生，没有线程他就没有存在的必要。<br>runloop 是线程的基础架构部分，runloop 和线程是一一对应关系<br>主线程的 runloop 是默认启动的，其他线程的 runloop 是没有启动的，<br>如果你需要更多的线程交互则可以手动配置和启动。</p>
<h1 id="24-KVO、KVC"><a href="#24-KVO、KVC" class="headerlink" title="24.KVO、KVC"></a>24.KVO、KVC</h1><h2 id="1-KVO-实现原理"><a href="#1-KVO-实现原理" class="headerlink" title="1.KVO 实现原理"></a>1.KVO 实现原理</h2><p>当你观察一个对象时，系统会动态的创建一个以 <code>NSKVONotifying_</code> 为前缀的类。<br>然后将被观察对象的 isa 指针指向这个新创建的类。<br>这个类继承自该对象的原本类，并重写了被观察属性的 setter 方法。<br>同时也会重写 class 方法，返回原先类对象，这样外部就无感知了。</p>
<p>重写所有要观察属性的 setter 方法，统一会走一个方法，<br>内部实现是 willChangeValueForKey 和 didChangevlueForKey 方法，<br>然后就是 observeValueForKey:ofObject:change:context:<br>通知所有观察对象值的更改。</p>
<h2 id="2-如何手动关闭-KVO"><a href="#2-如何手动关闭-KVO" class="headerlink" title="2.如何手动关闭 KVO"></a>2.如何手动关闭 KVO</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;closeType&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setProperty:(NSString *)Property&#123;</span><br><span class="line"></span><br><span class="line">    if (_Property!&#x3D;Property) &#123;</span><br><span class="line"></span><br><span class="line">        [self willChangeValueForKey:@&quot;Property&quot;];</span><br><span class="line">        _Property&#x3D;Property;</span><br><span class="line">        [self didChangeValueForKey:@&quot;Property&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-通过-KVC-修改属性会触发-KVO-么"><a href="#3-通过-KVC-修改属性会触发-KVO-么" class="headerlink" title="3.通过 KVC 修改属性会触发 KVO 么"></a>3.通过 KVC 修改属性会触发 KVO 么</h2><p>会触发 KVO 操作，KVC 时候会先查询对应的 getter 和 setter 方法。</p>
<h2 id="4-KVC"><a href="#4-KVC" class="headerlink" title="4.KVC"></a>4.KVC</h2><p>KVC（key-value-codeing）键值编码 是通过一种字符串间接访问对象的方式（即给属性赋值）</p>
<ul>
<li><p>KVC 调用 getter 流程：getKEY，KEY，isKEY, _KEY，接着是实例变量 _KEY,_isKEY, KEY, isKEY;</p>
</li>
<li><p>KVC 调用 setter 流程：setKEY 和 _setKEY，实例变量顺序 _KEY,_isKEY, KEY, isKEY，没找到就调用 setValue: forUndefinedKey: 当一个对象调用 setValue 方法时，方法内部会做以下操作</p>
</li>
</ul>
<ol>
<li>检查是否存在相应的 key 的 set 方法，存在就调用 set 方法</li>
<li>如果 set 方法不存在就找带下划线的成员变量，如果有就直接给成员变量属性赋值。</li>
<li>如果没有找到_key 就会找相同属性名的 key，有就直接赋值</li>
<li>如果还没找到，就调用 valueForUndefinedKey:和 setValue:forUndefinedKey:方法。这些方法就抛出异常崩溃了。</li>
</ol>
<h2 id="5-哪些情况下使用-kvo-会崩溃，怎么防护崩溃"><a href="#5-哪些情况下使用-kvo-会崩溃，怎么防护崩溃" class="headerlink" title="5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃"></a>5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃</h2><ol>
<li>添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context:方法，导致崩溃；</li>
<li>添加或者移除时 keypath == nil，导致崩溃；</li>
<li>多次重复移除同一个属性，移除了未注册的观察者</li>
</ol>
<h2 id="6-KVO-KVC-的优缺点？"><a href="#6-KVO-KVC-的优缺点？" class="headerlink" title="6.KVO/KVC 的优缺点？"></a>6.KVO/KVC 的优缺点？</h2><ul>
<li>KVC<br>优点：没有 property 的变量（私有）也能通过 KVC 进行设置，或者简化代码（多级属性）<br>缺点：如果 key 只写错，编写的时候不会报错，但是运行的时候会报错</li>
<li>KVO 优点：<br>能够提供一种简单的方法实现两个对象的同步；<br>能够对内部对象的状态改变作出响应，而且不需要改变内部对象的实现；<br>能够提供被观察者属性的最新值和之前的值；<br>使用 key Path 来观察属性，因此可以观察嵌套对象；<br>完成了对观察对象的抽象，因为不需要额外的代码来允许观察者被观察。</li>
<li>KVO 缺点：<br>KVO 只能检测类中的属性，并且属性名都是通过 NSString 来查找，编译器不会补全（编译时不会出现警告），容易写错；<br>对属性重构，将导致观察代码不可用；<br>复杂的 “if” 语句要求对象正在观察多个值，是因为所有的观察代码通过一个方法来指向；</li>
</ul>
<h1 id="25-Block"><a href="#25-Block" class="headerlink" title="25. Block"></a>25. Block</h1><h2 id="1-block-的内部结构和作用"><a href="#1-block-的内部结构和作用" class="headerlink" title="1.block 的内部结构和作用"></a>1.block 的内部结构和作用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    &#x2F;&#x2F; imported variables</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的结构, 可以看出一个 block 实例的构成实际上有 6 个部分：</p>
<ol>
<li>isa 指针: 所有对象都有该指针，用于实现对象相关的功能。</li>
<li>flags: 附加标识位, 在 copy 和 dispose 等情况下可以用到。</li>
<li>reserved:保留变量。</li>
<li>invoke: 函数指针，指向 block 的实现代码, 也可以说是函数调用地址。</li>
<li>descriptor: 表示该 block 的附加描述信息，主要是 size，以及 copy 和 dispose 函数的指针。这两个辅助函数在拷贝及丢弃块对象时运行, 其中会执行一些操作, 比方说, 前者要保留捕获的对象,而后者则将之释放。</li>
<li>variables: 捕获的变量，block 能够访问它外部的局部变量，就是因为将这些变量复制到了结构体中。</li>
</ol>
<h2 id="2-block-的类型"><a href="#2-block-的类型" class="headerlink" title="2.block 的类型"></a>2.block 的类型</h2><p>block 其实是有类型的, 且一共有 3 种类型, 全局块, 栈块, 堆块:</p>
<ol>
<li><code>__NSGlobalBlock__</code>: 存储在全局/静态的 block，不会捕获任何外部变量。</li>
<li><code>__NSStackBlock__</code>: 存储在栈中的 block，当函数返回时会被销毁。</li>
<li><code>__NSMallocBlock__</code>: 存储在堆中的 block，当引用计数为 0 时会被销毁。</li>
</ol>
<ul>
<li>NSGlobalBlock<br><strong>这种块不会捕捉任何变量, 运行时也无须有状态来参与</strong>。全局块声明在全局内存里, 在编译期已经完全确定了。所以, 无论是 ARC 还是 MRC 下, 如下代码中的 block 都是全局静态的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; NSGlobalBlock</span><br><span class="line">- (void)globalBlock &#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;GlobalBlock内部&quot;);               &#x2F;&#x2F; 全局静态区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;GlobalBlock：%@&quot;, block);           &#x2F;&#x2F; 全局静态区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>NSStackBlock 或 NSMallocBlock<br>ARC 下为 NSMallocBlock(堆区), MRC 下为 NSStackBlock(栈区)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ARC下为NSMallocBlock(堆区), MRC下为NSStackBlock(栈区)</span><br><span class="line">- (void)stackBlockInMRCAndHeapBlockInARC &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block：%@&quot;, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>NSMallocBlock</li>
</ul>
<p>要问 MRC 下有没有存储于堆区的 block, 当然有了。但 block 默认会分配在栈区, 需要保留的话, 也可以手动改到堆区, 这样它就是堆块了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; MRC下为NSMallocBlock(堆区), ARC下为NSMallocBlock(堆区)</span><br><span class="line">- (void)heapBlock &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    void (^block)(void) &#x3D; [^&#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        NSLog(@&quot;MallocBlock内部：%p&quot;, &amp;a);</span><br><span class="line">    &#125; copy];</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;MallocBlock：%@&quot;, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>block 在 ARC 和 MRC 下都是存储于堆区的, 所以其类型是 NSMallocBlock 的。<br>为了解决栈块在其变量作用域结束之后被释放的问题，我们需要把 block copy 到堆中，延长其生命周期。<strong>在开启 ARC 时，编译器会判断其是不是全局块, 若不是全局块则需要将 block 从栈 copy 到堆中，并自动生成相应代码。所以, 上面的例子中, 本不用手动添加 copy 代码的, ARC 会帮我们来做这个事情。</strong></p>
<ul>
<li>NSStackBlock<br>创建的 block 没有被持有的时候，编译器就不会做出将其拷贝到堆区的操作，所以这种情况下，它还在栈区。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)stackBlockInARC &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 由于不需要持有block， 所以不需要编译器做多余的拷贝到堆区的操作</span><br><span class="line">    NSLog(@&quot;StackBlock：%@&quot;, ^&#123; NSLog(@&quot;%p&quot;, &amp;a); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-block-类型总结"><a href="#2-block-类型总结" class="headerlink" title="2.block 类型总结"></a>2.block 类型总结</h2><p>总结一下, 在 MRC 中, 可能有三种 block, 就是全局块, 栈块和堆块。 但是在 <strong>ARC 中, 一版情况下只有两种 block, 即全局块和堆块</strong>。由于 ARC 已经能很好地处理对象的生命周期的管理, 所以都放到堆上管理, 不再使用栈区管理了, 所以就栈块的情况就很少了。<br>而且捕获了变量的 block 默认会分配在栈区, 在 MRC 中需要保留的话, 可以手动改到堆区; <strong>在 ARC 中, block 也是在栈区的, 但编译器会并自动将其 copy 到堆中</strong>, 所以会存储在堆区。所以每一个堆块都是由栈块 copy 而来的。<br><strong>在 ARC 下, 当你所创建的 block 没有被指针所持有的时候，编译器就不会做出将其拷贝到堆区的操作。在这种情况下，block 就是一个直接的栈块。</strong></p>
<h2 id="3-block-捕获局部变量"><a href="#3-block-捕获局部变量" class="headerlink" title="3.block 捕获局部变量"></a>3.block 捕获局部变量</h2><p>不加 <code>__block</code>捕获的是值，加了捕获的是指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)captureVariable &#123;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    NSLog(@&quot;Block前：%p&quot;, &amp;a);             &#x2F;&#x2F; 栈区</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);       &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block后：%p&quot;, &amp;a);             &#x2F;&#x2F; 栈区</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; MRC 下</span><br><span class="line">Block前：0x7ffee3ac9a5c</span><br><span class="line">Block内部：0x7ffee3ac9a48</span><br><span class="line">Block后：0x7ffee3ac9a5c</span><br><span class="line">&#x2F;&#x2F; ARC 下:</span><br><span class="line">Block前：0x7ffee4d91a5c</span><br><span class="line">Block内部：0x6000002590d0</span><br><span class="line">Block后：0x7ffee4d91a5c</span><br></pre></td></tr></table></figure>

<p>上面的例子 不加<code>__block</code> 在构建 block 的时候, <strong>传入的捕获变量是变量 a 的值(即传入 a)**。 所以对于 block 捕获的变量, block 默认是将其复制到其数据结构中来实现访问的, **且 block 捕获的变量是在 block 内部进行修改是不会影响外部变量的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)capture__blockVariable &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    NSLog(@&quot;Block前：%p&quot;, &amp;a);            &#x2F;&#x2F; 栈区</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);      &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block后：%p&quot;, &amp;a);            &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; MRC 下</span><br><span class="line">Block前：0x7ffee0110a58</span><br><span class="line">Block内部：0x7ffee0110a58</span><br><span class="line">Block后：0x7ffee0110a58</span><br><span class="line">&#x2F;&#x2F; ARC 下</span><br><span class="line">Block前：0x7ffee4d91a58</span><br><span class="line">Block内部：0x600000233578</span><br><span class="line">Block后：0x600000233578</span><br></pre></td></tr></table></figure>

<p><strong>上面的例子使用 <code>__block</code>修饰 在 ARC 下, block 内部和 block 后的地址是相同的都存在于堆中, 且与 block 前的地址不同。在构建 block 时, 传入捕获变量 a 的地址(即传入&amp;a)。所以对于 block 捕获的<code>__block</code> 修饰的变量，block 是复制其引用地址来实现访问的。自然就可以在 block 内部修改变量从而影响外部的变量了, 且 block 内外打印其地址都是同一个地址。</strong><br><strong>这里的 copy, 都是浅拷贝, 就是所谓的指针拷贝, 所以 a 指针指向的内存地址还是之前定义对象 a 的某块堆区区域。</strong></p>
<h2 id="4-block-可以用-strong-修饰吗"><a href="#4-block-可以用-strong-修饰吗" class="headerlink" title="4.block 可以用 strong 修饰吗"></a>4.block 可以用 strong 修饰吗</h2><p>ARC 是可以的 strong 和 copy 的操作都是将栈上 block 拷贝到堆上。</p>
<h2 id="5-block-在修改-NSMutableArray，需不需要添加-block"><a href="#5-block-在修改-NSMutableArray，需不需要添加-block" class="headerlink" title="5.block 在修改 NSMutableArray，需不需要添加__block"></a>5.block 在修改 NSMutableArray，需不需要添加__block</h2><p>不需要，本身 block 内部就捕获了 NSMutableArray 指针，除非你要修改指针指向的对象，而这里明显只是修改内存数据，这个可以类比 NSMutableString。</p>
<h2 id="6-怎么进行内存管理的"><a href="#6-怎么进行内存管理的" class="headerlink" title="6.怎么进行内存管理的"></a>6.怎么进行内存管理的</h2><ul>
<li><code>_NSConcreteGlobalBlock</code>:是设置在程序的全局数据区域（.data 区）中的 Block 对象。在全局声明实现的 block 或者 没有用到自动变量的 block 为<code>_NSConcreteGlobalBlock</code>，生命周期从创建到应用程序结束。</li>
<li><code>_NSConcreteStackBlock</code> 是设置在栈上的 block 对象，生命周期由系统控制的，一旦所属作用域结束，就被系统销毁了。</li>
</ul>
<h2 id="7-block-发生-copy-时机"><a href="#7-block-发生-copy-时机" class="headerlink" title="7.block 发生 copy 时机"></a>7.block 发生 copy 时机</h2><ul>
<li>调用 Block 的 copy 方法</li>
<li>将 Block 作为函数返回值时</li>
<li>将 Block 赋值给__strong 修饰的变量或 Block 类型成员变量时</li>
<li>向 Cocoa 框架含有 usingBlock 的方法或者 GCD 的 API 传递 Block 参数时</li>
</ul>
<h1 id="26-多线程"><a href="#26-多线程" class="headerlink" title="26.多线程"></a>26.多线程</h1><h2 id="1-iOS-开发中有多少类型的多线程？分别对比"><a href="#1-iOS-开发中有多少类型的多线程？分别对比" class="headerlink" title="1.iOS 开发中有多少类型的多线程？分别对比"></a>1.iOS 开发中有多少类型的多线程？分别对比</h2><p><strong>1. Pthread</strong>，较少使用。</p>
<p><strong>2. NSThread</strong>，每个 NSThread 对象对应一个线程，量级较轻，通常我们会起一个 runloop 保活，然后通过添加自定义 source0 源或者 perform onThread 来进行调用。</p>
<ul>
<li>优点 轻量级，使用简单，</li>
<li>缺点：需要自己管理线程的生命周期，保活，另外还会线程同步，加锁、睡眠和唤醒。</li>
</ul>
<p><strong>3. GCD</strong>：Grand Central Dispatch（派发） 是基于 C 语言的框架，可以充分利用多核，是苹果推荐使用的多线程技术</p>
<ul>
<li>优点：GCD 更接近底层，而 NSOperationQueue 则更高级抽象，所以 GCD 在追求性能的底层操作来说，是速度最快的，有待确认</li>
<li>缺点：操作之间的事务性，顺序行，依赖关系。GCD 需要自己写更多的代码来实现</li>
</ul>
<p><strong>4. NSOperation</strong> 基于 GCD 更高一层封装</p>
<ul>
<li>优点： 使用者的关注点都放在了 operation 上，而不需要线程管理。<br>支持在操作对象之间依赖关系，方便控制执行顺序。<br>支持可选的完成块，它在操作的主要任务完成后执行。<br>支持使用 KVO 通知监视操作执行状态的变化。<br>支持设定操作的优先级，从而影响它们的相对执行顺序。<br>支持取消操作，允许您在操作执行时暂停操作。</li>
<li>缺点：高级抽象，性能方面相较 GCD 来说不足一些;</li>
</ul>
<h2 id="2-GCD-有哪些队列，默认提供哪些队列"><a href="#2-GCD-有哪些队列，默认提供哪些队列" class="headerlink" title="2.GCD 有哪些队列，默认提供哪些队列"></a>2.GCD 有哪些队列，默认提供哪些队列</h2><ol>
<li><p>主队列（main queue ）【串行】<br>保证所有的任务都在主线程执行，而主线程是唯一用于 UI 更新的线程。此外还用于发送消息给视图或发送通知。</p>
</li>
<li><p>四个全局调度队列（high、default、low、background【并发】<br>Apple 的接口也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务</p>
</li>
<li><p>自定义队列</p>
<ul>
<li>多个任务以串行方式执行，但又不想在主线程中</li>
<li>多个任务以并行方式执行，但不希望队列中有其他系统的任务干扰。</li>
</ul>
</li>
</ol>
<h2 id="3-GCD-主线程-amp-主队列的关系"><a href="#3-GCD-主线程-amp-主队列的关系" class="headerlink" title="3.GCD 主线程 &amp; 主队列的关系"></a>3.GCD 主线程 &amp; 主队列的关系</h2><p>队列其实就是一个数据结构体，主队列由于是串行队列，所以入队列中的 task 会逐一派发到主线程中执行；但是其他队列也可能会派发到主线程执行</p>
<h2 id="4-如何实现同步，有多少方式就说多少"><a href="#4-如何实现同步，有多少方式就说多少" class="headerlink" title="4.如何实现同步，有多少方式就说多少"></a>4.如何实现同步，有多少方式就说多少</h2><ul>
<li>dispatch_sync</li>
<li>@synchronized</li>
<li>dispatch_group，</li>
<li>dispatch_semaphore</li>
<li>NSLock/NSRecursiveLock</li>
<li>pthread_mutex_t 互斥锁、递归锁等</li>
</ul>
<h2 id="5-有哪些类型的线程锁，分别介绍下作用和使用场景"><a href="#5-有哪些类型的线程锁，分别介绍下作用和使用场景" class="headerlink" title="5.有哪些类型的线程锁，分别介绍下作用和使用场景"></a>5.有哪些类型的线程锁，分别介绍下作用和使用场景</h2><ul>
<li>@synchronized 性能最差,SD 和 AFN 等框架内部有使用这个.</li>
<li>NSRecursiveLock 和 NSLock ：建议使用前者，避免循环调用出现死锁</li>
<li>OSSpinLock 自旋锁,存在的问题是:优先级反转问题,破坏了 spinlock</li>
<li>dispatch_semaphore 信号量 : 保持线程同步为线程加锁</li>
</ul>
<h1 id="27-通过-UIImage-imageNamed-生成的对象什么时候被释放？"><a href="#27-通过-UIImage-imageNamed-生成的对象什么时候被释放？" class="headerlink" title="27.通过[UIImage imageNamed:]生成的对象什么时候被释放？"></a>27.通过[UIImage imageNamed:]生成的对象什么时候被释放？</h1><ul>
<li>建议针对小图标/场景出现较多图片（此类方式加载，会缓存到内存）</li>
<li>@autoreleasepool 如果没有使用局部释放池，并且在主线程，则是当前主线程 Runloop 一次循环结束前释放。</li>
<li>imageWithContentsOfFile ： 加载适用于大图片,不常用的图片,一般无引用时候,会释放</li>
</ul>
<h2 id="imageName-amp-imageWithContentsOfFile-区别"><a href="#imageName-amp-imageWithContentsOfFile-区别" class="headerlink" title="imageName &amp; imageWithContentsOfFile 区别"></a>imageName &amp; imageWithContentsOfFile 区别</h2><ul>
<li>如果图片较小，并且使用频繁的图片使用 imageNamed：方法来加载。相同的图片是不会重复加载的</li>
<li>如果图片较大，并且使用较少，使用 imageWithContentOfFile:来加载。加载：imageWithContentsOfFile 只能加载 mainBundle 中图片。</li>
<li>当你不需要重用该图像，或者你需要将图像以数据方式存储到数据库，又或者你要通过网络下载一个很大的图像时，使用 imageWithContentsOfFile；</li>
<li>如果在程序中经常需要重用的图片，比如用于 UITableView 的图片，那么最好是选择 imageNamed 方法。这种方法可以节省出每次都从磁盘加载图片的时间；</li>
</ul>
<h1 id="28-UIView-amp-CALayer-的区别"><a href="#28-UIView-amp-CALayer-的区别" class="headerlink" title="28.UIView &amp; CALayer 的区别"></a>28.UIView &amp; CALayer 的区别</h1><ul>
<li>UIView 为 CALayer 提供内容，以及负责处理触摸等事件，参与响应链；</li>
<li>CALayer 负责显示内容 contents</li>
</ul>
<h2 id="layoutsubviews"><a href="#layoutsubviews" class="headerlink" title="layoutsubviews"></a>layoutsubviews</h2><ul>
<li>init 初始化不会触发 layoutSubviews。</li>
<li>addSubview 会触发 layoutSubviews。</li>
<li>改变一个 UIView 的 Frame 会触发 layoutSubviews，当然前提是 frame 的值设置前后发生了变化。</li>
<li>滚动一个 UIScrollView 引发 UIView 的重新布局会触发 layoutSubviews。</li>
<li>旋转 Screen 会触发父 UIView 上的 layoutSubviews 事件。</li>
<li>直接调用 setNeedsLayout 或者 layoutIfNeeded。</li>
<li>setNeedsLayout 标记为需要重新布局，异步调用 layoutIfNeeded 刷新布局，不立即刷新，在下一轮 runloop 结束前刷新，对于这一轮 runloop 之内的所有布局和 UI 上的更新只会刷新一次，layoutSubviews 一定会被调用。</li>
<li>layoutIfNeeded 如果有需要刷新的标记，立即调用 layoutSubviews 进行布局（如果没有标记，不会调用 layoutSubviews）。</li>
</ul>
<h2 id="drawrect"><a href="#drawrect" class="headerlink" title="drawrect"></a>drawrect</h2><ul>
<li>如果在 UIView 初始化时没有设置 frame，会导致 drawRect 不被自动调用</li>
<li>sizeToFit 后会调用。这时候可以先用 sizeToFit 中计算出 size，然后系统自动调用 drawRect 方法</li>
<li>通过设置 contentMode 为.redraw 时，那么在每次设置或更改 frame 的时候自动调用 drawRect</li>
<li>直接调用 setNeedsDisplay，或者 setNeedsDisplayInRect 会触发 drawRect</li>
</ul>
<h1 id="29-图片是什么时候解码的，如何优化"><a href="#29-图片是什么时候解码的，如何优化" class="headerlink" title="29. 图片是什么时候解码的，如何优化"></a>29. 图片是什么时候解码的，如何优化</h1><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</p>
<h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><ul>
<li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩</li>
<li>然后将生成的 UIImage 赋值给 UIImageView ；</li>
<li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li>
<li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<ul>
<li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li>
<li>将文件数据从磁盘读到内存中；</li>
<li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li>
<li>最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。</li>
</ul>
</li>
</ul>
<h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><p>解码操作是比较耗时的，并且没有 GPU 硬解码，只能通过 CPU，iOS 默认会在主线程对图像进行解码。解码过程是一个相当复杂的任务，需要消耗非常长的时间。60FPS ≈ 0.01666s per frame = 16.7ms per frame，这意味着在主线程超过 16.7ms 的任务都会引起掉帧。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage 的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。</p>
<ul>
<li><p>当加载图片的时候，iOS 通常会延迟解压图片的时间，直到加载到内存之后。因为需要在绘制之前进行解压，这就会在准备绘制图片的时候影响性能。</p>
</li>
<li><p>iOS 通常会延时解压图片，等到图片在屏幕上显示的时候解压图片。解压图片是非常耗时的操作。</p>
</li>
</ul>
<h1 id="30-性能优化"><a href="#30-性能优化" class="headerlink" title="30.性能优化"></a>30.性能优化</h1><h2 id="1-如何做启动优化，如何监控"><a href="#1-如何做启动优化，如何监控" class="headerlink" title="1.如何做启动优化，如何监控"></a>1.如何做启动优化，如何监控</h2><ul>
<li>合并或者删减一些 OC 类和函数；可以使用 AppCode 清理项目中没用到的类，属性等。</li>
<li>将不必须在+load 方法中做的事情延迟到+initialize 中</li>
<li>类和方法名不要太长：iOS 每个类和方法名都在__cstring 段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的；因还是 object-c 的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c 对象模型会把类/方法名字符串都保存下来；</li>
<li>在设计师可接受的范围内压缩图片的大小，启动的时候大大小小的图片加载个十来二十个是很正常的，图片小了，IO 操作量就小了，启动当然就会快了，比较靠谱的压缩算法是 TinyPNG。</li>
<li>减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库；如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库；</li>
<li>删减一些无用的静态变量，没有被调用到或者已经废弃的方法。</li>
</ul>
<h2 id="2-如何做卡顿优化，如何监控"><a href="#2-如何做卡顿优化，如何监控" class="headerlink" title="2.如何做卡顿优化，如何监控"></a>2.如何做卡顿优化，如何监控</h2><blockquote>
<p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
</blockquote>
<h3 id="卡顿原因"><a href="#卡顿原因" class="headerlink" title="卡顿原因"></a>卡顿原因</h3><p>标准情况下，页面滑动流畅是 60FPs ，就是每一秒有 60 帧的画面刷新，每 16.7ms(1/60 秒)有一帧数据。上图两个 VSync 之间的时间就是 16.7ms。<br>如果 CPU 和 GPU 加起来的处理时间超过了 16.7ms，就会造成掉帧甚至卡顿。当 FPs 帧数低于 30 时，人的肉眼就能感觉到画面明显的卡顿。</p>
<h3 id="卡顿监控"><a href="#卡顿监控" class="headerlink" title="卡顿监控"></a>卡顿监控</h3><ul>
<li>思路一：监控一秒钟内的帧数是否经常低于或远低于 60FPs。</li>
<li>思路二：监控每一帧的时长是否超时。</li>
</ul>
<p><strong>思路一实现方法：用 CADisplayLinker 来计数</strong></p>
<p>CADisplayLink 可以以屏幕刷新的频率调用指定 selector，iOS 系统中正常的屏幕刷新率为 60 次/秒，只要在这个方法里面统计每秒这个方法执行的次数，通过次数/时间就可以得出当前屏幕的刷新率了。</p>
<p><strong>思路二实现方法：通过子线程监测主线程的 RunLoop，判断两个状态 RunLoop 的状态区域之间的耗时是否达到一定阈值。</strong></p>
<p>开启子线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手，假定连续 6 次超时 50ms 认为卡顿(当然也包含了单次超时 300ms)</p>
<h3 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h3><p>图像显示的工作是由 CPU 和 GPU 协同完成的， 那么优化的方向和思路就是尽量减少他们的处理时长。</p>
<ul>
<li><p><strong>对 CPU 处理的优化:</strong><br>在子线程中进行对象的创建,调整和销毁，节省一部分 CPU 的时间<br>在子线程中预排版(布局计算,文本计算)，让主线程有更多的时间去响应用户的交互<br>对文本等异步绘制,图片编解码等内容进行 预渲染、预排版</p>
</li>
<li><p><strong>对 GPU 处理的优化</strong><br>尽量避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这样能少触发离屏渲染<br>尽可能将多张图片合成为一张进行显示，减轻视图层级</p>
</li>
</ul>
<h1 id="31-MVVM-和-MVC-的区别"><a href="#31-MVVM-和-MVC-的区别" class="headerlink" title="31.MVVM 和 MVC 的区别"></a>31.MVVM 和 MVC 的区别</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>M：数据模型， V：视图， C：控制器<br>controller 层拿到 model 更新 view，<br>view 事件传递到 controller 层，更新 model<br><strong>弊端</strong>：C 控制器层 代码逻辑较多</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M：数据模型，V：视图、控制器，VM：处理逻辑、网络</p>
<ol>
<li>View 引用 ViewModel，但 ViewModle 不能引用 View 视图、控制器。</li>
<li>ViewModel 可以引用 Model， Model 不能引用 ViewModel</li>
<li>viewController 尽量不涉及业务逻辑，让 viewModel 去做这些事情。</li>
<li>viewController 只是一个中间人，接收 view 的事件、调用 viewModel 的方法、响应 viewModel 的变化。</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>低耦合：View 可以独立于 Model 变化和修改，一个 viewModel 可以绑定到不同的 View 上</li>
<li>可重用性：可以把一些视图逻辑放在一个 viewModel 里面，让很多 view 重用这段视图逻辑</li>
<li>独立开发：开发人员可以专注于业务逻辑和数据的开发 viewModel，设计人员可以专注于页面设计</li>
<li>可测试：通常界面是比较难于测试的，而 MVVM 模式可以针对 viewModel 来进行测试</li>
</ul>
<p><strong>弊端</strong>：</p>
<ul>
<li>对于过大的项目，数据绑定和数据转化需要花费更多的内存（成本）。主要成本在于：</li>
<li>数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li>
</ul>
<h1 id="32-用过设计模式介绍下"><a href="#32-用过设计模式介绍下" class="headerlink" title="32.用过设计模式介绍下"></a>32.用过设计模式介绍下</h1><p><strong>单例模式:</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<ul>
<li>优点： 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2. 避免对资源的多重占用（比如写文件操作）。</li>
<li>缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
<p><strong>工厂模式:</strong> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<ul>
<li>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</li>
<li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
</ul>
<p><strong>观察者模式:</strong> 系统的 KVO</p>
<h1 id="33-描述一个-ViewController-的生命周期"><a href="#33-描述一个-ViewController-的生命周期" class="headerlink" title="33.描述一个 ViewController 的生命周期"></a>33.描述一个 ViewController 的生命周期</h1><ol>
<li>当我们调用 UIViewControlller 的 view 时，</li>
<li>系统首先判断当前的 UIViewControlller 是否存在 view，如果存在直接返回 view，</li>
<li>如果不存在的话，会调用 loadview 方法，</li>
<li>然后判断 loadview 方法是否是自定义方法，</li>
<li>如果是自定义方法，就执行自定义方法，</li>
<li>如果不是自定义方法，判断当时视图控制器是否有 xib、stroyboard。</li>
<li>如果有 xib、stroyboard 就加载 xib、stroyboard。</li>
<li>如果没有创建一个空白的 view。</li>
<li>调用 viewDidLoad 方法。</li>
<li>最后返回 view</li>
</ol>
]]></content>
      <categories>
        <category>iOS 知识点</category>
      </categories>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/2021/06/16/1000-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="第一部分：协议层次以及它们的服务类型"><a href="#第一部分：协议层次以及它们的服务类型" class="headerlink" title="第一部分：协议层次以及它们的服务类型"></a>第一部分：协议层次以及它们的服务类型</h1><h2 id="OSI-七层模型-🌟🌟🌟🌟🌟"><a href="#OSI-七层模型-🌟🌟🌟🌟🌟" class="headerlink" title="OSI 七层模型 🌟🌟🌟🌟🌟"></a>OSI 七层模型 🌟🌟🌟🌟🌟</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/ptp0ou.png"
                     
                ><br>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。 OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>① 应用层</p>
<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。</p>
<p>② 表示层</p>
<p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p>
<p>③ 会话层</p>
<p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<p>④ 传输层</p>
<p>传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p>⑤ 网络层</p>
<p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p>
<p>⑥ 数据链路层</p>
<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<p>⑦ 物理层</p>
<p>作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p>
<h2 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h2><p>OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。而 TCP/IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。</p>
<p>① 应用层</p>
<p>TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p>
<p>② 传输层</p>
<p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p>
<p>③ 网际互联层</p>
<p>网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p>
<p>④ 网络接入层</p>
<p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p>
<h2 id="TCP-IP-五层参考模型"><a href="#TCP-IP-五层参考模型" class="headerlink" title="TCP/IP 五层参考模型"></a>TCP/IP 五层参考模型</h2><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p>
<h2 id="OSI-模型和-TCP-IP-模型异同比较-🌟🌟🌟🌟"><a href="#OSI-模型和-TCP-IP-模型异同比较-🌟🌟🌟🌟" class="headerlink" title="OSI 模型和 TCP/IP 模型异同比较 🌟🌟🌟🌟"></a>OSI 模型和 TCP/IP 模型异同比较 🌟🌟🌟🌟</h2><p><strong>相同点</strong></p>
<p>① OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p>
<p>② 都能够提供面向连接和无连接两种通信服务机制。</p>
<p><strong>不同点</strong></p>
<p>① OSI 采用的七层模型； TCP/IP 是四层结构。</p>
<p>② TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p>
<p>③ OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p>
<p>④ TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p>
<p>⑤ OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p>
<h2 id="OSI-和-TCP-IP-协议之间的对应关系"><a href="#OSI-和-TCP-IP-协议之间的对应关系" class="headerlink" title="OSI 和 TCP/IP 协议之间的对应关系"></a>OSI 和 TCP/IP 协议之间的对应关系</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/0yqy24.png"
                     
                ></p>
<table>
<thead>
<tr>
<th>OSI 七层网络模型</th>
<th>TCP/IP 四层概念模型</th>
<th>对应的网络协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>HTTP,DNS,FTP,TFTP</td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
<td>GIF,JPEG,TIFF,PICT</td>
</tr>
<tr>
<td>会话层</td>
<td>应用层</td>
<td>RPC,SQL,NFS</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP,UDP</td>
</tr>
<tr>
<td>网络层层</td>
<td>网络层</td>
<td>IP,ARP,ICMP,RARP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层</td>
<td>FDDI,Frame Relay,HDLC</td>
</tr>
<tr>
<td>物理层</td>
<td>数据链路层</td>
<td>EIA/TIA-232,EIA/TIA-499,V.35</td>
</tr>
</tbody></table>
<h2 id="数据如何在各层之间传输【数据的封装过程】🌟🌟🌟"><a href="#数据如何在各层之间传输【数据的封装过程】🌟🌟🌟" class="headerlink" title="数据如何在各层之间传输【数据的封装过程】🌟🌟🌟"></a>数据如何在各层之间传输【数据的封装过程】🌟🌟🌟</h2><p>在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p>
<h1 id="第二部分：应用层"><a href="#第二部分：应用层" class="headerlink" title="第二部分：应用层"></a>第二部分：应用层</h1><h2 id="HTTP-头部包含哪些信息-🌟🌟🌟"><a href="#HTTP-头部包含哪些信息-🌟🌟🌟" class="headerlink" title="HTTP 头部包含哪些信息 🌟🌟🌟"></a>HTTP 头部包含哪些信息 🌟🌟🌟</h2><p><strong>通用头部</strong><br>协议头|说明|举例<br>-|-|-<br>Cache-Control |用来指定当前的请求/回复中是否使用缓存机制|Cache-Control: no-store<br>Connection|客户端（浏览器）想要优先使用的连接类型|Connection: keep-alive (Upgrade)<br>Date|报文创建时间|Date: Dec, 26 Dec 2015 17: 30: 00 GMT</p>
<p><strong>请求头部</strong><br>协议头|说明|举例<br>-|-|-<br>Authorization|用于表示 HTTP 协议中需要认证资源的认证信息|Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==<br>Host|表示服务器的域名以及服务器所监听的端口号|Host: <a class="link"   href="http://www.itbilu.com/" >www.itbilu.com:80<i class="fas fa-external-link-alt"></i></a><br>Range|表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面|Range: bytes=500-999<br>User-Agent |浏览器的身份标识字符串|User-Agent: Mozilla/……</p>
<p><strong>响应头部</strong><br>协议头|说明|举例<br>-|-|-<br>Age|创建响应的时间|Age：5744337<br>Location|表示重定向后的 URL|Location: <a class="link"   href="http://www.zcmhi.com/archives/94.html" >http://www.zcmhi.com/archives/94.html<i class="fas fa-external-link-alt"></i></a><br>Vary|缓存控制|Vary: Origin</p>
<p><strong>实体头部</strong><br>协议头|说明|举例<br>-|-|-<br>Content-Length|返回内容的字节长度|Content-Length: 348<br>Content-Range|在整个返回体中本部分的字节位置 |Content-Range: bytes 21010-47021/47022<br>Content-Type |返回内容的 MIME 类型|Content-Type: text/html; charset=utf-8</p>
<h2 id="Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗？-🌟🌟🌟"><a href="#Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗？-🌟🌟🌟" class="headerlink" title="Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗？ 🌟🌟🌟"></a>Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗？ 🌟🌟🌟</h2><p>在早期的 HTTP/1.0 中，浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在 HTTP/1.1 版本中默认使用持久连接，在此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 connection 的首部字段的值为 Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流，我们用一个示意图来更加生动的表示两者的区别：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/qzbhuj.png"
                     
                ><br>对于非 Keep=Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担，因为一台 Web 服务器可能同时服务于数以百计的客户机请求。在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。</p>
<p>然而，Keep-Alive 并不是没有缺点的，当长时间的保持 TCP 连接时容易导致系统资源被无效占用，若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。</p>
<h2 id="HTTP-长连接短连接使用场景是什么"><a href="#HTTP-长连接短连接使用场景是什么" class="headerlink" title="HTTP 长连接短连接使用场景是什么"></a>HTTP 长连接短连接使用场景是什么</h2><p><strong>长连接：</strong> 多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p>
<p><strong>短连接：</strong> 用户数目较多的 Web 网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p>
<h2 id="怎么知道-HTTP-的报文长度"><a href="#怎么知道-HTTP-的报文长度" class="headerlink" title="怎么知道 HTTP 的报文长度"></a>怎么知道 HTTP 的报文长度</h2><p>当响应消息中存在 Content-Length 字段时，我们可以直接根据这个值来判断数据是否接收完成，例如客户端向服务器请求一个静态页面或者一张图片时，服务器能够很清楚的知道请求内容的大小，因此可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据，但是如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length。</p>
<p>分块传输编码（Chunked transfer encoding）是 HTTP/1.1 中引入的一种数据传输机制，其允许 HTTP 由服务器发送给客户端的数据可以分成多个部分，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为 0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</p>
<h2 id="HTTP-方法了解哪些"><a href="#HTTP-方法了解哪些" class="headerlink" title="HTTP 方法了解哪些"></a>HTTP 方法了解哪些</h2><p>HTTP/1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。</p>
<p>HTTP/1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。</p>
<h2 id="GET-和-POST-的区别-🌟🌟🌟🌟🌟"><a href="#GET-和-POST-的区别-🌟🌟🌟🌟🌟" class="headerlink" title="GET 和 POST 的区别 🌟🌟🌟🌟🌟"></a>GET 和 POST 的区别 🌟🌟🌟🌟🌟</h2><ul>
<li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li>
<li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li>
<li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li>
<li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li>
<li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li>
<li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li>
</ul>
<h2 id="GET-的长度限制是多少-🌟🌟🌟"><a href="#GET-的长度限制是多少-🌟🌟🌟" class="headerlink" title="GET 的长度限制是多少 🌟🌟🌟"></a>GET 的长度限制是多少 🌟🌟🌟</h2><p>HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，例如 IE 浏览器对 URL 的最大限制为 2000 多个字符，大概 2KB 左右，像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET 的长度限制不同。</p>
<p>由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</p>
<h2 id="HTTP-与-HTTPs-的工作方式【建立连接的过程】🌟🌟🌟🌟"><a href="#HTTP-与-HTTPs-的工作方式【建立连接的过程】🌟🌟🌟🌟" class="headerlink" title="HTTP 与 HTTPs 的工作方式【建立连接的过程】🌟🌟🌟🌟"></a>HTTP 与 HTTPs 的工作方式【建立连接的过程】🌟🌟🌟🌟</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用 pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
<h2 id="HTTPS-和-HTTP-的区别-🌟🌟🌟🌟"><a href="#HTTPS-和-HTTP-的区别-🌟🌟🌟🌟" class="headerlink" title="HTTPS 和 HTTP 的区别 🌟🌟🌟🌟"></a>HTTPS 和 HTTP 的区别 🌟🌟🌟🌟</h2><ul>
<li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</li>
<li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li>
<li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</li>
</ul>
<h2 id="HTTPS-的加密方式"><a href="#HTTPS-的加密方式" class="headerlink" title="HTTPS 的加密方式"></a>HTTPS 的加密方式</h2><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p>
<h2 id="客户端为什么信任第三方证书"><a href="#客户端为什么信任第三方证书" class="headerlink" title="客户端为什么信任第三方证书"></a>客户端为什么信任第三方证书</h2><p>假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</p>
<p>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</p>
<h2 id="HTTP-是不保存状态的协议-如何保存用户状态-🌟🌟🌟🌟"><a href="#HTTP-是不保存状态的协议-如何保存用户状态-🌟🌟🌟🌟" class="headerlink" title="HTTP 是不保存状态的协议,如何保存用户状态 🌟🌟🌟🌟"></a>HTTP 是不保存状态的协议,如何保存用户状态 🌟🌟🌟🌟</h2><p>我们知道，假如某个特定的客户机在短时间内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象就不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不久之前所做过的是一样。因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。</p>
<p>通常有两种解决方案：</p>
<h3 id="①-基于-Session-实现的会话保持"><a href="#①-基于-Session-实现的会话保持" class="headerlink" title="① 基于 Session 实现的会话保持"></a>① 基于 Session 实现的会话保持</h3><p>在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p>
<p><strong>优点：</strong> 安全性高，因为状态信息保存在服务器端。</p>
<p><strong>缺点：</strong> 由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p>
<p>【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】</p>
<h3 id="②-基于-Cookie-实现的会话保持"><a href="#②-基于-Cookie-实现的会话保持" class="headerlink" title="② 基于 Cookie 实现的会话保持"></a>② 基于 Cookie 实现的会话保持</h3><p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</p>
<p><strong>优点：</strong> 服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。</p>
<p><strong>缺点：</strong> 该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p>
<h3 id="拓展：Cookie-被禁用了怎么办？"><a href="#拓展：Cookie-被禁用了怎么办？" class="headerlink" title="拓展：Cookie 被禁用了怎么办？"></a>拓展：Cookie 被禁用了怎么办？</h3><p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p>
<h2 id="面试时针对状态码的常见问法-🌟🌟🌟🌟"><a href="#面试时针对状态码的常见问法-🌟🌟🌟🌟" class="headerlink" title="面试时针对状态码的常见问法 🌟🌟🌟🌟"></a>面试时针对状态码的常见问法 🌟🌟🌟🌟</h2><p>① 状态码 301 和 302 的区别？</p>
<p>301：永久移动。请求的资源已被永久的移动到新的 URI，旧的地址已经被永久的删除了。返回信息会包括新的 URI，浏览器会自动定向到新的 URI。今后新的请求都应使用新的 URI 代替。</p>
<p>302：临时移动。与 301 类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有 URI。</p>
<p>② HTTP 异常状态码知道哪些？</p>
<p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>英文名</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有 URI</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解；请求的参数有误</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>当前请求需要用户验证</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server</td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented 服务器不支持当前请求所需要的某个功能</td>
<td></td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应</td>
<td></td>
</tr>
</tbody></table>
<h2 id="HTTP-1-1-和-HTTP-1-0-的区别-🌟🌟🌟"><a href="#HTTP-1-1-和-HTTP-1-0-的区别-🌟🌟🌟" class="headerlink" title="HTTP/1.1 和 HTTP/1.0 的区别 🌟🌟🌟"></a>HTTP/1.1 和 HTTP/1.0 的区别 🌟🌟🌟</h2><p>缓存处理：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。</p>
<p>节约带宽： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p>
<p>错误通知的管理：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p>
<p>Host 请求头：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p>
<p>长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p>
<h2 id="HTTP-1-X-和-HTTP-2-0-的区别-🌟🌟🌟"><a href="#HTTP-1-X-和-HTTP-2-0-的区别-🌟🌟🌟" class="headerlink" title="HTTP/1.X 和 HTTP/2.0 的区别 🌟🌟🌟"></a>HTTP/1.X 和 HTTP/2.0 的区别 🌟🌟🌟</h2><p>相比于 HTTP/1.X 的文本（字符串）传送， HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。</p>
<p>HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。</p>
<p>HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。</p>
<p>HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。</p>
<h2 id="HTTP-3-了解吗-🌟🌟🌟"><a href="#HTTP-3-了解吗-🌟🌟🌟" class="headerlink" title="HTTP/3 了解吗 🌟🌟🌟"></a>HTTP/3 了解吗 🌟🌟🌟</h2><h3 id="HTTP-2-存在的问题"><a href="#HTTP-2-存在的问题" class="headerlink" title="HTTP/2 存在的问题"></a>HTTP/2 存在的问题</h3><p>我们知道，传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的 HTTP/2，也无法完全解决 TCP 协议存在的固有问题（慢启动，拥塞窗口尺寸的设置等）。此外，HTTP/2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP/2 的表现将不如 HTTP/1.1。</p>
<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>QUIC（Quick UDP Internet Connections），直译为快速 UDP 网络连接，是谷歌制定的一种基于 UDP 的低延迟传输协议。其主要目的是解决采用传输层 TCP 协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了 TCP, TLS, HTTP/2 等协议的特性，并基于 UDP 传输。该协议带来的主要提升有：</p>
<p>低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。</p>
<p>QUIC 复用了 HTTP/2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP/2 存在的队头阻塞问题。<br>基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。</p>
<p>QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。</p>
<p>具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。</p>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。HTTP/3 主要有以下几个特点：</p>
<p>① 使用 UDP 作为传输层进行通信；</p>
<p>② 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手；</p>
<p>③ 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；</p>
<p>④ 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；</p>
<p>⑤ 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。</p>
<p>最后我们使用一张图来清晰的表示出 HTTP 协议的发展变化：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/aqw6ns.png"
                     
                ></p>
<h2 id="DNS-的作用和原理-🌟🌟🌟🌟"><a href="#DNS-的作用和原理-🌟🌟🌟🌟" class="headerlink" title="DNS 的作用和原理 🌟🌟🌟🌟"></a>DNS 的作用和原理 🌟🌟🌟🌟</h2><p>DNS</p>
<p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。</p>
<p>DNS 的作用</p>
<p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<p>DNS 域名解析原理</p>
<p>DNS 采用了分布式的设计方案，其域名空间采用一种树形的层次结构：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/lian6m.png"
                     
                ><br>上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。其实根域名服务器在因特网上有 13 个，大部分位于北美洲。第二层为顶级域服务器，这些服务器负责顶级域名（如 com、org、net、edu）和所有国家的顶级域名（如 uk、fr、ca 和 jp）。在第三层为权威 DNS 服务器，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/hwcxay.png"
                     
                ><br>在上图中，IP 地址的查询其实经历了两种查询方式，分别是递归查询和迭代查询。</p>
<p>拓展：域名解析查询的两种方式</p>
<p><strong>递归查询：</strong> 如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。<br><strong>迭代查询：</strong> 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）。</p>
<h2 id="DNS-为什么用-UDP"><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h2><p>更正确的答案是 DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h2 id="怎么实现-DNS-劫持"><a href="#怎么实现-DNS-劫持" class="headerlink" title="怎么实现 DNS 劫持"></a>怎么实现 DNS 劫持</h2><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。</p>
<p>具体实施步骤如下：</p>
<p>① 获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息。</p>
<p>② 控制域名相应的 E-MAIL 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码。更高级的攻击者甚至能够直接对 E-mail 进行信息窃取。</p>
<p>③ 修改注册信息：当攻击者破解了 E-MAIL 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。</p>
<p>④ 使用 E-MAIL 收发确认函：在修改完注册信息后，攻击者在 E-mail 真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。</p>
<p>用户端的一些预防手段：</p>
<p>直接通过 IP 地址访问网站，避开 DNS 劫持。<br>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8。</p>
<h2 id="socket-套接字有哪些-🌟🌟🌟"><a href="#socket-套接字有哪些-🌟🌟🌟" class="headerlink" title="socket() 套接字有哪些 🌟🌟🌟"></a>socket() 套接字有哪些 🌟🌟🌟</h2><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p>
<p>套接字主要有以下三种类型：</p>
<p>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</p>
<p>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</p>
<p>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</p>
<h2 id="URI（统一资源标识符）和-URL（统一资源定位符）之间的区别-🌟🌟🌟"><a href="#URI（统一资源标识符）和-URL（统一资源定位符）之间的区别-🌟🌟🌟" class="headerlink" title="URI（统一资源标识符）和 URL（统一资源定位符）之间的区别 🌟🌟🌟"></a>URI（统一资源标识符）和 URL（统一资源定位符）之间的区别 🌟🌟🌟</h2><p>URL，即统一资源定位符 (Uniform Resource Locator )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。例如 <a class="link"   href="https://leetcode-cn.com/problemset/all/" >https://leetcode-cn.com/problemset/all/<i class="fas fa-external-link-alt"></i></a> 这个 URL，标识一个特定资源并表示该资源的某种形式是可以通过 HTTP 协议从相应位置获得。</p>
<p>从定义即可看出，URL 是 URI 的一个子集，两者都定义了资源是什么，而 URL 还定义了如何能访问到该资源。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而 URL 则必须提供足够的信息来定位，是绝对的。简单地说，只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL。</p>
<h2 id="为什么-fidder，charles-能抓到你的包【抓取数据包的过程】"><a href="#为什么-fidder，charles-能抓到你的包【抓取数据包的过程】" class="headerlink" title="为什么 fidder，charles 能抓到你的包【抓取数据包的过程】"></a>为什么 fidder，charles 能抓到你的包【抓取数据包的过程】</h2><p>假如我们需要抓取客户端的数据包，需要监控客户端与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。而中间的网络节点不受我们控制，是基本无法实现抓包的，因此只能在客户端与服务器之间进行抓包。</p>
<p>① 当采用抓包工具抓取 HTTP 数据包时，过程较为简单：</p>
<p>首先抓包工具会提出代理服务，客户端需要连接该代理；<br>客户端发出 HTTP 请求时，会经过抓包工具的代理，抓包工具将请求的原文进行展示；<br>抓包工具使用该原文将请求发送给服务器；<br>服务器返回结果给抓包工具，抓包工具将返回结果进行展示；<br>抓包工具将服务器返回的结果原样返回给客户端。<br>这里抓包工具相当于透明人，数据经过的时候它一只手接到数据，然后另一只手把数据传出去。</p>
<p>② 当抓取 HTTPS 数据包时：</p>
<p>客户端连接抓包工具提供的代理服务，并安装抓包工具的根证书；<br>客户端发出 HTTPS 请求，抓包工具模拟服务器与客户端进行 TLS 握手交换密钥等流程；<br>抓包工具发送一个 HTTPS 请求给客户端请求的目标服务器，并与目标服务器进行 TLS 握手交换密钥等流程；<br>客户端使用与抓包工具协定好的密钥加密数据后发送给抓包工具；<br>抓包工具使用与客户端协定好的密钥解密数据，并将结果进行展示；<br>抓包工具将解密后的客户端数据，使用与服务器协定好的密钥进行加密后发送给目标服务器；<br>服务器解密数据后，做对应的逻辑处理，然后将返回结果使用与抓包工具协定好的密钥进行加密发送给抓包工具；<br>抓包工具将服务器返回的结果，用与服务器协定好的密钥解密，并将结果进行展示；<br>抓包工具将解密后的服务器返回数据，使用与客户端协定好的密钥进行加密后发送给客户端；<br>客户端解密数据。<br>这个时候抓包工具对客户端来说相当于服务器，对服务器来说相当于客户端。在这个传输过程中，客户端会以为它就是目标服务器，服务器也会以为它就是请求发起的客户端。</p>
<h2 id="如果你访问一个网站很慢，怎么排查和解决"><a href="#如果你访问一个网站很慢，怎么排查和解决" class="headerlink" title="如果你访问一个网站很慢，怎么排查和解决"></a>如果你访问一个网站很慢，怎么排查和解决</h2><p>网页打开速度慢的原因有很多，这里列举出一些较常出现的问题：</p>
<p>① 首先最直接的方法是查看本地网络是否正常，可以通过网络测速软件例如电脑管家等对电脑进行测速，若网速正常，我们查看网络带宽是否被占用，例如当你正在下载电影时并且没有限速，是会影响你打开网页的速度的，这种情况往往是处理器内存小导致的；</p>
<p>② 当网速测试正常时，我们对网站服务器速度进行排查，通过 ping 命令查看链接到服务器的时间和丢包等情况，一个速度好的机房，首先丢包率不能超过 1%，其次 ping 值要小，最后是 ping 值要稳定，如最大和最小差值过大说明路由不稳定。或者我们也可以查看同台服务器上其他网站的打开速度，看是否其他网站打开也慢。</p>
<p>③ 如果网页打开的速度时快时慢，甚至有时候打不开，有可能是空间不稳定的原因。当确定是该问题时，就要找你的空间商解决或换空间商了，如果购买空间的话，可选择购买购买双线空间或多线空间；如果是在有的地方打开速度快，有的地方打开速度慢，那应该是网络线路的问题。电信线路用户访问放在联通服务器的网站，联通线路用户访问放在电信服务器上的网站，相对来说打开速度肯定是比较慢。</p>
<p>④ 从网站本身找原因。网站的问题主要包括网站程序设计、网页设计结构和网页内容三个部分。</p>
<p>网站程序设计：当访问网页中有拖慢网站打开速度的代码，会影响网页的打开速度，例如网页中的统计代码，我们最好将其放在网站的末尾。因此我们需要查看网页程序的设计结构是否合理；<br>网页设计结构：如果是 table 布局的网站，查看是否嵌套次数太多，或是一个大表格分成多个表格这样的网页布局，此时我们可以采用 div 布局并配合 css 进行优化。<br>网页内容：查看网页中是否有许多尺寸大的图片或者尺寸大的 flash 存在，我们可以通过降低图片质量，减小图片尺寸，少用大型 flash 加以解决。此外，有的网页可能过多地引用了其他网站的内容，若某些被引用的网站访问速度慢，或者一些页面已经不存在了，打开的速度也会变慢。一种直接的解决方法是去除不必要的加载项。</p>
<h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><p>FTP</p>
<ul>
<li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户/服务器方式，使用 UDP 数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定。</li>
</ul>
<p>SMTP<br>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</p>
<p>DHCP<br>DHCP ( Dynamic Host Configuration Protocol，动态主机设置协议 ) 是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p>
<ul>
<li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li>
<li>用于内部网络管理员作为对所有电脑作中央管理的手段</li>
</ul>
<h2 id="网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟"><a href="#网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟" class="headerlink" title="网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟"></a>网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/wmooux.png"
                     
                ><br>① DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。【具体细节参看问题 16，17】</p>
<p>② TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。【三次握手放在传输层详细讲解】</p>
<p>③ 发送 HTTP 请求：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的 TCP 连接中，按照 HTTP 协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</p>
<p>拓展：什么是负载均衡？</p>
<p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。</p>
<p>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p>
<p>④ 处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</p>
<p>⑤ 浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
<p>⑥ 断开连接：客户端和服务器通过四次挥手终止 TCP 连接。【其中的细节放在传输层详细讲解】</p>
<h1 id="第三部分：传输层"><a href="#第三部分：传输层" class="headerlink" title="第三部分：传输层"></a>第三部分：传输层</h1><h2 id="三次握手和四次挥手机制-🌟🌟🌟🌟🌟"><a href="#三次握手和四次挥手机制-🌟🌟🌟🌟🌟" class="headerlink" title="三次握手和四次挥手机制 🌟🌟🌟🌟🌟"></a>三次握手和四次挥手机制 🌟🌟🌟🌟🌟</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/tc9f5u.png"
                     
                ><br>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p>
<p>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p>
<p>标志位为 SYN，表示请求建立连接；<br>序号为 Seq = x（x 一般为 1）；<br>随后客户端进入 SYN-SENT 阶段。<br>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p>
<p>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；<br>序号为 Seq = y；<br>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。<br>③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p>
<p>标志位为 ACK，表示确认收到服务器端同意连接的信号；<br>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；<br>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。<br>随后客户端进入 ESTABLISHED。<br>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/dxkghq.png"
                     
                ><br>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p>
<p>① 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：</p>
<p>标记位为 FIN，表示请求释放连接；<br>序号为 Seq = u；<br>随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。<br>② 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：</p>
<p>标记位为 ACK，表示接收到客户端释放连接的请求；<br>序号为 Seq = v；<br>确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；<br>随后服务器开始准备释放服务器端到客户端方向上的连接。<br>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段。</p>
<p>③ 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：</p>
<p>标记位为 FIN 和 ACK，表示已经准备好释放连接了；<br>序号为 Seq = w；<br>确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。<br>随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。</p>
<p>④ 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：</p>
<p>标记位为 ACK，表示接收到服务器准备好释放连接的信号；<br>序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；<br>确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。<br>随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p>
<h2 id="如果三次握手的时候每次握手信息对方没有收到会怎么样"><a href="#如果三次握手的时候每次握手信息对方没有收到会怎么样" class="headerlink" title="如果三次握手的时候每次握手信息对方没有收到会怎么样"></a>如果三次握手的时候每次握手信息对方没有收到会怎么样</h2><p>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。</p>
<p>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</p>
<p>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态。</p>
<h2 id="为什么要进行三次握手？两次握手可以吗？"><a href="#为什么要进行三次握手？两次握手可以吗？" class="headerlink" title="为什么要进行三次握手？两次握手可以吗？"></a>为什么要进行三次握手？两次握手可以吗？</h2><p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</p>
<p>我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p>
<h2 id="第-2-次握手传回了-ACK，为什么还要传回-SYN"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN</h2><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了告诉客户端，服务端收到的消息确实是客户端发送的消息。</p>
<h2 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h2><p>释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h2 id="CLOSE-WAIT-和-TIME-WAIT-的状态和意义"><a href="#CLOSE-WAIT-和-TIME-WAIT-的状态和意义" class="headerlink" title="CLOSE-WAIT 和 TIME-WAIT 的状态和意义"></a>CLOSE-WAIT 和 TIME-WAIT 的状态和意义</h2><p>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</p>
<p>TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</p>
<h2 id="TIME-WAIT-状态会导致什么问题，怎么解决"><a href="#TIME-WAIT-状态会导致什么问题，怎么解决" class="headerlink" title="TIME_WAIT 状态会导致什么问题，怎么解决"></a>TIME_WAIT 状态会导致什么问题，怎么解决</h2><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p>
<p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p>
<h2 id="TIME-WAIT-为什么是-2MSL"><a href="#TIME-WAIT-为什么是-2MSL" class="headerlink" title="TIME-WAIT 为什么是 2MSL"></a>TIME-WAIT 为什么是 2MSL</h2><p>当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。</p>
<p>若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。</p>
<p>若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。</p>
<p>所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。</p>
<h2 id="有很多-TIME-WAIT-状态如何解决"><a href="#有很多-TIME-WAIT-状态如何解决" class="headerlink" title="有很多 TIME-WAIT 状态如何解决"></a>有很多 TIME-WAIT 状态如何解决</h2><p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。</p>
<p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p>
<h2 id="有很多-CLOSE-WAIT-怎么解决"><a href="#有很多-CLOSE-WAIT-怎么解决" class="headerlink" title="有很多 CLOSE-WAIT 怎么解决"></a>有很多 CLOSE-WAIT 怎么解决</h2><p>首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码。</p>
<p>调整系统参数，包括句柄相关参数和 TCP/IP 的参数，一般一个 CLOSE_WAIT 会维持至少 2 个小时的时间，我们可以通过调整参数来缩短这个时间。</p>
<h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/srgsce.png"
                     
                ></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否面向连接</th>
<th>传输可靠性</th>
<th>传输形式</th>
<th>传输效率</th>
<th>所需资源</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>文件传输、邮件传输</td>
<td>20~60</td>
</tr>
<tr>
<td>UDP</td>
<td>否</td>
<td>不可靠</td>
<td>数据报文段</td>
<td>快</td>
<td>少</td>
<td>即时通讯、域名转换</td>
<td>8 个字节</td>
</tr>
</tbody></table>
<h2 id="TCP-是如何保证可靠性的"><a href="#TCP-是如何保证可靠性的" class="headerlink" title="TCP 是如何保证可靠性的"></a>TCP 是如何保证可靠性的</h2><p><strong>数据分块：</strong> 应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p><strong>序列号和确认应答：</strong> TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</p>
<p><strong>校验和：</strong> TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</p>
<p><strong>流量控制：</strong> TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</p>
<p><strong>拥塞控制：</strong> 当网络某个节点发生拥塞时，减少数据的发送。</p>
<p><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<p><strong>超时重传：</strong> 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p>
<h2 id="UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么-🌟🌟🌟"><a href="#UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么-🌟🌟🌟" class="headerlink" title="UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么 🌟🌟🌟"></a>UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么 🌟🌟🌟</h2><p>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故 UDP 的数据传输是不可靠的。</p>
<p>和 TCP 建立连接时采用三次握手不同，UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号（通过设置 connect 函数的第二个参数）。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。</p>
<p>当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p>
<h2 id="TCP-超时重传的原理-🌟🌟🌟"><a href="#TCP-超时重传的原理-🌟🌟🌟" class="headerlink" title="TCP 超时重传的原理 🌟🌟🌟"></a>TCP 超时重传的原理 🌟🌟🌟</h2><p>发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</p>
<h2 id="TCP-的停止等待协议是什么-🌟🌟🌟"><a href="#TCP-的停止等待协议是什么-🌟🌟🌟" class="headerlink" title="TCP 的停止等待协议是什么 🌟🌟🌟"></a>TCP 的停止等待协议是什么 🌟🌟🌟</h2><p>停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。我们通过四种情形来帮助理解停等协议是如何实现可靠传输的：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/g2ioim.png"
                     
                ><br>① 无差错传输</p>
<p>如上述左图所示，A 发送分组 Msg 1，发完就暂停发送，直到收到接收方确认收到 Msg 1 的报文后，继续发送 Msg 2，以此类推，该情形是通信中的一种理想状态。</p>
<p>② 出现差错</p>
<p>如上述右图所示，发送方发送的报文出现差错导致接收方不能正确接收数据，出现差错的情况主要分为两种：</p>
<p>发送方发送的 Msg 1 在中途丢失了，接收方完全没收到数据。<br>接收方收到 Msg 1 后检测出现了差错，直接丢弃 Msg 1。<br>上面两种情形，接收方都不会回任何消息给发送方，此时就会触发超时传输机制，即发送方在等待一段时间后仍然没有收到接收方的确认，就认为刚才发送的数据丢失了，因此重传前面发送过的数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/ku1p3d.png"
                     
                ><br>③ 确认丢失</p>
<p>当接收方回应的 Msg 1 确认报文在传输过程中丢失，发送方无法接收到确认报文。于是发送方等待一段时间后重传 Msg 1，接收方将收到重复的 Msg1 数据包，此时接收方会丢弃掉这个重复报文并向发送方再次发送 Msg1 的确认报文。</p>
<p>④ 确认迟到</p>
<p>当接收方回应的 Msg 1 确认报文由于网络各种原因导致发送方没有及时收到，此时发送方在超时重传机制的作用下再次发送了 Msg 数据包，接收方此时进行和确认丢失情形下相同的动作（丢弃重复的数据包并再次发送 Msg 1 确认报文）。发送方此时收到了接收方的确认数据包，于是继续进行数据发送。过了一段时间后，发送方收到了迟到的 Msg 1 确认包会直接丢弃。</p>
<p>上述四种情形即停止等待协议中所出现的所有可能情况。</p>
<h2 id="TCP-最大连接数限制"><a href="#TCP-最大连接数限制" class="headerlink" title="TCP 最大连接数限制"></a>TCP 最大连接数限制</h2><h3 id="Client-最大-TCP-连接数"><a href="#Client-最大-TCP-连接数" class="headerlink" title="Client 最大 TCP 连接数"></a>Client 最大 TCP 连接数</h3><p>client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0 不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。</p>
<h3 id="Server-最大-TCP-连接数"><a href="#Server-最大-TCP-连接数" class="headerlink" title="Server 最大 TCP 连接数"></a>Server 最大 TCP 连接数</h3><p>server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方。</p>
<p>然而上面给出的是只是理论上的单机最大连接数，在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的。</p>
<h2 id="TCP-流量控制与拥塞控制-🌟🌟🌟🌟"><a href="#TCP-流量控制与拥塞控制-🌟🌟🌟🌟" class="headerlink" title="TCP 流量控制与拥塞控制 🌟🌟🌟🌟"></a>TCP 流量控制与拥塞控制 🌟🌟🌟🌟</h2><ul>
<li><p><strong>流量控制</strong><br>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。</p>
</li>
<li><p><strong>拥塞控制</strong><br>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p>
</li>
<li><p><strong>拥塞控制和流量控制的区别</strong><br>拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而 TCP 连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。</p>
</li>
</ul>
<h2 id="如果接收方滑动窗口满了，发送方会怎么做-🌟🌟🌟🌟"><a href="#如果接收方滑动窗口满了，发送方会怎么做-🌟🌟🌟🌟" class="headerlink" title="如果接收方滑动窗口满了，发送方会怎么做 🌟🌟🌟🌟"></a>如果接收方滑动窗口满了，发送方会怎么做 🌟🌟🌟🌟</h2><p>基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，发送方便继续发送数据。</p>
<h2 id="TCP-拥塞控制采用的四种算法-🌟🌟🌟"><a href="#TCP-拥塞控制采用的四种算法-🌟🌟🌟" class="headerlink" title="TCP 拥塞控制采用的四种算法 🌟🌟🌟"></a>TCP 拥塞控制采用的四种算法 🌟🌟🌟</h2><ul>
<li><strong>慢开始</strong><br>当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd 为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。<br>但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。<br>① 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法；<br>② 当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；<br>③ 当 cwnd == ssthresh 时，两者均可。</li>
</ul>
<ul>
<li><strong>拥塞避免</strong><br>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。</li>
</ul>
<p>当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p>
<ul>
<li><p><strong>快重传</strong><br>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p>
</li>
<li><p><strong>快恢复</strong><br>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：<br>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；<br>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。</p>
</li>
</ul>
<h2 id="TCP-粘包问题-🌟🌟🌟"><a href="#TCP-粘包问题-🌟🌟🌟" class="headerlink" title="TCP 粘包问题 🌟🌟🌟"></a>TCP 粘包问题 🌟🌟🌟</h2><p>为什么会发生 TCP 粘包和拆包?</p>
<p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p>
<p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p>
<p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p>
<p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p>
<p>常见解决方法</p>
<p>① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p>
<p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p>
<p>③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p>
<p>什么时候需要处理粘包问题？</p>
<p>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。</p>
<h2 id="TCP-报文包含哪些信息"><a href="#TCP-报文包含哪些信息" class="headerlink" title="TCP 报文包含哪些信息"></a>TCP 报文包含哪些信息</h2><p>TCP 报文是 TCP 传输的的数据单元，也叫做报文段，其报文格式如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://files.catbox.moe/4w7vow.png"
                     
                ></p>
<ul>
<li>源端口和目的端口号：它用于多路复用/分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。</li>
<li>序号和确认号字段：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。</li>
<li>首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。</li>
<li>保留：为将来用于新的用途而保留。</li>
<li>控制位：URG 表示紧急指针标志，该位为 1 时表示紧急指针有效，为 0 则忽略；ACK 为确认序号标志，即相应报文段包括一个对已被成功接收报文段的确认；PSH 为 push 标志，当该位为 1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队； RST 为重置连接标志，当出现错误连接时，使用此标志来拒绝非法的请求；SYN 为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；FIN 为 finish 标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。</li>
<li>接收窗口：主要用于 TCP 流量控制。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。</li>
<li>校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该 TCP 报文。</li>
<li>紧急数据指针：紧急数据用于告知紧急数据所在的位置，在 URG 标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。</li>
<li>选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：<br>① TCP 连接初始化时，通信双方确认最大报文长度。</li>
</ul>
<p>② 在高速数据传输时，可使用该选项协商窗口扩大因子。</p>
<p>③ 作为时间戳时，提供一个 较为精准的 RTT，主要为了更好的实现 TCP 流量控制协议。</p>
<ul>
<li>数据：TCP 报文中的数据部分也是可选的，例如在 TCP 三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据。</li>
</ul>
<h2 id="SYN-FLOOD-是什么"><a href="#SYN-FLOOD-是什么" class="headerlink" title="SYN FLOOD 是什么"></a>SYN FLOOD 是什么</h2><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>
<h1 id="为什么服务端易受到-SYN-攻击-🌟🌟🌟"><a href="#为什么服务端易受到-SYN-攻击-🌟🌟🌟" class="headerlink" title="为什么服务端易受到 SYN 攻击 🌟🌟🌟"></a>为什么服务端易受到 SYN 攻击 🌟🌟🌟</h1><p>在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p>
<p>服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<p>解决方法：</p>
<ul>
<li>直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；</li>
<li>部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</li>
</ul>
<p>上述两种方法虽然在一定程度上能够提高服务器的防御能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽。</p>
<ul>
<li>SYN Cache：该方法首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。和服务器传输资源相比，维护表的开销要小得多。</li>
<li>SYN Cookies：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端发送 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</li>
</ul>
<p>然而该方案也存在一些缺点，由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p>
<ul>
<li>SYN Proxy：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）。</li>
</ul>
<h1 id="第四部分：网络层"><a href="#第四部分：网络层" class="headerlink" title="第四部分：网络层"></a>第四部分：网络层</h1><h2 id="IP-协议的定义和作用-🌟🌟🌟"><a href="#IP-协议的定义和作用-🌟🌟🌟" class="headerlink" title="IP 协议的定义和作用 🌟🌟🌟"></a>IP 协议的定义和作用 🌟🌟🌟</h2><p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成了 TCP/IP 协议族的核心。IP 协议主要有以下几个作用：</p>
<ul>
<li>寻址和路由：在 IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li>
<li>分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li>
</ul>
<h2 id="域名和-IP-的关系，一个-IP-可以对应多个域名吗"><a href="#域名和-IP-的关系，一个-IP-可以对应多个域名吗" class="headerlink" title="域名和 IP 的关系，一个 IP 可以对应多个域名吗"></a>域名和 IP 的关系，一个 IP 可以对应多个域名吗</h2><p>IP 在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号；域名在同一个网络中也是唯一的，就像一个人的名字，绰号。假如你有多个不同的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是唯一的。由此我们可以看出一个域名只能对应一个 IP 地址，是一对一的关系；而一个 IP 却可以对应多个域名，是一对多的关系。</p>
<h2 id="IPV4-地址不够如何解决"><a href="#IPV4-地址不够如何解决" class="headerlink" title="IPV4 地址不够如何解决"></a>IPV4 地址不够如何解决</h2><ul>
<li><p><strong>DHCP：</strong> 动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</p>
</li>
<li><p><strong>CIDR：</strong> 无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效的分配 IPv4 的地址空间，但无法从根本上解决地址耗尽问题。</p>
</li>
<li><p><strong>NAT：</strong> 网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</p>
</li>
<li><p><strong>IPv6 ：</strong> 作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个 IP 地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</p>
</li>
</ul>
<h2 id="路由器的分组转发流程-🌟🌟🌟"><a href="#路由器的分组转发流程-🌟🌟🌟" class="headerlink" title="路由器的分组转发流程 🌟🌟🌟"></a>路由器的分组转发流程 🌟🌟🌟</h2><p>① 从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络；</p>
<p>② 判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 ③；</p>
<p>③ 检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 ④；</p>
<p>④ 逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 ⑤；</p>
<p>⑤ 若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 ⑥；</p>
<p>⑥ 无法找到合适路由，向源主机报错。</p>
<h2 id="路由器和交换机的区别-🌟🌟🌟🌟"><a href="#路由器和交换机的区别-🌟🌟🌟🌟" class="headerlink" title="路由器和交换机的区别 🌟🌟🌟🌟"></a>路由器和交换机的区别 🌟🌟🌟🌟</h2><ul>
<li><strong>交换机：</strong> 交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li>
</ul>
<ul>
<li><strong>路由器：</strong> 路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li>
</ul>
<ul>
<li>交换机的端口不具有实际的 MAC 地址,因此交换机只是把接收到的消息转发出去而已，它的各端口并不以实际的发送方或接收方的身份参与到以太网包的传递过程；而路由器的端口具有 MAC 地址 IP 地址，所以它的端口是作为以太网包实际的接收方与发送方的身份存在的。</li>
<li>当交换机不知道将包转发到哪一个端口时，它会将包转发到除了源端口以外的所有端口；而当路由器不知道将包转发到哪一端口时，它就直接丢弃这个包。产生这种区别的原因是他们所连接的网络的规模不同——交换机工作在局域网，它所连接的网络规模比较小，向所有端口转发也不会造成多大问题；但路由器工作的环境是互联网，它的规模是远大于互联网的，若向所有端口转发则会产生大量的网络包，造成网络拥塞。</li>
</ul>
<h2 id="ICMP-协议概念-作用"><a href="#ICMP-协议概念-作用" class="headerlink" title="ICMP 协议概念/作用"></a>ICMP 协议概念/作用</h2><p>ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）。</p>
<h2 id="两台电脑连起来后-ping-不通，你觉得可能存在哪些问题？"><a href="#两台电脑连起来后-ping-不通，你觉得可能存在哪些问题？" class="headerlink" title="两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？"></a>两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？</h2><ul>
<li>首先看网络是否连接正常，检查网卡驱动是否正确安装。</li>
<li>局域网设置问题，检查 IP 地址是否设置正确。</li>
<li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 。</li>
<li>看是否被第三方软件拦截。</li>
<li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到。</li>
</ul>
<h2 id="ARP-地址解析协议的原理和地址解析过程-🌟🌟🌟🌟"><a href="#ARP-地址解析协议的原理和地址解析过程-🌟🌟🌟🌟" class="headerlink" title="ARP 地址解析协议的原理和地址解析过程 🌟🌟🌟🌟"></a>ARP 地址解析协议的原理和地址解析过程 🌟🌟🌟🌟</h2><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48 位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
<p>使用 ARP 的 4 种情况：</p>
<ol>
<li>发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>
<li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>
</ol>
<h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p>
<p>NAT 的实现方式主要有三种：</p>
<ul>
<li>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</li>
<li>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</li>
<li>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</li>
</ul>
<h2 id="TTL-是什么？有什么作用"><a href="#TTL-是什么？有什么作用" class="headerlink" title="TTL 是什么？有什么作用"></a>TTL 是什么？有什么作用</h2><p>TTL 是指生存时间，简单来说，它表示了数据包在网络中的时间。每经过一个路由器后 TTL 就减一，这样 TTL 最终会减为 0 ，当 TTL 为 0 时，则将数据包丢弃。通过设置 TTL 可以避免这两个路由器之间形成环导致数据包在环路上死转的情况，由于有了 TTL ，当 TTL 为 0 时，数据包就会被抛弃。</p>
<h2 id="运输层协议和网络层协议的区别"><a href="#运输层协议和网络层协议的区别" class="headerlink" title="运输层协议和网络层协议的区别"></a>运输层协议和网络层协议的区别</h2><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p>
<h1 id="第五部分：数据链路层"><a href="#第五部分：数据链路层" class="headerlink" title="第五部分：数据链路层"></a>第五部分：数据链路层</h1><h2 id="MAC-地址和-IP-地址分别有什么作用"><a href="#MAC-地址和-IP-地址分别有什么作用" class="headerlink" title="MAC 地址和 IP 地址分别有什么作用"></a>MAC 地址和 IP 地址分别有什么作用</h2><ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>
</ul>
<h2 id="为什么有了-MAC-地址还需要-IP-地址-🌟🌟🌟🌟"><a href="#为什么有了-MAC-地址还需要-IP-地址-🌟🌟🌟🌟" class="headerlink" title="为什么有了 MAC 地址还需要 IP 地址 🌟🌟🌟🌟"></a>为什么有了 MAC 地址还需要 IP 地址 🌟🌟🌟🌟</h2><p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<h2 id="为什么有了-IP-地址还需要-MAC-地址-🌟🌟🌟🌟"><a href="#为什么有了-IP-地址还需要-MAC-地址-🌟🌟🌟🌟" class="headerlink" title="为什么有了 IP 地址还需要 MAC 地址 🌟🌟🌟🌟"></a>为什么有了 IP 地址还需要 MAC 地址 🌟🌟🌟🌟</h2><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p>
<h2 id="私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗-🌟🌟🌟"><a href="#私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗-🌟🌟🌟" class="headerlink" title="私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗 🌟🌟🌟"></a>私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗 🌟🌟🌟</h2><p>当采用静态或者动态转换时，由于一个私网 IP 地址对应一个公网地址，因此经过转换之后的公网 IP 地址是不同的；而采用端口复用方式的话，在一个子网中的所有地址都采用一个公网地址，但是使用的端口是不同的。</p>
<h1 id="第六部分：物理层"><a href="#第六部分：物理层" class="headerlink" title="第六部分：物理层"></a>第六部分：物理层</h1><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ul>
<li>单工通信：也叫单向通信，发送方和接收方是固定的，消息只能单向传输。例如采集气象数据、家庭电费，网费等数据收集系统，或者打印机等应用主要采用单工通信。</li>
<li>半双工通信：也叫双向交替通信，通信双方都可以发送消息，但同一时刻同一信道只允许单方向发送数据。例如传统的对讲机使用的就是半双工通信。</li>
<li>全双工通信：也叫双向同时通信，全双工通信允许通信双方同时在两个方向是传输，其要求通信双方都具有独立的发送和接收数据的能力。例如平时我们打电话，自己说话的同时也能听到对面的声音。</li>
</ul>
<h1 id="第七部分：计算机网络中的安全"><a href="#第七部分：计算机网络中的安全" class="headerlink" title="第七部分：计算机网络中的安全"></a>第七部分：计算机网络中的安全</h1><h2 id="ARP-攻击"><a href="#ARP-攻击" class="headerlink" title="ARP 攻击"></a>ARP 攻击</h2><p>在 ARP 的解析过程中，局域网上的任何一台主机如果接收到一个 ARP 应答报文，并不会去检测这个报文的真实性，而是直接记入自己的 ARP 缓存表中。并且这个 ARP 表是可以被更改的，当表中的某一列长时间不适使用，就会被删除。ARP 攻击就是利用了这一点，攻击者疯狂发送 ARP 报文，其源 MAC 地址为攻击者的 MAC 地址，而源 IP 地址为被攻击者的 IP 地址。通过不断发送这些伪造的 ARP 报文，让网络内部的所有主机和网关的 ARP 表中被攻击者的 IP 地址所对应的 MAC 地址为攻击者的 MAC 地址。这样所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。通常可以把 ARP 欺骗分为以下几种：</p>
<ul>
<li>洪泛攻击</li>
</ul>
<p>攻击者恶意向局域网中的网关、路由器和交换机等发送大量 ARP 报文，设备的 CPU 忙于处理 ARP 协议，而导致难以响应正常的服务请求。其表现通常为：网络中断或者网速很慢。</p>
<ul>
<li>欺骗主机</li>
</ul>
<p>这种攻击方式也叫仿冒网关攻击。攻击者通过 ARP 欺骗使得网络内部被攻击主机发送给网关的信息实际上都发送给了攻击者，主机更新的 ARP 表中对应的 MAC 地址为攻击者的 MAC。当用户主机向网关发送重要信息使，该攻击方式使得用户的数据存在被窃取的风险。</p>
<ul>
<li>欺骗网关</li>
</ul>
<p>该攻击方式和欺骗主机的攻击方式类似，不过这种攻击的欺骗对象是局域网的网关，当局域网中的主机向网关发送数据时，网关会把数据发送给攻击者，这样攻击者就会源源不断地获得局域网中用户的信息。该攻击方式同样会造成用户数据外泄。</p>
<ul>
<li>中间人攻击</li>
</ul>
<p>攻击者同时欺骗网关和主机，局域网的网关和主机发送的数据最后都会到达攻击者这边。这样，网关和用户的数据就会泄露。</p>
<ul>
<li>IP 地址冲突</li>
</ul>
<p>攻击者对局域网中的主机进行扫描，然后根据物理主机的 MAC 地址进行攻击，导致局域网内的主机产生 IP 冲突，使得用户的网络无法正常使用。</p>
<h2 id="对称加密和非对称的区别，非对称加密有哪些"><a href="#对称加密和非对称的区别，非对称加密有哪些" class="headerlink" title="对称加密和非对称的区别，非对称加密有哪些"></a>对称加密和非对称的区别，非对称加密有哪些</h2><ul>
<li>加密和解密的过程不同：对称加密和解密过程使用同一个密钥；非对称加密中加密和解密采用公钥和私钥两个密钥，一般使用公钥进行加密，使用私钥进行解密。</li>
<li>加密和解密的速度不同：对称加密和解密速度较快，当数据量比较大时适合使用；非对称加密和解密时间较长，速度相对较慢，适合少量数据传输的场景。</li>
<li>传输的安全性不同：采用对称加密方式进行通信时，收发双方在数据传送前需要协定好密钥，而这个密钥还有可能被第三方窃听到的，一旦密钥泄漏，之后的通信就完全暴漏给攻击者了；非对称加密采用公钥加密和私钥解密的方式，其中私钥是基于不同的算法生成的随机数，公钥可以通过私钥通过一定的算法推导得出，并且私钥到公钥的推导过程是不可逆的，也就是说公钥无法反推导出私钥，即使攻击者窃听到传输的公钥，也无法正确解出数据，所以安全性较高。</li>
</ul>
<p>常见的非对称加密算法主要有：RSA、Elgamal、背包算法、Rabin、D-H 算法等等。<br>对称加密算法：AES</p>
<h2 id="RSA-和-AES-算法有什么区别"><a href="#RSA-和-AES-算法有什么区别" class="headerlink" title="RSA 和 AES 算法有什么区别"></a>RSA 和 AES 算法有什么区别</h2><ul>
<li><p><strong>RSA</strong><br>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，除此之外，由于需要大数的乘幂求模等运算，其运算速度较慢，不适合大量数据文件加密。</p>
</li>
<li><p><strong>AES</strong><br>采用对称加密的方式，其密钥长度最长只有 256 个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p>
</li>
</ul>
<p>基于上述两种算法的特点，一般使用 RSA 传输密钥给对方，之后使用 AES 进行加密通信。</p>
<h2 id="DDoS-有哪些，如何防范"><a href="#DDoS-有哪些，如何防范" class="headerlink" title="DDoS 有哪些，如何防范"></a>DDoS 有哪些，如何防范</h2><p>DDoS 为分布式拒绝服务攻击，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了不同位置上的多台机器并利用这些机器对受害者同时实施攻击。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机一起发起网络攻击。</p>
<p>DDoS 攻击主要有两种形式：流量攻击和资源耗尽攻击。前者主要针对网络带宽，攻击者和已受害主机同时发起大量攻击导致网络带宽被阻塞，从而淹没合法的网络数据包；后者主要针对服务器进行攻击，大量的攻击包会使得服务器资源耗尽或者 CPU 被内核应用程序占满从而无法提供网络服务。</p>
<p>常见的 DDos 攻击主要有：TCP 洪水攻击（SYN Flood）、放射性攻击（DrDos）、CC 攻击（HTTP Flood）等。</p>
<p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足网络带宽的前提下，我们应尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。此外，负载均衡，CDN 等技术都能够有效对抗 DDoS 攻击</p>
]]></content>
  </entry>
</search>
