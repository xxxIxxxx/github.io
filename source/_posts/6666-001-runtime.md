---
title: Runtime 相关知识
date: 2021-3-08 22:35
categories: [iOS 知识点]
tags: []
sticky: #9999
---

# 1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）

- **对象(实例)**
  OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object \*id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
- **类(Class)**
  1. 在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class \*Class.
  2. OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;
  3. 当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。
- **OC 对象、类、元类之间的关系**
  对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。
  ![OC 对象、类、元类之间的关系](https://files.catbox.moe/kj1q75.png)

# 2.为什么要设计 metaclass?

- 类对象、元类对象能够复用消息发送流程机制；
- 单一职责原则
  metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。

# 3.class_copyIvarList & class_copyPropertyList 区别

- **class_copyIvarList**
  会返回所有的成员变量，包括属性生成的成员变量。
  获取类对象中的所有实例变量信息，从 class_ro_t 中获取。
- **class_copyPropertyList**
  获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。

```
@interface ViewController ()
{
    NSString *_ddd;
    NSString *_ccc;
}
@property (nonatomic, copy) NSString *abc1;
@property (nonatomic, copy) NSString *abc2;
@end

/// class_copyIvarList
unsigned int count = 0;
Ivar * ivars = class_copyIvarList(self.class, &count);
for (unsigned int i = 0; i < count; i++) {
      const char *name = ivar_getName(ivars[i]);
      NSLog(@"name == %@",[NSString stringWithUTF8String:name]);
  }
free(ivars);
//name == _ddd
//name == _ccc
//name == _abc1
//name == _abc2


/// class_copyPropertyList
unsigned int outCount = 0;
objc_property_t *prs = class_copyPropertyList(self.class, &outCount);
for (unsigned int i = 0; i < outCount; i++) {
    const char *pname =  property_getName(prs[i]);
    NSLog(@"pname === %@",[NSString stringWithUTF8String:pname]);
}
free(prs);
//pname === abc1
//pname === abc2
```

# 4.class_rw_t 和 class_ro_t 的区别

- class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only

- class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write

# 5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序

+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看
分类添加到了 rw = cls->data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。

# 6.initialize && Load

```
+ (void)load {
    NSLog(@" load ");
}

+ (void)initialize
{
    if (self == [self class]) {
        NSLog(@" initialize ");
    }
}

```

load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，**如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。**。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。

不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。
调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。

# 7.category & extension 区别，能给 NSObject 添加 Extension 吗，结果如何

- category 可以给类添加方法和属性(需要借助 runtime)
- extension 可以给类添加成员变量和方法，但是是私有的在 .m 内。
- 不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m

# 8.在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么

OC 中的方法调用，编译后的代码最终都会转成 `objc_msgSend(id , SEL, ...)` 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用`_objc_msgForward(id, SEL, ...)`进行消息转发。

# 9.IMP、SEL、Method 的区别和使用场景

- IMP:IMP 定义为 `id (*IMP) (id, SEL, …)`。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。

- SEL:是“selector”的一个类型，表示一个方法的名字
- Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关

# 10.load、initialize 方法的区别什么？在继承关系中他们有什么区别

load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。

继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。

# 11.说说消息转发机制的优劣

- 优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。
- 劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。

## 消息转发三部曲

**1. 第一步动态添加一个实现方法。** 如果是实例对象会调用这个实例所属的类方法
`resolveInstanceMethod`，如果是类方法会调用`+ (BOOL)resolveClassMethod:(SEL)sel;`

我们可以动态的给该对象添加该方法。

```
+(BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(abc)) {
      //v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;
        class_addMethod(self, sel, (IMP)aaa, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}
// C 方法
void aaa (id self,SEL _cmd){
    NSLog(@"添加了");
}

```

**2. 消息转发，可以将消息转发给实现了该方法的对象。** 系统会调用下面的这个方法。

```
- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(abc)) {
      // 返回一个实现了该方法的对象
        return [SubViewController new];
    }
    return [super forwardingTargetForSelector:aSelector];
}
```

**3. 完整的消息转发**
先调用 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`
获取一个方法签名，如果没有返回一个有效的签名则直接调用
`- (void)doesNotRecognizeSelector:(SEL)aSelector;`抛出异常。
如果获取到则将签名包装成`NSInvocation`
传给`- (void)forwardInvocation:(NSInvocation *)anInvocation;`
进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。

```
// 返回一个方法签名
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(abc)) {
        // v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

// 如果返回了有效的签名将调用这个方法进行转发
- (void)forwardInvocation:(NSInvocation *)anInvocation {
    // 获取方法
    SEL selector = [anInvocation selector];

    // 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象
    // 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃

    SubViewController *subVC = [SubViewController new];
    if ([subVC respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:subVC];
    }

    ABC *abc = [ABC new];
    if ([abc respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:abc];
    }
}
```

# 12.weak 的实现原理？SideTable 的结构是什么样的

runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，
value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.
runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数
weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.

SideTable 结构

```
struct SideTable {
     spinlock_t slock;//操作SideTable时用到的自旋锁
     RefcountMap refcnts;//引用计数器的 map
     weak_table_t weak_table;//存放weak指针的哈希表
 };

```
