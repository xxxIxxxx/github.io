---
title: Runtime 相关知识
date: 2021-3-08 22:35
categories: [iOS 知识点]
tags: []
sticky: #9999
---

# 1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）

- **对象(实例)**
  OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object \*id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
- **类(Class)**
  1. 在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class \*Class.
  2. OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;
  3. 当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。
- **OC 对象、类、元类之间的关系**
  对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。
  ![OC 对象、类、元类之间的关系](https://files.catbox.moe/kj1q75.png)

# 2.为什么要设计 metaclass?

- 类对象、元类对象能够复用消息发送流程机制；
- 单一职责原则
  metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。

# 3.class_copyIvarList & class_copyPropertyList 区别

- **class_copyIvarList**
  会返回所有的成员变量，包括属性生成的成员变量。
  获取类对象中的所有实例变量信息，从 class_ro_t 中获取。
- **class_copyPropertyList**
  获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。

```
@interface ViewController ()
{
    NSString *_ddd;
    NSString *_ccc;
}
@property (nonatomic, copy) NSString *abc1;
@property (nonatomic, copy) NSString *abc2;
@end

/// class_copyIvarList
unsigned int count = 0;
Ivar * ivars = class_copyIvarList(self.class, &count);
for (unsigned int i = 0; i < count; i++) {
      const char *name = ivar_getName(ivars[i]);
      NSLog(@"name == %@",[NSString stringWithUTF8String:name]);
  }
free(ivars);
//name == _ddd
//name == _ccc
//name == _abc1
//name == _abc2


/// class_copyPropertyList
unsigned int outCount = 0;
objc_property_t *prs = class_copyPropertyList(self.class, &outCount);
for (unsigned int i = 0; i < outCount; i++) {
    const char *pname =  property_getName(prs[i]);
    NSLog(@"pname === %@",[NSString stringWithUTF8String:pname]);
}
free(prs);
//pname === abc1
//pname === abc2
```

# 4.class_rw_t 和 class_ro_t 的区别

- class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only

- class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write

# 5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序

+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看
分类添加到了 rw = cls->data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。

# 6.initialize && Load

```
+ (void)load {
    NSLog(@" load ");
}

+ (void)initialize
{
    if (self == [self class]) {
        NSLog(@" initialize ");
    }
}

```

load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，**如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。**。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。

不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。
调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。

# 7.category & extension 区别，能给 NSObject 添加 Extension 吗，结果如何

- category 可以给类添加方法和属性(需要借助 runtime
  `objc_setAssociatedObject(self, &redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);`
  及`objc_getAssociatedObject(self, &redXXKey);`)
- extension 可以给类添加成员变量和方法，但是是私有的在 .m 内。
- 不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m

# 8.在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么

OC 中的方法调用，编译后的代码最终都会转成 `objc_msgSend(id , SEL, ...)` 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用`_objc_msgForward(id, SEL, ...)`进行消息转发。

# 9.IMP、SEL、Method 的区别和使用场景

- IMP:IMP 定义为 `id (*IMP) (id, SEL, …)`。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。

- SEL:是“selector”的一个类型，表示一个方法的名字
- Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关

# 10.load、initialize 方法的区别什么？在继承关系中他们有什么区别

load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。

继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。

# 11.说说消息转发机制的优劣

- 优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。
- 劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。

## 消息转发三部曲

**1. 第一步动态添加一个实现方法。** 如果是实例对象会调用这个实例所属的类方法
`resolveInstanceMethod`，如果是类方法会调用`+ (BOOL)resolveClassMethod:(SEL)sel;`

我们可以动态的给该对象添加该方法。

```
+(BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(abc)) {
      //v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;
        class_addMethod(self, sel, (IMP)aaa, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}
// C 方法
void aaa (id self,SEL _cmd){
    NSLog(@"添加了");
}

```

**2. 消息转发，可以将消息转发给实现了该方法的对象。** 系统会调用下面的这个方法。

```
- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(abc)) {
      // 返回一个实现了该方法的对象
        return [SubViewController new];
    }
    return [super forwardingTargetForSelector:aSelector];
}
```

**3. 完整的消息转发**
先调用 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`
获取一个方法签名，如果没有返回一个有效的签名则直接调用
`- (void)doesNotRecognizeSelector:(SEL)aSelector;`抛出异常。
如果获取到则将签名包装成`NSInvocation`
传给`- (void)forwardInvocation:(NSInvocation *)anInvocation;`
进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。

```
// 返回一个方法签名
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(abc)) {
        // v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

// 如果返回了有效的签名将调用这个方法进行转发
- (void)forwardInvocation:(NSInvocation *)anInvocation {
    // 获取方法
    SEL selector = [anInvocation selector];

    // 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象
    // 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃

    SubViewController *subVC = [SubViewController new];
    if ([subVC respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:subVC];
    }

    ABC *abc = [ABC new];
    if ([abc respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:abc];
    }
}
```

# 12.weak 的实现原理？SideTable 的结构是什么样的

runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，
value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.
runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数
weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.

SideTable 结构

```
struct SideTable {
     spinlock_t slock;//操作SideTable时用到的自旋锁
     RefcountMap refcnts;//引用计数器的 map
     weak_table_t weak_table;//存放weak指针的哈希表
 };

```

# 13.关联对象的应用？系统如何实现关联对象的

- 应用：给 category 添加属性。
- 如何实现关联的？
  首先系统中有一个全局 AssociationsManager,里面有个 AssociationsHashMap 哈希表，哈希表中的 key 是对象的内存地址，value 是 ObjectAssociationMap,也是一个哈希表。
  ObjectAssociationMap 中的 key 是我们设置关联对象时所设置的唯一 key，value 是 ObjcAssociation,里面存放着关联对象设置的值和内存管理的策略。
  以`void objc_setAssociatedObject(id object, const void * key,id value, objc_AssociationPolicy policy)`为例，
  首先会通过 AssociationsManager 获取 AssociationsHashMap，然后以 object 的内存地址为 key，从 AssociationsHashMap 中取出 ObjectAssociationMap，若没有，则新创建一个 ObjectAssociationMap，
  然后通过 key 获取旧值，以及通过 key 和 policy 生成新值 ObjcAssociation(policy, new_value)，把新值存放到 ObjectAssociationMap 中，
  若新值不为 nil，并且内存管理策略为 retain，则会对新值进行一次 retain，若新值为 nil，则会删除旧值，若旧值不为空并且内存管理的策略是 retain，则对旧值进行一次 release.
- 其被释放的时候需要手动将所有的关联对象的指针置空么？
  对这个问题我的理解是：当对象被释放时，需要手动移除该对象所设置的关联对象吗？ 不需要，因为在对象的 dealloc 中，若发现对象有关联对象时，会调用`_object_remove_assocations` 方法来移除所有的关联对象，并根据内存策略，来判断是否需要对关联对象的值进行 release

```
@interface UIView (XX)
@property (nonatomic, copy) NSString *redXX;
@end


@implementation UIView (XX)
static char redXXKey;
- (void)setRedXX:(NSString *)redXX {
    // 被关联的对象、关联的key唯一、关联的对象、内存管理策略
    objc_setAssociatedObject(self, &redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
- (NSString *)redXX {
    return objc_getAssociatedObject(self, &redXXKey);
}
@end
```

# 14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性

在关联对象时又一个参数`objc_AssociationPolicy policy`设置内存管理策略
OBJC_ASSOCIATION_ASSIGN 类型的关联对象和 weak 有一定差别，而更加接近于 unsafe_unretained，
即当目标对象遭到摧毁时，属性值不会自动清空。
然后内部封装一个 weak 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil 操作。

# 15.Autoreleasepool 的原理？所使用的的数据结构是什么

- Autoreleasepool 是由多个 AutoreleasePoolPage 以双向链表的形式连接起来的。
- 释放时机: 当前 RunLoop 迭代结束时候释放。
- Autoreleasepool 的基本原理：在每个自动释放池创建的时候，会在当前的 AutoreleasePoolPage 中设置一个标记位，在此期间，当有对象调用 autorelsease 时，会把对象添加到 AutoreleasePoolPage 中，若当前页添加满了，会初始化一个新页，然后用双向量表链接起来，并把新初始化的这一页设置为 hotPage,当自动释放池 pop 时，从最下面依次往上 pop，调用每个对象的 release 方法，直到遇到标志位。
- AutoreleasePoolPage 结构如下

```
class AutoreleasePoolPage {
     magic_t const magic;
     id *next;//下一个存放autorelease对象的地址
     pthread_t const thread; //AutoreleasePoolPage 所在的线程
     AutoreleasePoolPage * const parent;//父节点
     AutoreleasePoolPage *child;//子节点
     uint32_t const depth;//深度,也可以理解为当前page在链表中的位置
     uint32_t hiwat;
 }
```

# 16.ARC 的实现原理？ARC 下对 retain & release 做了哪些优化

- Automatic Reference Counting，自动引用计数，即 ARC,ARC 会自动帮你插入 retain 和 release 语句,
  ARC 编译器有两部分，分别是前端编译器和优化器
- 前端编译器:前端编译器会为“拥有的”每一个对象插入相应的 release 语句。如果对象的所有权修饰符是`__strong`，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入 release 语句以销毁它。而类拥有的对象（实例变量/属性）会在 dealloc 方法内被释放。事实上，你并不需要写 dealloc 方法或调用父类的 dealloc 方法，ARC 会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的 release 语句的性能还要好，因为编辑器可以作出一些假设。在 ARC 中，没有类可以覆盖 release 方法，也没有调用它的必要。ARC 会通过直接使用 objc_release 来优化调用过程。而对于 retain 也是同样的方法。ARC 会调用 objc_retain 来取代保留消息
- ARC 优化器: 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对 retain 和 release 的重复调用。ARC 优化器负责移除多余的 retain 和 release 语句，确保生成的代码运行速度高于手动引用计数的代码

# 17.ARC 下哪些情况会造成内存泄漏

- 循环引用
- 注册通知，不移除

# 18. Method Swizzle 注意事项

如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议先添加：class_addMethod

```
AFNetworking 源码涉及代码
static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) {
    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);
    method_exchangeImplementations(originalMethod, swizzledMethod);
}

static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) {
    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));
}

+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass {
    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));
    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));

    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) {
        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));
    }

    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) {
        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));
    }
}
```

# 19. iOS 中内省的几个方法有哪些？内部实现原理是什么

对象在运行时获取其类型的能力称为内省

```
-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例
-(BOOL) isMemberOfClass:      判断是否是这个类的实例
-(BOOL) respondsToSelector:                      判读实例是否有这样方法
+(BOOL) instancesRespondToSelector:      判断类是否有这个方法
```
