---
title: Runtime 相关知识
date: 2021-3-08 22:35
categories: [iOS 知识点]
tags: []
sticky: #9999
---

# 1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）

- **对象(实例)**
  OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object \*id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
- **类(Class)**
  1. 在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class \*Class.
  2. OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;
  3. 当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。
- **OC 对象、类、元类之间的关系**
  对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。
  ![OC 对象、类、元类之间的关系](https://files.catbox.moe/kj1q75.png)

# 2.为什么要设计 metaclass?

- 类对象、元类对象能够复用消息发送流程机制；
- 单一职责原则
  metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。

# 3.class_copyIvarList & class_copyPropertyList 区别

- **class_copyIvarList**
  会返回所有的成员变量，包括属性生成的成员变量。
  获取类对象中的所有实例变量信息，从 class_ro_t 中获取。
- **class_copyPropertyList**
  获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。

```
@interface ViewController ()
{
    NSString *_ddd;
    NSString *_ccc;
}
@property (nonatomic, copy) NSString *abc1;
@property (nonatomic, copy) NSString *abc2;
@end

/// class_copyIvarList
unsigned int count = 0;
Ivar * ivars = class_copyIvarList(self.class, &count);
for (unsigned int i = 0; i < count; i++) {
      const char *name = ivar_getName(ivars[i]);
      NSLog(@"name == %@",[NSString stringWithUTF8String:name]);
  }
free(ivars);
//name == _ddd
//name == _ccc
//name == _abc1
//name == _abc2


/// class_copyPropertyList
unsigned int outCount = 0;
objc_property_t *prs = class_copyPropertyList(self.class, &outCount);
for (unsigned int i = 0; i < outCount; i++) {
    const char *pname =  property_getName(prs[i]);
    NSLog(@"pname === %@",[NSString stringWithUTF8String:pname]);
}
free(prs);
//pname === abc1
//pname === abc2
```

# 4.class_rw_t 和 class_ro_t 的区别

- class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only

- class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write

# 5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序

+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看
分类添加到了 rw = cls->data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。

# 6.initialize && Load

```
+ (void)load {
    NSLog(@" load ");
}

+ (void)initialize
{
    if (self == [self class]) {
        NSLog(@" initialize ");
    }
}

```

load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，**如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。**。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。

不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。
调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。

# 7.category & extension 区别，能给 NSObject 添加 Extension 吗，结果如何

- category 可以给类添加方法和属性(需要借助 runtime
  `objc_setAssociatedObject(self, &redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);`
  及`objc_getAssociatedObject(self, &redXXKey);`)
- extension 可以给类添加成员变量和方法，但是是私有的在 .m 内。
- 不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m

# 8.在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么

OC 中的方法调用，编译后的代码最终都会转成 `objc_msgSend(id , SEL, ...)` 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用`_objc_msgForward(id, SEL, ...)`进行消息转发。

# 9.IMP、SEL、Method 的区别和使用场景

- IMP:IMP 定义为 `id (*IMP) (id, SEL, …)`。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。

- SEL:是“selector”的一个类型，表示一个方法的名字
- Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关

# 10.load、initialize 方法的区别什么？在继承关系中他们有什么区别

load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。

继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。

# 11.说说消息转发机制的优劣

- 优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。
- 劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。

## 消息转发三部曲

**1. 第一步动态添加一个实现方法。** 如果是实例对象会调用这个实例所属的类方法
`resolveInstanceMethod`，如果是类方法会调用`+ (BOOL)resolveClassMethod:(SEL)sel;`

我们可以动态的给该对象添加该方法。

```
+(BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(abc)) {
      //v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;
        class_addMethod(self, sel, (IMP)aaa, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}
// C 方法
void aaa (id self,SEL _cmd){
    NSLog(@"添加了");
}

```

**2. 消息转发，可以将消息转发给实现了该方法的对象。** 系统会调用下面的这个方法。

```
- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(abc)) {
      // 返回一个实现了该方法的对象
        return [SubViewController new];
    }
    return [super forwardingTargetForSelector:aSelector];
}
```

**3. 完整的消息转发**
先调用 `- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`
获取一个方法签名，如果没有返回一个有效的签名则直接调用
`- (void)doesNotRecognizeSelector:(SEL)aSelector;`抛出异常。
如果获取到则将签名包装成`NSInvocation`
传给`- (void)forwardInvocation:(NSInvocation *)anInvocation;`
进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。

```
// 返回一个方法签名
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(abc)) {
        // v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    return [super methodSignatureForSelector:aSelector];
}

// 如果返回了有效的签名将调用这个方法进行转发
- (void)forwardInvocation:(NSInvocation *)anInvocation {
    // 获取方法
    SEL selector = [anInvocation selector];

    // 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象
    // 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃

    SubViewController *subVC = [SubViewController new];
    if ([subVC respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:subVC];
    }

    ABC *abc = [ABC new];
    if ([abc respondsToSelector:selector]) {
        [anInvocation invokeWithTarget:abc];
    }
}
```

# 12.weak 的实现原理？SideTable 的结构是什么样的

runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，
value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.
runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数
weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.

SideTable 结构

```
struct SideTable {
     spinlock_t slock;//操作SideTable时用到的自旋锁
     RefcountMap refcnts;//引用计数器的 map
     weak_table_t weak_table;//存放weak指针的哈希表
 };

```

# 13.关联对象的应用？系统如何实现关联对象的

- 应用：给 category 添加属性。
- 如何实现关联的？
  首先系统中有一个全局 AssociationsManager,里面有个 AssociationsHashMap 哈希表，哈希表中的 key 是对象的内存地址，value 是 ObjectAssociationMap,也是一个哈希表。
  ObjectAssociationMap 中的 key 是我们设置关联对象时所设置的唯一 key，value 是 ObjcAssociation,里面存放着关联对象设置的值和内存管理的策略。
  以`void objc_setAssociatedObject(id object, const void * key,id value, objc_AssociationPolicy policy)`为例，
  首先会通过 AssociationsManager 获取 AssociationsHashMap，然后以 object 的内存地址为 key，从 AssociationsHashMap 中取出 ObjectAssociationMap，若没有，则新创建一个 ObjectAssociationMap，
  然后通过 key 获取旧值，以及通过 key 和 policy 生成新值 ObjcAssociation(policy, new_value)，把新值存放到 ObjectAssociationMap 中，
  若新值不为 nil，并且内存管理策略为 retain，则会对新值进行一次 retain，若新值为 nil，则会删除旧值，若旧值不为空并且内存管理的策略是 retain，则对旧值进行一次 release.
- 其被释放的时候需要手动将所有的关联对象的指针置空么？
  对这个问题我的理解是：当对象被释放时，需要手动移除该对象所设置的关联对象吗？ 不需要，因为在对象的 dealloc 中，若发现对象有关联对象时，会调用`_object_remove_assocations` 方法来移除所有的关联对象，并根据内存策略，来判断是否需要对关联对象的值进行 release

```
@interface UIView (XX)
@property (nonatomic, copy) NSString *redXX;
@end


@implementation UIView (XX)
static char redXXKey;
- (void)setRedXX:(NSString *)redXX {
    // 被关联的对象、关联的key唯一、关联的对象、内存管理策略
    objc_setAssociatedObject(self, &redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
- (NSString *)redXX {
    return objc_getAssociatedObject(self, &redXXKey);
}
@end
```

# 14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性

在关联对象时又一个参数`objc_AssociationPolicy policy`设置内存管理策略
OBJC_ASSOCIATION_ASSIGN 类型的关联对象和 weak 有一定差别，而更加接近于 unsafe_unretained，
即当目标对象遭到摧毁时，属性值不会自动清空。
然后内部封装一个 weak 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil 操作。

# 15.Autoreleasepool 的原理？所使用的的数据结构是什么

- Autoreleasepool 是由多个 AutoreleasePoolPage 以双向链表的形式连接起来的。
- 释放时机: 当前 RunLoop 迭代结束时候释放。
- Autoreleasepool 的基本原理：在每个自动释放池创建的时候，会在当前的 AutoreleasePoolPage 中设置一个标记位，在此期间，当有对象调用 autorelsease 时，会把对象添加到 AutoreleasePoolPage 中，若当前页添加满了，会初始化一个新页，然后用双向量表链接起来，并把新初始化的这一页设置为 hotPage,当自动释放池 pop 时，从最下面依次往上 pop，调用每个对象的 release 方法，直到遇到标志位。
- AutoreleasePoolPage 结构如下

```
class AutoreleasePoolPage {
     magic_t const magic;
     id *next;//下一个存放autorelease对象的地址
     pthread_t const thread; //AutoreleasePoolPage 所在的线程
     AutoreleasePoolPage * const parent;//父节点
     AutoreleasePoolPage *child;//子节点
     uint32_t const depth;//深度,也可以理解为当前page在链表中的位置
     uint32_t hiwat;
 }
```

# 16.ARC 的实现原理？ARC 下对 retain & release 做了哪些优化

- Automatic Reference Counting，自动引用计数，即 ARC,ARC 会自动帮你插入 retain 和 release 语句,
  ARC 编译器有两部分，分别是前端编译器和优化器
- 前端编译器:前端编译器会为“拥有的”每一个对象插入相应的 release 语句。如果对象的所有权修饰符是`__strong`，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入 release 语句以销毁它。而类拥有的对象（实例变量/属性）会在 dealloc 方法内被释放。事实上，你并不需要写 dealloc 方法或调用父类的 dealloc 方法，ARC 会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的 release 语句的性能还要好，因为编辑器可以作出一些假设。在 ARC 中，没有类可以覆盖 release 方法，也没有调用它的必要。ARC 会通过直接使用 objc_release 来优化调用过程。而对于 retain 也是同样的方法。ARC 会调用 objc_retain 来取代保留消息
- ARC 优化器: 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对 retain 和 release 的重复调用。ARC 优化器负责移除多余的 retain 和 release 语句，确保生成的代码运行速度高于手动引用计数的代码

# 17.ARC 下哪些情况会造成内存泄漏

- 循环引用
- 注册通知，不移除

# 18. Method Swizzle 注意事项

如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议先添加：class_addMethod

```
AFNetworking 源码涉及代码
static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) {
    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);
    method_exchangeImplementations(originalMethod, swizzledMethod);
}

static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) {
    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));
}

+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass {
    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));
    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));

    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) {
        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));
    }

    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) {
        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));
    }
}
```

# 19. iOS 中内省的几个方法有哪些？内部实现原理是什么

对象在运行时获取其类型的能力称为内省

```
-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例
-(BOOL) isMemberOfClass:      判断是否是这个类的实例
-(BOOL) respondsToSelector:                      判读实例是否有这样方法
+(BOOL) instancesRespondToSelector:      判断类是否有这个方法
```

# 20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗

- 实现机制：atomic 是 property 的修饰词之一，表示是原子性的，使用方式为@property(atomic)int age;,此时编译器会自动生成 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法来进行存取属性。若此时属性用 atomic 修饰的话，在这两个方法内部使用 os_unfair_lock 来进行加锁，来保证读写的原子性。锁都在 PropertyLocks 中保存着（在 iOS 平台会初始化 8 个，mac 平台 64 个），在用之前，会把锁都初始化好，在需要用到时，用对象的地址加上成员变量的偏移量为 key，去 PropertyLocks 中去取。因此存取时用的是同一个锁，所以 atomic 能保证属性的存取时是线程安全的。注：由于锁是有限的，不用对象，不同属性的读取用的也可能是同一个锁

- 不能保证：atomic 在 getter/setter 方法中加锁，仅保证了存取时的线程安全，假设我们的属性是 @property(atomic)NSMutableArray \*array;可变的容器时,无法保证对容器的修改是线程安全的
- 在编译器自动生产的 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法存取属性，在此方法内部保证了读写时的线程安全的，当我们重写 getter/setter 方法时，就只能依靠自己在 getter/setter 中保证线程安全
- os_unfair_lock(互斥锁) 锁，iOS 10 之前使用 OSSpinLock(自旋锁)不能完全保证。
- OSSpinLock 忙等 是会一直循环等待，循环等待的时候会消耗 cpu 的性能
- os_unfair_lock 线程休眠，cpu 线程调度的时候会消耗 cpu 性能

# 21. class、objc_getClass、object_getclass 方法有什么区别?

- object_getClass:获得的是 isa 的指向
- self.class:当 self 是实例对象的时候，返回的是类对象，否则则返回自身。
- 类方法 class，返回的是 self，所以当查找 meta class 时，需要对类对象调用 object_getClass 方法

# 22.NSNotification

## 1. 通知的发送时同步的，还是异步的

同步发送

## 2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息

NSNotificationQueue

## 3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应

通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用 NSNotificationCenter 的发送接口进行发送通知，这么看 NSNotificationQueue 最终还是调用 NSNotificationCenter 进行消息的分发。

- 依赖 runloop，所以如果在其他子线程使用 NSNotificationQueue，需要开启 runloop
- 最终还是通过 NSNotificationCenter 进行发送通知，所以这个角度讲它还是同步的
- 所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程

## 4.如何保证通知接收的线程在主线程

使用 addObserverForName: object: queue: usingBlock 方法注册通知，指定在 mainqueue 上响应 block

## 5.下面的方式能接收到通知吗？为什么

```
// 发送通知
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@"TestNotification" object:@1];
// 接收通知
[NSNotificationCenter.defaultCenter postNotificationName:@"TestNotification" object:nil];
```

不会
存储是以 name 和 object 为维度的，即判定是不是同一个通知要从 name 和 object 区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的

# 23.runloop

## 1.app 如何接收到触摸事件的

### 1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)

- 指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。
- IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoad 进程。
- SpringBoard 进程因接收到触摸事件，将触摸事件交给前台 app 进程来处理。

### 2.APP 响应阶段

- APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。
- source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。
- source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 hit-testing，另外，此处开始便是与我们平时开发相关的工作了。
- 寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。
- 触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。

## 2.事件响应者链

这个传递的过程叫做 hit-Testing

- 事件是自上而下传递的即
  UIApplication -> UIWindow -> 子试图 -> ..->子试图中的子试图
- 后加试图响应程度更高，即最靠近我们的试图。

1. 首先调用当前视图的 pointInside:withEvent:方法判断触摸点是否在当前视图内
2. 若 pointInside:withEvent:方法返回 NO，说明触摸点不在当前视图内，则当前视图的 hitTest:withEvent:返回 nil
3. 若 pointInside:withEvent:方法返回 YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的 hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从 top 到 bottom，即从 subviews 数组的末尾向前遍历，直到有子视图的 hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕。
4. 若第一次有子视图的 hitTest:withEvent:方法返回非空对象,则当前视图的 hitTest:withEvent:方法就返回此对象，处理结束
5. 若所有子视图的 hitTest:withEvent:方法都返回 nil，则当前视图的 hitTest:withEvent:方法返回当前视图自身(self)

```
//判断点击的位置是不是在视图内
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
//返回点击的视图
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

```

```
- (UIView _)hitTest:(CGPoint)point withEvent:(UIEvent _)event{
  // 1. 前置条件要满足
   if (self.userInteractionEnabled == NO ||
  self.hidden == YES ||
   self.alpha <= 0.01) return nil;

  // 2. 判断点是否在视图内部 这是最起码的 note point 是在当前视图坐标系的点位置
  if ([self pointInside:point withEvent:event] == NO) return nil;

  // 3. 现在起码能确定当前视图能够是响应者 接下去询问子视图
  int count = (int)self.subviews.count;
  for (int i = count - 1; i >= 0; i--)
  {
  // 子视图
  UIView *childView = self.subviews[i];

   // 点需要先转换坐标系
   CGPoint childP = [self convertPoint:point toView:childView];
   // 子视图开始询问
  UIView *fitView = [childView hitTest:childP withEvent:event];
  if (fitView)
  {
  return fitView;
  }
  }

   return self;
  }

```

## 3.为什么只有主线程的 runloop 是开启的

- 主线程需要维持一份 RunLoop，保持 App 在 Main 后不会直接退出。
- 其他线程默认并没有调用 NSRunLoop \*runloop = [NSRunLoop currentRunLoop]

## 4.runloop 的 mode 作用是什么？

mode 主要是用来指定事件在运行循环中的优先级分为:

- NSDefaultRunLoopMode：默认，空闲状态
- UITrackingRunLoopMode: ScrollView 滑动
- UIInitializationRunloopMode: 启动时
- NSRunloopCommonModes：Mode 集合

苹果公开的有 2 个：
NSDefaultRunLoopMode
NSRunLoopCommonModes

定时在 scrollview 滑动时通过添加到 NSRunLoopCommonModes
`[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];`

## 5.为什么只在主线程刷新 UI

- UIKit 并不是一个 线程安全 的类，UI 操作涉及到渲染访问各种 View 对象的属性
- 如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度
- 另一方面因为整个程序的起点 UIApplication 是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以 view 只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以 60 帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。

## 6.PerformSelector 和 runloop 的关系

- perform 有几种方式，如 [self performSelector:@selector(perform) withObject:nil] 同步执行的，等同于 objc_msgSend 方法执行调用方法。

- `[self performSelector:@selector(perform) withObject:nil afterDelay:0]` 则是会在当前 runloop 中起一个 timer，如果当前线程没有起 runloop(也就是上面说的没有调用 `[NSRunLoop currentRunLoop]` 方法的话)，则不会有输出

## 7.如何使线程保活

线程保活就是不让线程退出，所以往简单说就是搞个 “while(1)” 自己实现一套处理流程，事件派发就可以了。
runloop 线程保活前提就是有事情要处理，这里指 timer，source0，source1 事件。

```
// Timer
NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
   NSLog(@"timer 定时任务");
}];
NSRunLoop *runloop = [NSRunLoop currentRunLoop];
[runloop addTimer:timer forMode:NSDefaultRunLoopMode];
[runloop run];
```

```
// Port
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
[runLoop run];
```

## 8.runloop 和线程有什么关系？

runloop 为线程而生，没有线程他就没有存在的必要。
runloop 是线程的基础架构部分，runloop 和线程是一一对应关系
主线程的 runloop 是默认启动的，其他线程的 runloop 是没有启动的，
如果你需要更多的线程交互则可以手动配置和启动。

# 24.KVO

## 1.KVO 实现原理

当你观察一个对象时，系统会动态的创建一个以 `NSKVONotifying_` 为前缀的类。
然后将被观察对象的 isa 指针指向这个新创建的类。
这个类继承自该对象的原本类，并重写了被观察属性的 setter 方法。
同时也会重写 class 方法，返回原先类对象，这样外部就无感知了。

重写所有要观察属性的 setter 方法，统一会走一个方法，
内部实现是 willChangeValueForKey 和 didChangevlueForKey 方法，
然后就是 observeValueForKey:ofObject:change:context:
通知所有观察对象值的更改。

## 2.如何手动关闭 KVO

```
+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {
    if ([key isEqualToString:@"closeType"]) {
        return NO;
    }else{
        return [super automaticallyNotifiesObserversForKey:key];
    }
}

-(void)setProperty:(NSString *)Property{

    if (_Property!=Property) {

        [self willChangeValueForKey:@"Property"];
        _Property=Property;
        [self didChangeValueForKey:@"Property"];
    }

}
```

## 3.通过 KVC 修改属性会触发 KVO 么

会触发 KVO 操作，KVC 时候会先查询对应的 getter 和 setter 方法。

## 4.KVC

KVC（key-value-codeing）键值编码 是通过一种字符串间接访问对象的方式（即给属性赋值）

- KVC 调用 getter 流程：getKEY，KEY，isKEY, \_KEY，接着是实例变量 \_KEY,\_isKEY, KEY, isKEY;

- KVC 调用 setter 流程：setKEY 和 \_setKEY，实例变量顺序 \_KEY,\_isKEY, KEY, isKEY，没找到就调用 setValue: forUndefinedKey: 当一个对象调用 setValue 方法时，方法内部会做以下操作

1. 检查是否存在相应的 key 的 set 方法，存在就调用 set 方法
2. 如果 set 方法不存在就找带下划线的成员变量，如果有就直接给成员变量属性赋值。
3. 如果没有找到\_key 就会找相同属性名的 key，有就直接赋值
4. 如果还没找到，就调用 valueForUndefinedKey:和 setValue:forUndefinedKey:方法。这些方法就抛出异常崩溃了。

## 5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃

1. 添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context:方法，导致崩溃；
2. 添加或者移除时 keypath == nil，导致崩溃；
3. 多次重复移除同一个属性，移除了未注册的观察者

## 6.KVO/KVC 的优缺点？

- KVC
  优点：没有 property 的变量（私有）也能通过 KVC 进行设置，或者简化代码（多级属性）
  缺点：如果 key 只写错，编写的时候不会报错，但是运行的时候会报错
- KVO 优点：
  能够提供一种简单的方法实现两个对象的同步；
  能够对内部对象的状态改变作出响应，而且不需要改变内部对象的实现；
  能够提供被观察者属性的最新值和之前的值；
  使用 key Path 来观察属性，因此可以观察嵌套对象；
  完成了对观察对象的抽象，因为不需要额外的代码来允许观察者被观察。
- KVO 缺点：
  KVO 只能检测类中的属性，并且属性名都是通过 NSString 来查找，编译器不会补全（编译时不会出现警告），容易写错；
  对属性重构，将导致观察代码不可用；
  复杂的 “if” 语句要求对象正在观察多个值，是因为所有的观察代码通过一个方法来指向；
