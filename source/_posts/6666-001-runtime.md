---
title: Runtime 相关知识
date: 2021-3-08 22:35
categories: [iOS 知识点]
tags: []
sticky: #9999
---

# 1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）

- **对象(实例)**
  OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object \*id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
- **类(Class)**
  1. 在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class \*Class.
  2. OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;
  3. 当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。
- **OC 对象、类、元类之间的关系**
  对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。
  ![OC 对象、类、元类之间的关系](https://files.catbox.moe/kj1q75.png)

# 2.为什么要设计 metaclass?

- 类对象、元类对象能够复用消息发送流程机制；
- 单一职责原则
  metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。
