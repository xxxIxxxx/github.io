<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-17T07:34:52.487Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简述 JWT 的原理和校验机制</title>
    <link href="http://example.com/2021/02/17/1000-014%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/02/17/1000-014%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-17T07:10:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。"><a href="#JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。" class="headerlink" title="JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。"></a>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。</h1><h1 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h1 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGcio1JIUZIINiIsInR5CCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIioiIxMiMONTY30DkwIiwibmFtZSI6IkpvaG4</span><br><span class="line">gRG9IIiwiaXNTb2NpYWwiOnRydWv9.</span><br><span class="line">4pcPyMD09oIPSyXnrXCjTwXyr4BsezdI1AVTmud2fU4</span><br></pre></td></tr></table></figure><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是下面的样子。<br><code>Header.Payload.Signature</code></p><h2 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h2 id="Payload（负载）"><a href="#Payload（负载）" class="headerlink" title="Payload（负载）"></a>Payload（负载）</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h2 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。<br><code>Authorization: Bearer &lt;token&gt;</code><br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。<br>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><blockquote><p>摘录于 <a class="link"   href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" >https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。&quot;&gt;&lt;a href=&quot;#JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。&quot; class=&quot;headerlink&quot; title=&quot;JSON Web Token（缩</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="JWT" scheme="http://example.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的方法有哪些？</title>
    <link href="http://example.com/2021/02/17/1000-013HTTP%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2021/02/17/1000-013HTTP%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2021-02-17T06:45:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h1><p>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p><h1 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h1><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </p><h1 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h1><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p><h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>DELETE方法删除指定的资源。</p><h1 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h1><p>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p><h1 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h1><p>OPTIONS方法用于描述目标资源的通信选项。</p><h1 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h1><p>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</p><h1 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h1><p>PATCH方法用于对资源应用部分修改。</p><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为HTTP动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享：: 例如一个请求方法可以是 safe(安全), idempotent(幂等), 或 cacheable(可缓存).</p><h2 id="safe-安全"><a href="#safe-安全" class="headerlink" title="safe(安全)"></a>safe(安全)</h2><p>如果说一个 HTTP 方法是安全的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD 和 OPTIONS。所有安全的方法都是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是。</p><h2 id="idempotent-幂等"><a href="#idempotent-幂等" class="headerlink" title="idempotent(幂等)"></a>idempotent(幂等)</h2><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p><h2 id="cacheable-可缓存"><a href="#cacheable-可缓存" class="headerlink" title="cacheable(可缓存)"></a>cacheable(可缓存)</h2><p>可缓存的响应是可被缓存的HTTP 响应，它被存储以供稍后检索和使用，从而将新的请求保存在伺服器。不是所有的 HTTP 响应都可以被缓存，可以被缓存的 HTTP 响应需满足如下列条件:</p><ul><li>请求中使用的方法本身是可以被缓存的，如 GET 或 HEAD 方法。如果下达了新的指示，响应 POST 方法也可以被缓存，但这种实施方式极为罕见。其他方法，如： PUT 或 DELETE 都不可以被缓存，同样他们的处理结果也不可以。</li><li>应用程式是会缓存已知的响应的状态码，并且被认为是可缓存的。这些可缓存的状态码如下： 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 和 501.</li><li>响应中没有指定的头部，如 Cache-Control，它可以阻止缓存。<br>请注意一些不缓存请求/响应到指定的 URI 可能会导致相同 URI 上以前的缓存响应失效。例如，  PUT 到 pageX.html 将使相同 URI 下所有的 GET 或 HEAD 请求缓存失效。</li></ul><blockquote><p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GET&quot;&gt;&lt;a href=&quot;#GET&quot; class=&quot;headerlink&quot; title=&quot;GET&quot;&gt;&lt;/a&gt;GET&lt;/h1&gt;&lt;p&gt;GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.&lt;/p&gt;
&lt;h1 id=&quot;HEAD&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>简述对称与非对称加密的概念</title>
    <link href="http://example.com/2021/02/16/1000-012%E7%AE%80%E8%BF%B0%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/02/16/1000-012%E7%AE%80%E8%BF%B0%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-16T09:30:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密是最快速、最简单的一种加密方式，加密与解密用的是同样的密钥。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p><p><strong>密钥交换的发送过程中有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</strong></p><h2 id="对称加密常用算法"><a href="#对称加密常用算法" class="headerlink" title="对称加密常用算法"></a>对称加密常用算法</h2><ol><li><strong>DES（Data Encryption Standard）</strong>：数据加密标准，速度较快，适用于加密大量数据的场合；</li><li><strong>3DES（Triple DES）</strong>：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li><li><strong>AES（Advanced Encryption Standard）</strong>：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密；</li></ol><h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><ol><li>加密方和解密方使用同一个密钥；</li><li>加密解密的速度比较快，适合数据比较长时的使用；</li><li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</li></ol><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p><h2 id="非对称加密常用算法"><a href="#非对称加密常用算法" class="headerlink" title="非对称加密常用算法"></a>非对称加密常用算法</h2><p>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。</p><p>使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。</p><h1 id="MD5-单向加密算法不可解密，属于散列算法。"><a href="#MD5-单向加密算法不可解密，属于散列算法。" class="headerlink" title="MD5 单向加密算法不可解密，属于散列算法。"></a>MD5 单向加密算法不可解密，属于散列算法。</h1><h1 id="Base64-是编码。"><a href="#Base64-是编码。" class="headerlink" title="Base64 是编码。"></a>Base64 是编码。</h1><blockquote><p>对称加密与非对称加密 <a class="link"   href="https://zhuanlan.zhihu.com/p/30573146" >https://zhuanlan.zhihu.com/p/30573146<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" >https://baike.baidu.com/item/对称加密<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h1&gt;&lt;p&gt;对称加密是最快速、最简单的一种加密方式，加密与解密用的是同样的密钥。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="加密" scheme="http://example.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>什么是 TCP 粘包和拆包？</title>
    <link href="http://example.com/2021/02/14/1000-011%E4%BB%80%E4%B9%88%E6%98%AF%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F/"/>
    <id>http://example.com/2021/02/14/1000-011%E4%BB%80%E4%B9%88%E6%98%AF%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F/</id>
    <published>2021-02-14T03:50:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-粘包和拆包"><a href="#TCP-粘包和拆包" class="headerlink" title="TCP 粘包和拆包"></a>TCP 粘包和拆包</h1><p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况。</p><ol><li><p>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，<strong>没有粘包和拆包</strong>；</p></li><li><p>服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，<strong>被称为 TCP 粘包</strong>；</p></li><li><p>服务端分两次读取到了两个数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，<strong>这被称为 TCP 拆包</strong>；</p></li><li><p>服务端分两次读取到了两个数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。<br>如果此时服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2 比较大，很有可能会发生第五种可能，即<strong>服务端分多次才能将 D1 和 D2 包接收完全，期间发生多次拆包</strong>。</p></li></ol><h1 id="TCP粘包-拆包发生的原因"><a href="#TCP粘包-拆包发生的原因" class="headerlink" title="TCP粘包/拆包发生的原因"></a>TCP粘包/拆包发生的原因</h1><ol><li><p>应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</p></li><li><p>进行 MSS 大小的 TCP 分段；</p></li><li><p>以太网帧的 payload 大于 MTU 进行 IP 分片。</p></li></ol><h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>泛指通讯协议中的最大传输单元。一般用来说明TCP/IP四层协议中数据链路层的最大传输单元，不同类型的网络MTU也会不同，我们普遍使用的以太网的MTU是1500，即最大只能传输1500字节的数据帧。可以通过ifconfig命令查看电脑各个网卡的MTU。</p><h1 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h1><p>指TCP建立连接后双方约定的可传输的最大TCP报文长度，是TCP用来限制应用层可发送的最大字节数。如果底层的MTU是1500byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-粘包和拆包&quot;&gt;&lt;a href=&quot;#TCP-粘包和拆包&quot; class=&quot;headerlink&quot; title=&quot;TCP 粘包和拆包&quot;&gt;&lt;/a&gt;TCP 粘包和拆包&lt;/h1&gt;&lt;p&gt;假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>简述 OSI 七层模型，TCP，IP 属于哪一层？</title>
    <link href="http://example.com/2021/02/13/1000-010%E7%AE%80%E8%BF%B0%20OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8CTCP%EF%BC%8CIP%20%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F/"/>
    <id>http://example.com/2021/02/13/1000-010%E7%AE%80%E8%BF%B0%20OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8CTCP%EF%BC%8CIP%20%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F/</id>
    <published>2021-02-13T09:35:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://img.rruu.net/image/6027a373e47f9"                                     ></p><h1 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h1><p>1.应用层 2.传输层 3.网络层 4.网络接口层</p><h1 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h1><p>1.应用层 2.传输层 3.网络层 4.数据链路层 5.物理层</p><h1 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h1><p>1.物理层 2.数据链路层 3.网络层 4.传输层 5.会话层 6.表示层 7.应用层</p><h1 id="IP-协议属于网络层"><a href="#IP-协议属于网络层" class="headerlink" title="IP 协议属于网络层"></a>IP 协议属于网络层</h1><h1 id="TCP-协议属于传输层"><a href="#TCP-协议属于传输层" class="headerlink" title="TCP 协议属于传输层"></a>TCP 协议属于传输层</h1><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h2><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p><h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h2><p>最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。</p><ol><li>基本数据单位为帧；</li><li>主要的协议：以太网协议；</li><li>两个重要设备名称：网桥和交换机。</li></ol><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h2><p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是”路径选择、路由及逻辑寻址”。<br>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。</p><ol><li>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</li><li>基本数据单位为IP数据报；</li><li>包含的主要协议：<br>　　IP协议（Internet Protocol，因特网互联协议）;<br>　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;<br>　　ARP协议（Address Resolution Protocol，地址解析协议）;<br>　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</li><li>重要的设备：路由器。</li></ol><h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h2><p>传输层要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p><ol><li>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题</li><li>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）</li><li>重要设备：网关</li></ol><h2 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h2><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><h2 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h2><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><h2 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h2><p>为操作系统或网络应用程序提供访问网络服务的接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://img.rruu.net/i</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="七层模型" scheme="http://example.com/tags/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</title>
    <link href="http://example.com/2021/02/12/1000-009DNS%20%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDNS%20%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2021/02/12/1000-009DNS%20%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDNS%20%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-02-12T07:00:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-查询服务器的基本流程"><a href="#DNS-查询服务器的基本流程" class="headerlink" title="DNS 查询服务器的基本流程"></a>DNS 查询服务器的基本流程</h1><p><strong>查询顺序：</strong>浏览器缓存–&gt; 操作系统缓存–&gt; 本地 host 文件 –&gt; 路由器缓存–&gt; ISP DNS 缓存 –&gt; 顶级 DNS 服务器/根 DNS 服务器</p><p><strong>1. 浏览器缓存：</strong> 首先会向浏览器的缓存中读取上一次访问的记录，在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看缓存的当前状态 。</p><p><strong>2. 操作系统缓存：</strong> 查找存储在系统运行内存中的缓存。在 mac 中可以通过下面的命令清除系统中的 DNS 缓存。<br><code>dscacheutil -flushcache</code></p><p><strong>3. 本地 host 文件：</strong> 查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p><p><strong>4. 路由器缓存：</strong> 有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</p><p><strong>5. ISP DNS 缓存：</strong> 互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</p><p><strong>6. 顶级 DNS 服务器 / 根 DNS 服务器：</strong> 根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（baidu.com），本机继续查找，直到服务器找到(<a class="link"   href="http://www.baidu.com)的主机./" >www.baidu.com)的主机。<i class="fas fa-external-link-alt"></i></a><br>最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/t5awpd.png"                      alt="过程图"                ></p><p>上述图片是查找 <a class="link"   href="http://www.google.com/" >www.google.com<i class="fas fa-external-link-alt"></i></a> 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是</a> <a class="link"   href="http://www.google.com.,并不是我多打了一个.,这个.对应的就是根域名服务器,默认情况下所有的网址的最后一位都是.,既然是默认情况下,为了方便用户,通常都会省略,浏览器在请求/" >www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求<i class="fas fa-external-link-alt"></i></a> DNS 的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; <a class="link"   href="http://www.google.com../" >www.google.com.。<i class="fas fa-external-link-alt"></i></a></p><h1 id="什么是-DNS-劫持？"><a href="#什么是-DNS-劫持？" class="headerlink" title="什么是 DNS 劫持？"></a>什么是 DNS 劫持？</h1><p>在 DNS 的解析中返回了一个假的 IP 地址给客户端，从而促使用户访问了错误的网站。</p><h1 id="DNS-劫持的方法"><a href="#DNS-劫持的方法" class="headerlink" title="DNS 劫持的方法"></a>DNS 劫持的方法</h1><p><strong>1. 本机 DNS 劫持</strong><br>攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地 DNS 配置，比如修改本地 hosts 文件，缓存等<br><strong>2. 路由 DNS 劫持</strong><br>很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置<br><strong>3.攻击 DNS 服务器</strong><br>直接攻击 DNS 服务器，例如对 DNS 服务器进行 DDOS 攻击，可以是 DNS 服务器宕机，出现异常请求，还可以利用某些手段感染 dns 服务器的缓存，使给用户返回来的是恶意的 ip 地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DNS-查询服务器的基本流程&quot;&gt;&lt;a href=&quot;#DNS-查询服务器的基本流程&quot; class=&quot;headerlink&quot; title=&quot;DNS 查询服务器的基本流程&quot;&gt;&lt;/a&gt;DNS 查询服务器的基本流程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;查询顺序：&lt;/strong&gt;</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="DNS" scheme="http://example.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>UDP 有拥塞控制吗？</title>
    <link href="http://example.com/2021/02/11/1000-008UDP/"/>
    <id>http://example.com/2021/02/11/1000-008UDP/</id>
    <published>2021-02-11T06:05:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP-有拥塞控制吗？"><a href="#UDP-有拥塞控制吗？" class="headerlink" title="UDP 有拥塞控制吗？"></a>UDP 有拥塞控制吗？</h1><ol><li><strong>UDP 没有拥塞控制</strong>，网络出现拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。</li><li>UDP 支持一对一、一对多和多对的的交互通信。</li><li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ol><h1 id="TCP-与-UDP-的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。"><a href="#TCP-与-UDP-的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。" class="headerlink" title="TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。"></a>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</h1><h1 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h1><p>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及查错检测的功能。</p><h1 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h1><ol><li>UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表</li><li>UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li></ol><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><ol><li>某些实时应用需要使用没有拥塞控制的 UDP，但很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，导致大家都无法正常接收。</li><li>还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠传输进行适当的改进，以减少数据的丢失。应用进程可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文</li></ol><blockquote><p><a class="link"   href="https://developer.aliyun.com/article/699136" >https://developer.aliyun.com/article/699136<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.runoob.com/w3cnote/summary-of-network.html#_label7" >https://www.runoob.com/w3cnote/summary-of-network.html#_label7<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UDP-有拥塞控制吗？&quot;&gt;&lt;a href=&quot;#UDP-有拥塞控制吗？&quot; class=&quot;headerlink&quot; title=&quot;UDP 有拥塞控制吗？&quot;&gt;&lt;/a&gt;UDP 有拥塞控制吗？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;UDP 没有拥塞控制&lt;/strong&gt;，</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="UDP" scheme="http://example.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>简述常见的 HTTP 状态码的含义（301，304，401，403）</title>
    <link href="http://example.com/2021/02/10/1000-007%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%20HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88301%EF%BC%8C304%EF%BC%8C401%EF%BC%8C403%EF%BC%89/"/>
    <id>http://example.com/2021/02/10/1000-007%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%20HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88301%EF%BC%8C304%EF%BC%8C401%EF%BC%8C403%EF%BC%89/</id>
    <published>2021-02-10T10:00:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3** 重定向"></a>3** 重定向</h1><p><strong>300 Multiple Choice</strong><br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p><p><strong>301 Moved Permanently</strong><br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><p><strong>304 Not Modified</strong><br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p><p><strong>302 Found</strong><br>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p><p><strong>303 See Other</strong><br>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</p><h1 id="4-客户端响应"><a href="#4-客户端响应" class="headerlink" title="4** 客户端响应"></a>4** 客户端响应</h1><p><strong>400 Bad Request</strong><br>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。</p><p><strong>401 Unauthorized</strong><br>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</p><p><strong>403 Forbidden</strong><br>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</p><p><strong>404 Not Found</strong><br>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p><p><strong>405 Method Not Allowed</strong><br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p><h1 id="5-服务端响应"><a href="#5-服务端响应" class="headerlink" title="5** 服务端响应"></a>5** 服务端响应</h1><p><strong>500 Internal Server Error</strong><br>服务器遇到了不知道如何处理的情况。</p><p><strong>501 Not Implemented</strong><br>此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。</p><p><strong>502 Bad Gateway</strong><br>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</p><p><strong>503 Service Unavailable</strong><br>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</p><h1 id="2-成功响应"><a href="#2-成功响应" class="headerlink" title="2** 成功响应"></a>2** 成功响应</h1><p><strong>200 OK</strong><br>请求成功。成功的含义取决于 HTTP 方法：<br>GET：资源已被提取并在消息正文中传输。<br>HEAD：实体标头位于消息正文中。<br>POST：描述动作结果的资源在消息体中传输。<br>TRACE：消息正文包含服务器收到的请求消息</p><p><strong>201 Created</strong><br>该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</p><p><strong>202 Accepted</strong><br>请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</p><p><strong>203 Non-Authoritative Information</strong><br>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。</p><h1 id="1-信息响应"><a href="#1-信息响应" class="headerlink" title="1** 信息响应"></a>1** 信息响应</h1><p><strong>100 Continue</strong><br>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p><p><strong>101 Switching Protocol</strong><br>该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。<br><strong>102 Processing (WebDAV)</strong><br>此代码表示服务器已收到并正在处理该请求，但没有响应可用。<br><strong>103 Early Hints</strong><br>此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 </p><blockquote><p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-重定向&quot;&gt;&lt;a href=&quot;#3-重定向&quot; class=&quot;headerlink&quot; title=&quot;3** 重定向&quot;&gt;&lt;/a&gt;3** 重定向&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;300 Multiple Choice&lt;/strong&gt;&lt;br&gt;被请求的资源有一系列可供选择</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="状态码" scheme="http://example.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>什么是跨域，什么情况下会发生跨域请求？</title>
    <link href="http://example.com/2021/02/09/1000-006%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F/"/>
    <id>http://example.com/2021/02/09/1000-006%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F/</id>
    <published>2021-02-09T12:00:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h1><p>在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是跨域请求。</p><p>跨域的情况有：<br>同一域名不同端口<br>同一域名不同协议<br>域名不同 ip 相同<br>主域相同子域不同<br>不同域名</p><h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><ol><li>通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>location.hash + iframe</li><li>window.name + iframe跨域</li><li>postMessage跨域</li><li>跨域资源共享（CORS）</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li><li>WebSocket协议跨域</li></ol><blockquote><p>摘录于 <a class="link"   href="https://cloud.tencent.com/developer/article/1175899" >https://cloud.tencent.com/developer/article/1175899<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是跨域，什么情况下会发生跨域请求？&quot;&gt;&lt;a href=&quot;#什么是跨域，什么情况下会发生跨域请求？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域，什么情况下会发生跨域请求？&quot;&gt;&lt;/a&gt;什么是跨域，什么情况下会发生跨域请求？&lt;/h1&gt;&lt;p&gt;在浏</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="跨域" scheme="http://example.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 与 HTTPS 有哪些区别？</title>
    <link href="http://example.com/2021/02/08/1000-005HTTP%20%E4%B8%8E%20HTTPS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2021/02/08/1000-005HTTP%20%E4%B8%8E%20HTTPS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2021-02-08T12:10:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1><ol><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ol><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ol><li>HyperText Transfer Protocol：超文本传输协议。</li><li>是一种用于分布式、协作式和超媒体信息系统的应用层协议。</li><li>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</li><li>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><ol><li>Hypertext Transfer Protocol Secure：安全的超文本传输协议。</li><li>是一种透过计算机网络进行安全通信的传输协议。</li><li>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。</li><li>HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</li><li>HTTPS 默认工作在 TCP 协议443端口</li></ol><h1 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h1><p><strong>1. 客户端发起 HTTPS 请求</strong><br><strong>2. 服务端的配置</strong><br>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p><strong>3. 传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><p><strong>4. 客户端解析证书</strong><br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p><strong>5. 传送加密信息</strong><br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p><strong>6. 服务端解密信息</strong><br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p><strong>7. 传输加密后的信息</strong><br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p><strong>8. 客户端解密信息</strong><br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p><blockquote><p>摘录于 <a class="link"   href="https://www.runoob.com/w3cnote/http-vs-https.html" >https://www.runoob.com/w3cnote/http-vs-https.html<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-与-HTTPS-区别&quot;&gt;&lt;a href=&quot;#HTTP-与-HTTPS-区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP 与 HTTPS 区别&quot;&gt;&lt;/a&gt;HTTP 与 HTTPS 区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HTTP 明文传输，数据</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTPS" scheme="http://example.com/tags/HTTPS/"/>
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</title>
    <link href="http://example.com/2021/02/07/1000-004%E7%AE%80%E8%BF%B0%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F/"/>
    <id>http://example.com/2021/02/07/1000-004%E7%AE%80%E8%BF%B0%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F/</id>
    <published>2021-02-07T12:10:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><blockquote><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p></blockquote><p><strong>第一次握手：</strong> 客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><strong>第二次握手：</strong> 服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><strong>第三次握手：</strong> 客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><blockquote><p>关闭时，发包顺序不一定。一般来说是客户端主动发起的关闭，过程如下。</p></blockquote><p><strong>第一次挥手：</strong> 当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p><p><strong>第二次挥手：</strong> 主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p><p><strong>第三次挥手：</strong> 主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p><p><strong>第四次挥手：</strong> 主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p><h1 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h1><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="三次握手" scheme="http://example.com/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
    <category term="四次挥手" scheme="http://example.com/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>树、二叉树</title>
    <link href="http://example.com/2021/02/06/2000-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/02/06/2000-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-06T13:00:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote><p>是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图</p></blockquote><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><blockquote><p>是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p></blockquote><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉树遍历" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>简述 HTTPS 的加密与认证过程</title>
    <link href="http://example.com/2021/02/06/1000-003%E7%AE%80%E8%BF%B0%20HTTPS%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/02/06/1000-003%E7%AE%80%E8%BF%B0%20HTTPS%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</id>
    <published>2021-02-06T11:50:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><ul><li><p>共享/对称密钥加密：客户端和服务端使用相同的密钥加密，缺陷：发送密钥有被窃听的风险，但不发送，对方就不能解密。如果密钥能够安全发送，那么数据也能安全送达，就无需加密。</p></li><li><p> 公开密钥加密：非对称加密，一把私钥，一把公钥，成对。首先，发送公钥给加密方，发送密文一方使用对方的公钥进行加密，对方收到密文后，使用自己的私钥进行解密。</p></li><li><p>混合加密：使用公开密钥加密方式传递共享密钥，再使用共享密钥加密传递的数据</p></li></ul><h1 id="证书的正确性：CA（数字认证机构）颁发的公开密钥证书"><a href="#证书的正确性：CA（数字认证机构）颁发的公开密钥证书" class="headerlink" title="证书的正确性：CA（数字认证机构）颁发的公开密钥证书"></a>证书的正确性：CA（数字认证机构）颁发的公开密钥证书</h1><ul><li>服务器把自己的公钥登录至CA进行认证；</li><li>CA机构使用自己的私钥给服务器的公钥署数字签名并颁发公钥证书；</li><li>客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥（事先植入到浏览器客户端），向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性；</li><li>使用服务器的公开密钥对报文加密并发送</li></ul><h1 id="SSL-TLS握手协议"><a href="#SSL-TLS握手协议" class="headerlink" title="SSL/TLS握手协议"></a>SSL/TLS握手协议</h1><ul><li>客户端给出协议版本号，一个随机数（client random），以及客户端支持的加密方式；</li><li>服务端确认双方使用的加密方式，并给出数字证书，以及一个服务器生成的随机数（server random）；</li><li>客户端确认证书有效，然后生成一个新的随机数（premaster secret），并使用数字证书的公钥加密这个随机数，发送给服务端；</li><li>服务端使用自己的私钥，获得客户端发送的随机数（premaster secret）;</li><li>客户端和服务端，根据约定的加密方式，使用前面的三个随机数，生成一个对话密钥（session key）,及共享密钥，然后使用该密钥加密整个数据交互过程。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;加密&quot;&gt;&lt;a href=&quot;#加密&quot; class=&quot;headerlink&quot; title=&quot;加密&quot;&gt;&lt;/a&gt;加密&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;共享/对称密钥加密：客户端和服务端使用相同的密钥加密，缺陷：发送密钥有被窃听的风险，但不发送，对方就不能解密。如果密钥能够</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTPS" scheme="http://example.com/tags/HTTPS/"/>
    
    <category term="SSL/TLS" scheme="http://example.com/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>TCP 中常见的拥塞控制算法有哪些？</title>
    <link href="http://example.com/2021/02/05/1000-002TCP%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2021/02/05/1000-002TCP%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2021-02-05T12:00:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h1><h1 id="TCP-Tahoe-Reno"><a href="#TCP-Tahoe-Reno" class="headerlink" title="TCP Tahoe/Reno"></a>TCP Tahoe/Reno</h1><p>最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout/RTO）和重复确认为条件判断是否发生了丢包。两者的区别在于：Tahoe算法下如果收到三次重复确认，就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；而Reno算法如果收到三次重复确认，就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。<br>而Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。</p><h1 id="TCP-Vegas"><a href="#TCP-Vegas" class="headerlink" title="TCP Vegas"></a>TCP Vegas</h1><p>TCP Vegas算法由 Lawrence Brakmo 和 Larry L. Peterson 在1994年提出，它和其他拥塞控制算法的不同之处在于Vegas算法并不急于丢包来判断是否发生了拥塞，而是通过数据包延迟来判断。Vegas通过RTT（roundtrip time）来决定增加或者减小拥塞窗口，它能够将拥塞要发生时就避免拥塞，而不是等到拥塞已经发生之后再减小发送速度，因此能够减小重传和超时的几率。Vegas算法与其他算法（比如Reno）共存时，会由于比其他算法更先降低发送速率而出现公平性问题。</p><h1 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h1><p> TCP New Reno主要改进了TCP Reno中快速恢复阶段的重传。<br>在Reno的快恢复中，一旦出现3次重复确认，TCP发送方会重发数据包并设置定时器等待该重发数据包被确认。当重发的数据包被确认后，就立即退出快速恢复阶段，进入拥塞控制阶段。但如果一次拥塞中出现多个丢包，Reno会误以为发生了多次拥塞而重复减小拥塞窗口导致发送速率下降。<br>而在New Reno的快速恢复中，一旦出现3次重复确认，会记下出现重复确认时未确认的数据包的最大序列号，然后重发重复确认的数据包。如果有多个数据包丢失，则继续重发丢失的数据包，直到最大序列号的数据包被确认才推出快恢复阶段。<br>New Reno在低错误率时运行效率和“选择确认”（Selective ACKnowledgement，SACK）相当，在高错误率仍优于Reno。</p><h1 id="TCP-BIC-CUBIC"><a href="#TCP-BIC-CUBIC" class="headerlink" title="TCP BIC/CUBIC"></a>TCP BIC/CUBIC</h1><p>TCP BIC（Binary Increase Congestion control）旨在优化高速高延迟网络（即“长肥网络”（long fat network，LFN））的拥塞控制，其拥塞窗口算法使用二分搜索算法尝试找到能长时间保持拥塞窗口最大值的值。Linux内核在2.6.8至2.6.18使用该算法作为默认TCP拥塞算法。<br>BIC算法采用二分查找的方式来确定最大的窗口大小：如果发生丢包时窗口大小是W1，那么最大窗口Wmax应该小于W1；这时将窗口缩小到W2（乘以一个系数，也就是乘法减小），那么可以预期W1&gt;Wmax&gt;W2；这时再将窗口大小设置为(W1+W2)2（也就是二分查找），即每收到一个ACK就把窗口大小设置为两个界限的中点。<br>如果窗口大小已经无限逼近W1，说明网络状况又变好了（可用带宽增加了），这时BIC会尝试往上寻找更大的Wmax。而在往上寻找时，BIC会镜像的利用逼近当前Wmax的路径去搜寻，也就是前面是如何先快后慢慢地靠近当前Wmax的，后面就反过来先慢后快地增长。<br>而CUBIC则是比BIC更温和和系统化的分支版本，其使用三次函数代替二分算法作为其拥塞窗口算法（因为实际上BIC的搜索曲线看起来就像一个三次函数，所以干脆就写一个三次函数来模拟曲线），并且使用函数拐点作为拥塞窗口的设置值。Linux内核在2.6.19后使用该算法作为默认TCP拥塞算法。</p><h1 id="TCP-Westwood-Westwood"><a href="#TCP-Westwood-Westwood" class="headerlink" title="TCP Westwood/Westwood+"></a>TCP Westwood/Westwood+</h1><p>TCP Westwood改良自New Reno，不同于以往其他拥塞控制算法使用丢失来测量，其通过对确认包测量来确定一个“合适的发送速度”，并以此调整拥塞窗口和慢启动阈值。Westwood改良了慢启动阶段算法为“敏捷探测（Agile Probing）”，并且设计了一种持续探测拥塞窗口的方法来控制进入“敏捷探测”，使连接尽可能地使用更多的带宽。Westwood+使用更长的带宽估计间隔和优化的滤波器来修正Westwood对ACK压缩场景对带宽估计过高的问题。通过以上改良，TCP Westwood系列算法在有线网络和无线网络的拥塞控制上取得平衡，尤其研究中针对于无线通信网络上。</p><h1 id="Compound-TCP"><a href="#Compound-TCP" class="headerlink" title="Compound TCP"></a>Compound TCP</h1><p>Compound TCP是微软自己实现的TCP拥塞控制算法，通过同时维护两个拥塞窗口，来实现在长肥网络有较好的性能而又不损失公平性。CTCP维护两个拥塞窗口：一个常规的AIMD（英语：Additive increase/multiplicative decrease）窗口，以及一个基于延迟的窗口，最终实际使用的滑动窗口大小是这两个窗口的和。AIMD窗口与Reno的增加方式相同；如果延迟小，基于延迟的窗口将迅速增加以提高网络的利用率。一旦经历了排队，延迟窗口将逐渐减小以补偿增加的AIMD窗口。这样的目的是保持两者的总和大致恒定，使算法估计带宽时延积的路径。</p><h1 id="TCP-PRR"><a href="#TCP-PRR" class="headerlink" title="TCP PRR"></a>TCP PRR</h1><p>TCP PRR（TCP Proportional Rate Reduction ）是旨在恢复期间提高发送数据的准确性。该算法确保恢复后的拥塞窗口大小尽可能接近慢启动阈值</p><h1 id="TCP-BBR"><a href="#TCP-BBR" class="headerlink" title="TCP BBR"></a>TCP BBR</h1><p>TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由Google设计，于2016年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。</p><blockquote><p>摘录于 <a class="link"   href="https://juejin.cn/post/6844904003654926350" >https://juejin.cn/post/6844904003654926350<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-中常见的拥塞控制算法有哪些？&quot;&gt;&lt;a href=&quot;#TCP-中常见的拥塞控制算法有哪些？&quot; class=&quot;headerlink&quot; title=&quot;TCP 中常见的拥塞控制算法有哪些？&quot;&gt;&lt;/a&gt;TCP 中常见的拥塞控制算法有哪些？&lt;/h1&gt;&lt;h1 id=&quot;T</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP 怎么保证可靠传输？</title>
    <link href="http://example.com/2021/02/04/1000-001TCP%20%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F/"/>
    <id>http://example.com/2021/02/04/1000-001TCP%20%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F/</id>
    <published>2021-02-04T09:00:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-TCP-怎么保证可靠传输？"><a href="#1-TCP-怎么保证可靠传输？" class="headerlink" title="1. TCP 怎么保证可靠传输？"></a>1. TCP 怎么保证可靠传输？</h1><blockquote><p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。</p></blockquote><p>TCP协议保证数据传输可靠性的方式主要有：</p><ol><li><strong>数据分割</strong> 应用数据被分割成 TCP 认为最合适发送的数据块。</li><li><strong>编号</strong> TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>检验和</strong> TTCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>  TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h1 id="2-ARQ-协议"><a href="#2-ARQ-协议" class="headerlink" title="2. ARQ 协议"></a>2. ARQ 协议</h1><p> <strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><h2 id="2-1-停止等待ARQ协议"><a href="#2-1-停止等待ARQ协议" class="headerlink" title="2.1 停止等待ARQ协议"></a>2.1 停止等待ARQ协议</h2><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><p><strong>优点：</strong> 简单<br><strong>缺点：</strong> 信道利用率低，等待时间长</p><h3 id="2-1-1-无差错情况"><a href="#2-1-1-无差错情况" class="headerlink" title="2.1.1 无差错情况"></a>2.1.1 无差错情况</h3><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><h3 id="2-1-2-出现差错情况（超时重传）"><a href="#2-1-2-出现差错情况（超时重传）" class="headerlink" title="2.1.2 出现差错情况（超时重传）"></a>2.1.2 出现差错情况（超时重传）</h3><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。 <strong>这种自动重传方式常称为 自动重传请求 ARQ 。</strong></p><p>另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><h3 id="2-1-3-确认丢失和确认迟到"><a href="#2-1-3-确认丢失和确认迟到" class="headerlink" title="2.1.3 确认丢失和确认迟到"></a>2.1.3 确认丢失和确认迟到</h3><ul><li><strong>确认丢失：</strong> 确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li><li><strong>确认迟到</strong> 确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul><h2 id="2-2-连续ARQ协议"><a href="#2-2-连续ARQ协议" class="headerlink" title="2.2 连续ARQ协议"></a>2.2 连续ARQ协议</h2><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h1 id="3-滑动窗口和流量控制"><a href="#3-滑动窗口和流量控制" class="headerlink" title="3. 滑动窗口和流量控制"></a>3. 滑动窗口和流量控制</h1><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h1 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个<strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p></li><li><p><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p></li></ul><blockquote><p>摘录于 <a class="link"   href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E5%9B%9B-tcp-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93" >https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=四-tcp-协议如何保证可靠传输<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-TCP-怎么保证可靠传输？&quot;&gt;&lt;a href=&quot;#1-TCP-怎么保证可靠传输？&quot; class=&quot;headerlink&quot; title=&quot;1. TCP 怎么保证可靠传输？&quot;&gt;&lt;/a&gt;1. TCP 怎么保证可靠传输？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;TCP</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="ARQ协议" scheme="http://example.com/tags/ARQ%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>从输入 URL 到展现页面的全过程</title>
    <link href="http://example.com/2021/02/03/1000-000%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E5%B1%95%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/02/03/1000-000%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E5%B1%95%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-02-03T07:22:00.000Z</published>
    <updated>2021-02-17T07:34:52.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从输入-URL-到展现页面的全过程"><a href="#从输入-URL-到展现页面的全过程" class="headerlink" title="从输入 URL 到展现页面的全过程"></a>从输入 URL 到展现页面的全过程</h1><blockquote><p>8 个过程</p></blockquote><ul><li>URL 输入</li><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求</li><li>服务器相应请求</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h2 id="1-URL-输入"><a href="#1-URL-输入" class="headerlink" title="1. URL 输入"></a>1. URL 输入</h2><blockquote><p>URL中文名叫做统一资源定位符，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p></blockquote><p><strong>主要组成部分：protocol :// hostname[:port] / path / [;parameters][?query]#fragment</strong></p><ul><li>protocol 协议</li><li>hostname 主机名</li><li>port 端口号</li><li>path 路径</li><li>parameters 参数</li><li>query 查询</li><li>fragment 信息片段<blockquote><p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p></blockquote><h2 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h2><blockquote><p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如<a class="link"   href="http://www.baidu.com,其实不是百度网站真正意义上的地址.互联网上每一台计算机的唯一标识是它的ip地址,但是ip地址并不方便记忆.用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机,也就是上面提到的百度的网址.所以互联网设计者需要在用户的方便性与可用性方面做一个权衡,这个权衡就是一个网址到ip地址的转换,这个过程就是dns解析.它实际上充当了一个翻译的角色,实现了网址到ip地址的转换.网址到ip地址转换的过程是如何进行的/" >www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的<i class="fas fa-external-link-alt"></i></a>?</p></blockquote></li></ul><p><strong>查找顺序： 浏览器缓存–&gt; 操作系统缓存–&gt; 本地host文件 –&gt; 路由器缓存–&gt; ISP DNS缓存 –&gt; 顶级DNS服务器/根DNS服务器</strong></p><p><strong>1. 浏览器缓存：</strong> 首先会向浏览器的缓存中读取上一次访问的记录，在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看缓存的当前状态 。</p><p><strong>2. 操作系统缓存：</strong>  查找存储在系统运行内存中的缓存。在mac中可以通过下面的命令清除系统中的DNS缓存。<br><code>dscacheutil -flushcache</code></p><p><strong>3. 本地 host 文件：</strong> 查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p><p><strong>4. 路由器缓存：</strong> 有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。</p><p><strong>5. ISP DNS 缓存：</strong> 互联网服务提供商（如中国电信）也会提供DNS服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向根域名服务器请求查询。</p><p><strong>6. 顶级 DNS 服务器 / 根 DNS 服务器：</strong> 根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的DNS服务器IP（baidu.com），本机继续查找，直到服务器找到(<a class="link"   href="http://www.baidu.com)的主机./" >www.baidu.com)的主机。<i class="fas fa-external-link-alt"></i></a><br>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/t5awpd.png"                      alt="过程图"                ></p><p>上述图片是查找 <a class="link"   href="http://www.google.com/" >www.google.com<i class="fas fa-external-link-alt"></i></a> 的 IP 地址过程。首先在本地域名服务器中查询 IP 地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向 com 顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为</a>: . -&gt; .com -&gt; google.com. -&gt; <a class="link"   href="http://www.google.com../" >www.google.com.。<i class="fas fa-external-link-alt"></i></a></p><p>补充：</p><ol><li><p>什么是 DNS ？<br>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<br>  通俗的讲，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p></li><li><p>DNS 查询的两种方式：递归查询和迭代查询</p><p> 2.1 递归解析<br> 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/4vqiqy.png"                      alt="DNS 递归解析查询"                ></p><p> 2.2 迭代解析<br> 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/rnsyzp.png"                      alt="DNS 迭代解析查询"                ></p></li><li><p>DNS 域名称空间的组织方式<br>我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例</p></li></ol><table><thead><tr><th>名称类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>根域</td><td>DNS 域名中使用时，规模由尾部句点(.) 来指定名称位于根或更高级别的域层次结构</td><td>单个句点(.)或句点用于末尾的名称</td></tr><tr><td>顶级域</td><td>用来指示某个国家/地区或组织的名称</td><td>.com</td></tr><tr><td>第二层域</td><td>个人或组织在 Internet 上使用的注册名称</td><td>qq.com</td></tr><tr><td>子域</td><td>已注册的二级域名派生的域名，通俗的讲就是网站名</td><td><a class="link"   href="http://www.qq.com/" >www.qq.com<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>主机名</td><td>通常情况下，DNS 域名的最左侧的标签标示网络上的特定计算机 如 h1</td><td>h1.<a class="link"   href="http://www.qq.com/" >www.qq.com<i class="fas fa-external-link-alt"></i></a></td></tr></tbody></table><ol start="4"><li><p>DNS 优化<br>了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。</p><p> 4.1 DNS 缓存<br> DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。<br> 4.2 DNS 负载均衡<br> 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p></li></ol><h2 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/bnd17b.png"                      alt="TCP 连接图"                ></p><p>三次握手以建立 TCP 连接<br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p><strong>为什需要三次握手？</strong><br>《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p><h2 id="4-发送HTTP请求"><a href="#4-发送HTTP请求" class="headerlink" title="4. 发送HTTP请求"></a>4. 发送HTTP请求</h2><p>建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。   </p><p>客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p><ul><li>请求方法URI协议/版本</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h2 id="5-服务器永久重定向"><a href="#5-服务器永久重定向" class="headerlink" title="5.服务器永久重定向"></a>5.服务器永久重定向</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<a class="link"   href="http://www.google.com/" >http://www.google.com/<i class="fas fa-external-link-alt"></i></a> 而非<a class="link"   href="http://google.com/%E3%80%82" >http://google.com/。<i class="fas fa-external-link-alt"></i></a>   <br>​    为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a class="link"   href="http://www.yy.com/%E5%92%8Chttp://yy.com/%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%9A%E8%AE%A4%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%80%A0%E6%88%90%E6%AF%8F%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%93%BE%E6%8E%A5%E9%83%BD%E5%87%8F%E5%B0%91%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%8E%92%E5%90%8D%E3%80%82%E8%80%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9F%A5%E9%81%93301%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E6%8A%8A%E8%AE%BF%E9%97%AE%E5%B8%A6www%E7%9A%84%E5%92%8C%E4%B8%8D%E5%B8%A6www%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%92%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8E%92%E5%90%8D%E4%B8%8B%E3%80%82%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E6%80%A7%E5%8F%98%E5%B7%AE%EF%BC%8C%E5%BD%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%90%8D%E5%AD%97%E6%97%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E9%87%8C%E5%87%BA%E7%8E%B0%E5%A5%BD%E5%87%A0%E6%AC%A1%E3%80%82" >http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。<i class="fas fa-external-link-alt"></i></a></p><ul><li>补充</li></ul><ol><li>301和302的区别：</li></ol><p>301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。<br>  他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；<br>  302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</p><ol start="2"><li><p>重定向原因：<br>(1)网站调整（如改变网页目录结构）；<br>(2)网页被移到一个新地址；<br>(3)网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p></li><li><p>什么时候进行301或者302跳转呢？<br>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下：</p></li></ol><ul><li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li><li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li><li>空间服务器不稳定，换空间的时候。</li></ul><h2 id="6-服务器处理请求"><a href="#6-服务器处理请求" class="headerlink" title="6. 服务器处理请求"></a>6. 服务器处理请求</h2><p>经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？   </p><p>后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。   <br>一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/pn6p43.png"                      alt="示例图"                ></p><ul><li>补充：</li></ul><ol><li>什么是反向代理？<br>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/ysfjxn.png"                      alt="示例图"                ></li></ol><h2 id="7-服务器返回一个-HTTP-响应"><a href="#7-服务器返回一个-HTTP-响应" class="headerlink" title="7. 服务器返回一个 HTTP 响应"></a>7. 服务器返回一个 HTTP 响应</h2><p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。 HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p><ul><li>状态行</li><li>响应头</li><li>空行</li><li>响应正文</li></ul><p><strong>状态行：</strong><br>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。<br>格式: HTTP-Version Status-Code Reason-Phrase CRLF<br>例如: HTTP/1.1 200 OK \r\n<br>| -协议版本：是用http1.0还是其他版本<br>| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok<br>| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p><p>==1xx：== 信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p><ul><li>100 Continue</li><li>101 Switching Protocols</li></ul><p>==2xx：== 成功状态码，表示服务器已成功接收到请求并进行处理。</p><ul><li>200 OK 表示客户端请求成功</li><li>204 No Content 成功，但不返回任何实体的主体部分</li><li>206 Partial Content 成功执行了一个范围（Range）请求</li></ul><p>==3xx：== 重定向状态码，表示服务器要求客户端重定向。</p><ul><li>301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</li><li>302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</li><li>303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</li><li>304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</li><li>307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</li></ul><p>==4xx：== 客户端错误状态码，表示客户端的请求有非法内容。</p><ul><li>400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</li><li>403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</li><li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li></ul><p>==5xx：== 服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p><ul><li>500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</li><li>503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li></ul><p><strong>响应头：</strong><br>响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/m1chic.png"                      alt="响应头"                ></p><p><strong>响应正文：</strong><br>包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/0qw5o5.png"                      alt="响应正文"                ></p><h2 id="8-浏览器显示-html"><a href="#8-浏览器显示-html" class="headerlink" title="8. 浏览器显示 html"></a>8. 浏览器显示 html</h2><blockquote><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p></blockquote><p><strong>构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</strong><br>渲染过程：</p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br>​    当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。<br>​    JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。<br>​    JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/we6f9l.png"                      alt="渲染过程"                ></p><h2 id="9-连接结束"><a href="#9-连接结束" class="headerlink" title="9. 连接结束"></a>9. 连接结束</h2><p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的。一般来说是客户端主动发起的关闭，过程如下。<br>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：<br>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。<br>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。<br>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。<br>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p><p><strong>补充：</strong><br><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><blockquote><p>摘录于 <a class="link"   href="https://juejin.cn/post/6844903616101220366" >https://juejin.cn/post/6844903616101220366<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从输入-URL-到展现页面的全过程&quot;&gt;&lt;a href=&quot;#从输入-URL-到展现页面的全过程&quot; class=&quot;headerlink&quot; title=&quot;从输入 URL 到展现页面的全过程&quot;&gt;&lt;/a&gt;从输入 URL 到展现页面的全过程&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="三次握手" scheme="http://example.com/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
    <category term="DNS" scheme="http://example.com/tags/DNS/"/>
    
    <category term="HTTP 请求" scheme="http://example.com/tags/HTTP-%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序自定义组件、父子组件相互调用传值</title>
    <link href="http://example.com/2021/01/15/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2021/01/15/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</id>
    <published>2021-01-15T07:53:00.000Z</published>
    <updated>2021-02-17T07:34:52.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-创建-header-组件"><a href="#1-创建-header-组件" class="headerlink" title="1.创建 header 组件"></a>1.创建 header 组件</h1><h2 id="1-1-选中文件夹，右键新建-Component。-暂命名为-header"><a href="#1-1-选中文件夹，右键新建-Component。-暂命名为-header" class="headerlink" title="1.1 选中文件夹，右键新建 Component。 暂命名为 header"></a>1.1 选中文件夹，右键新建 Component。 暂命名为 header</h2><h2 id="1-2-header-js-文件配置组件属性与方法"><a href="#1-2-header-js-文件配置组件属性与方法" class="headerlink" title="1.2 header.js 文件配置组件属性与方法"></a>1.2 header.js 文件配置组件属性与方法</h2><blockquote><p>交互关键方法⚠️ this.triggerEvent(‘subClickEvent’, ‘来自 子组件 的信号这个是 参数’)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;组件的属性列表</span><br><span class="line">  properties: &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 属性名 简化写法</span><br><span class="line">    name: String,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 属性名</span><br><span class="line">    car: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      value: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生命周期函数，可以为函数，或一个在methods段中定义的方法名</span><br><span class="line">  lifetimes: &#123;</span><br><span class="line">    attached: function () &#123; &#125;,</span><br><span class="line">    moved: function () &#123; &#125;,</span><br><span class="line">    detached: function () &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件所在页面的生命周期函数</span><br><span class="line">  pageLifetimes: &#123;</span><br><span class="line">    show: function () &#123; &#125;,</span><br><span class="line">    hide: function () &#123; &#125;,</span><br><span class="line">    resize: function () &#123; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件的初始数据</span><br><span class="line">  data: &#123;</span><br><span class="line">    color: &#39;彩色&#39;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组件的方法列表</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    logP() &#123;</span><br><span class="line">      console.log(&#39;pppppp&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组件内部先调用该方法 再调用父方法</span><br><span class="line">    cllParentClick() &#123;</span><br><span class="line">      &#x2F;&#x2F;  触发 subClickEvent 事件， 间接通知在 父组件中 subClickEvent 绑定的 subClick 方法</span><br><span class="line">      &#x2F;&#x2F;  建议  subClickEvent 与  subClick 命名相同，这个刚接触感觉会有一点混乱</span><br><span class="line">      &#x2F;&#x2F; subClickEvent 就是通知名。subClickEvent 这个通知在使用该组件时绑定的，绑定了父组件的 subClick 方法。然后在这里触发了 subClickEvent 通知</span><br><span class="line">      this.triggerEvent(&#39;subClickEvent&#39;, &#39;来自 子组件 的信号这个是 参数&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    btnClick(e) &#123;</span><br><span class="line">      console.log(&#39;开车开车&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 私有方法 下划线开头</span><br><span class="line">    _saySelfName() &#123;</span><br><span class="line">      console.log(&#39;header&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-header-wxml"><a href="#1-3-header-wxml" class="headerlink" title="1.3 header.wxml"></a>1.3 header.wxml</h2><p>header 组件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">  &lt;text&gt;name:&#123;&#123;name&#125;&#125;  car:&#123;&#123;car&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;button size&#x3D;&quot;default&quot; type&#x3D;&quot;primary&quot; bind:tap&#x3D;&quot;btnClick&quot;&gt;开车开车&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;button size&#x3D;&quot;default&quot; type&#x3D;&quot;primary&quot; bind:tap&#x3D;&quot;cllParentClick&quot;&gt;调用父组件 subClick 方法&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>header.wxss</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-使用-header-组件"><a href="#2-使用-header-组件" class="headerlink" title="2. 使用 header 组件"></a>2. 使用 header 组件</h1><h2 id="2-1-page-json"><a href="#2-1-page-json" class="headerlink" title="2.1 page.json"></a>2.1 page.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;header&quot;: &quot;..&#x2F;..&#x2F;..&#x2F;components&#x2F;header&#x2F;header&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-page-wxml"><a href="#2-2-page-wxml" class="headerlink" title="2.2 page.wxml"></a>2.2 page.wxml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;header id&#x3D;&#39;comHeader&#39; name&#x3D;&#39;朱小明&#39; car&#x3D;&#39;自行车&#39; bind:subClickEvent&#x3D;&#39;subClick&#39;&gt;&lt;&#x2F;header&gt;</span><br><span class="line">&lt;button bind:tap&#x3D;&quot;getHeaderInfo&quot;&gt;获取组件属性&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这里注册的 subClickEvent 事件，当 header 组件触发 subClickEvent 时，调用 page 的  subClick 方法。 建议将 subClickEvent 与 subClick 命名相同</p></blockquote><h2 id="2-3-page-js"><a href="#2-3-page-js" class="headerlink" title="2.3 page.js"></a>2.3 page.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; header 组件间接调用该方法</span><br><span class="line">  subClick(e) &#123;</span><br><span class="line">    console.log(e.detail);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 主动获取 header 组件实例对象</span><br><span class="line">  getHeaderInfo() &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取组件实例对象  记得加 # </span><br><span class="line">    let header &#x3D; this.selectComponent(&#39;#comHeader&#39;);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取属性</span><br><span class="line">    console.log(header.properties.color);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 调用方法</span><br><span class="line">    header.logP();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-创建-header-组件&quot;&gt;&lt;a href=&quot;#1-创建-header-组件&quot; class=&quot;headerlink&quot; title=&quot;1.创建 header 组件&quot;&gt;&lt;/a&gt;1.创建 header 组件&lt;/h1&gt;&lt;h2 id=&quot;1-1-选中文件夹，右键新建-Co</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序引入模块，App.js</title>
    <link href="http://example.com/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97/</id>
    <published>2021-01-14T07:05:00.000Z</published>
    <updated>2021-02-17T07:34:52.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建一个模块-utils-appConfig-js"><a href="#创建一个模块-utils-appConfig-js" class="headerlink" title="创建一个模块 utils/appConfig.js"></a>创建一个模块 utils/appConfig.js</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const appConfig &#x3D; &#123;</span><br><span class="line">  host: &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">  sayHi(e) &#123;</span><br><span class="line">    console.log(&#39;hi&#39; + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default appConfig</span><br></pre></td></tr></table></figure><h1 id="导入创建的模块使用-其他-js-文件内"><a href="#导入创建的模块使用-其他-js-文件内" class="headerlink" title="导入创建的模块使用     其他 .js 文件内"></a>导入创建的模块使用     其他 .js 文件内</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import appConfig from &#39;..&#x2F;..&#x2F;..&#x2F;utils&#x2F;appConfig.js&#39;;</span><br><span class="line">console.log(appConfig.host);</span><br><span class="line">appConfig.sayHi(&#39;朱小明&#39;)</span><br></pre></td></tr></table></figure><h1 id="获取-App-js"><a href="#获取-App-js" class="headerlink" title="获取 App.js"></a>获取 App.js</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  userToken:&#39;zhu xiao ming&#39;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; 省略其他</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let app &#x3D; getApp();</span><br><span class="line">console.log(app.userToken);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建一个模块-utils-appConfig-js&quot;&gt;&lt;a href=&quot;#创建一个模块-utils-appConfig-js&quot; class=&quot;headerlink&quot; title=&quot;创建一个模块 utils/appConfig.js&quot;&gt;&lt;/a&gt;创建一个模块 util</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序界面跳转传值、反向传值</title>
    <link href="http://example.com/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%80%BC/"/>
    <id>http://example.com/2021/01/14/600-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%80%BC/</id>
    <published>2021-01-14T05:40:00.000Z</published>
    <updated>2021-02-17T07:34:52.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="page1-点击事件-wxml"><a href="#page1-点击事件-wxml" class="headerlink" title="page1 点击事件 .wxml"></a>page1 点击事件 .wxml</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text bind:tap&#x3D;&quot;pushNav&quot;&gt;界面跳转传值&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure><h1 id="page1-跳转方法实现-js"><a href="#page1-跳转方法实现-js" class="headerlink" title="page1 跳转方法实现 .js"></a>page1 跳转方法实现 .js</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pushNav(e) &#123;</span><br><span class="line">    </span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      &#x2F;&#x2F; 跳转传值方式 1</span><br><span class="line">      url: &#39;..&#x2F;page2?carName&#x3D;&#39; + &#39;特斯拉&#39;,</span><br><span class="line"></span><br><span class="line">      events: &#123;</span><br><span class="line">        &#x2F;&#x2F; 反向传值 page2 回调给 page1 接收处</span><br><span class="line">        getuserInfoClick(e) &#123;</span><br><span class="line">          console.log(e);</span><br><span class="line">          that.setData(&#123; userName: e.userName &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        &#x2F;&#x2F; 跳转传值方式 2</span><br><span class="line">        &#x2F;&#x2F; 这个其实有点类似于通知的意思 定义通知名称 和 参数</span><br><span class="line">        res.eventChannel.emit(&#39;diyfunName&#39;, &#123; parKey: &#39;我是通过 eventChannel 传递的另一个数据&#39; &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="page2-接收传值，并回传-js"><a href="#page2-接收传值，并回传-js" class="headerlink" title="page2 接收传值，并回传  .js"></a>page2 接收传值，并回传  .js</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过方式1 传值接收</span><br><span class="line">    this.setData(&#123; carName: options.carName &#125;);</span><br><span class="line"></span><br><span class="line">    const eventChannel &#x3D; this.getOpenerEventChannel();</span><br><span class="line">    </span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 反向传值 page2 传给 page1</span><br><span class="line">    eventChannel.emit(&#39;getuserInfoClick&#39;, &#123; userName: &#39;朱小明&#39; &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F; 通过方式2 传值接收</span><br><span class="line">    eventChannel.on(&#39;diyfunName&#39;, function (params) &#123;</span><br><span class="line">      that.setData(&#123; otherPar: params.parKey &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;page1-点击事件-wxml&quot;&gt;&lt;a href=&quot;#page1-点击事件-wxml&quot; class=&quot;headerlink&quot; title=&quot;page1 点击事件 .wxml&quot;&gt;&lt;/a&gt;page1 点击事件 .wxml&lt;/h1&gt;&lt;figure class=&quot;high</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter 路由跳转</title>
    <link href="http://example.com/2020/12/29/400-Flutter%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/"/>
    <id>http://example.com/2020/12/29/400-Flutter%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/</id>
    <published>2020-12-29T02:43:00.000Z</published>
    <updated>2021-02-17T07:34:52.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本路由跳转-加传值"><a href="#基本路由跳转-加传值" class="headerlink" title="基本路由跳转  加传值"></a>基本路由跳转  加传值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).push(MaterialPageRoute(</span><br><span class="line">                builder: (context) &#x3D;&gt; MyRouterPage(title: &#39;首页&#39;),</span><br><span class="line">              ));</span><br></pre></td></tr></table></figure><h1 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本路由跳转-加传值&quot;&gt;&lt;a href=&quot;#基本路由跳转-加传值&quot; class=&quot;headerlink&quot; title=&quot;基本路由跳转  加传值&quot;&gt;&lt;/a&gt;基本路由跳转  加传值&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="Flutter" scheme="http://example.com/categories/Flutter/"/>
    
    
  </entry>
  
</feed>
