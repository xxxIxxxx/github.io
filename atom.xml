<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-23T16:02:29.256Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>112. 路径总和 - 简单</title>
    <link href="http://example.com/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://example.com/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2021-02-23T15:55:00.000Z</published>
    <updated>2021-02-23T16:02:29.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a class="link"   href="https://leetcode-cn.com/problems/path-sum/" >112. 路径总和<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/lxqfb4.png"                      alt="112. 路径总和"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n),每个节点都要访问一次</li><li>空间复杂度<br>O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        if root.left &#x3D;&#x3D; nil, root.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">            return root.val &#x3D;&#x3D; targetSum</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 递归每次用当前的 sum - 当前 root.val</span><br><span class="line">        &#x2F;&#x2F; 一直 减减减 减到 叶子节点， 就判断当前的 sum 和 root.val 是否相等即可</span><br><span class="line">        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先解法"><a href="#广度优先解法" class="headerlink" title="广度优先解法"></a>广度优先解法</h1><ul><li>时间复杂度<br>O(n),每个节点都要访问一次</li><li>空间复杂度<br>O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; &#x2F;&#x2F; 如果 root &#x3D; nil 那么就一定不存在了</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var stackTree: [TreeNode] &#x3D; [root]</span><br><span class="line">        var treeVal: [Int] &#x3D; [root.val]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;           1</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;   \</span><br><span class="line">        &#x2F;&#x2F;        2     3</span><br><span class="line">        &#x2F;&#x2F;       &#x2F; \    &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;      4   5   6  7</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 1 添加 2 3,同时 treeVal 移除 1.val 添加 1+2.val ，1+3.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 2 添加 4 5,同时 treeVal 移除 2.val 添加 2+4.val ，2+5.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 3 添加 6 7,同时 treeVal 移除 3.val 添加 3+6.val ，3+7.val</span><br><span class="line">        while !stackTree.isEmpty &#123;</span><br><span class="line">            let tree: TreeNode &#x3D; stackTree.popLast()!</span><br><span class="line">            let sum &#x3D; treeVal.popLast()</span><br><span class="line">            if tree.left &#x3D;&#x3D; nil, tree.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">                if sum &#x3D;&#x3D; targetSum &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.left !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.left!)</span><br><span class="line">                treeVal.append(sum! + tree.left!.val)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.right !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.right!)</span><br><span class="line">                treeVal.append(sum! + tree.right!.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;112-路径总和&quot;&gt;&lt;a href=&quot;#112-路径总和&quot; class=&quot;headerlink&quot; title=&quot;112. 路径总和&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/path</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>155. 最小栈 - 简单</title>
    <link href="http://example.com/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://example.com/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2021-02-23T10:23:00.000Z</published>
    <updated>2021-02-23T16:02:29.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a class="link"   href="https://leetcode-cn.com/problems/min-stack/" >155. 最小栈<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/g135og.png"                      alt="155. 最小栈"                ></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ul><li>时间复杂度<br>对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是<br>O(1)，我们定义的每个操作最多调用栈操作两次。</li><li>空间复杂度<br>其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;记录当前最小值</span><br><span class="line">    var minNum: Int?</span><br><span class="line">    &#x2F;&#x2F;只存最小值</span><br><span class="line">    var minNums: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    func push(_ x: Int) &#123;</span><br><span class="line">        list.append(x)</span><br><span class="line">        minNum &#x3D; min(minNum ?? .max, x)</span><br><span class="line">        if minNum &#x3D;&#x3D; x &#123;</span><br><span class="line">            minNums.append(minNum!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func pop() &#123;</span><br><span class="line">        let p &#x3D; list.removeLast()</span><br><span class="line">        if minNum &#x3D;&#x3D; p &#123;</span><br><span class="line">            minNum &#x3D; list.min()</span><br><span class="line">            minNums.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func top() -&gt; Int &#123;</span><br><span class="line">        return list.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getMin() -&gt; Int &#123;</span><br><span class="line">        return minNums.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;155-最小栈&quot;&gt;&lt;a href=&quot;#155-最小栈&quot; class=&quot;headerlink&quot; title=&quot;155. 最小栈&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/min-sta</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是中间人攻击？如何防止攻击？</title>
    <link href="http://example.com/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/"/>
    <id>http://example.com/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/</id>
    <published>2021-02-23T08:10:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h1><p>A &lt;—-&gt; B<br>A &lt;—-&gt; C &lt;—-&gt; B<br>正常是 A 和 B 通信，这时 C 截获了 A 发给 B 的消息，然后假装成 A 给 B 发送消息。</p><p>中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。<br>在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL 协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p><h1 id="如何防止中间人攻击？"><a href="#如何防止中间人攻击？" class="headerlink" title="如何防止中间人攻击？"></a>如何防止中间人攻击？</h1><p>使用由 CA (数字证书认证机构 Certificate Authority)签发或签名的数子证书 来提供认证和加密。证书必须放入服务器和客户端中。</p><p>要信任某个证书真实有效，该证书必须通过属于可信认证中心 (CA) 的根证书进行数字签名。操作系统和浏览器维护有可信 CA 根证书的列表，以便可以轻松验证 CA 签发和签名的证书。</p><blockquote><p>摘录于 <a class="link"   href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" >https://zh.wikipedia.org/wiki/中间人攻击<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN" >https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是中间人攻击？&quot;&gt;&lt;a href=&quot;#什么是中间人攻击？&quot; class=&quot;headerlink&quot; title=&quot;什么是中间人攻击？&quot;&gt;&lt;/a&gt;什么是中间人攻击？&lt;/h1&gt;&lt;p&gt;A &amp;lt;—-&amp;gt; B&lt;br&gt;A &amp;lt;—-&amp;gt; C &amp;lt;—-&amp;gt</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>145. 二叉树的后序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T07:18:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" >145. 二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树的后序遍历 左 右 根</p><p>当根节点的左右子树均为空的时候 add root.val</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        postorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func postorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        postorder(root.left, &amp;list)</span><br><span class="line">        postorder(root.right, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="真迭代解法"><a href="#真迭代解法" class="headerlink" title="真迭代解法"></a>真迭代解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal1(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 用来记录回退的根节点 在回退的时候 要判断这个是不是刚刚回退的节点 如果不加判断会死循环</span><br><span class="line">        var lastTree: TreeNode?</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; root.right &#x3D;&#x3D; nil 时做下列操作很容易理解</span><br><span class="line">            if root?.right &#x3D;&#x3D; nil || root?.right &#x3D;&#x3D;&#x3D; lastTree &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                &#x2F;&#x2F; 这个时候要回退了，所以先记录当前的这个节点</span><br><span class="line">                lastTree &#x3D; root</span><br><span class="line">                &#x2F;&#x2F; 要把 root 置 nil 进行回退， 否则又是死循环</span><br><span class="line">                root &#x3D; nil</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="假后序解法"><a href="#假后序解法" class="headerlink" title="假后序解法"></a>假后序解法</h1><ul><li>时间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。 一个 n 是所有节点的遍历，另一个是最后的反转</li><li>空间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。一个 n 是迭代栈的开销，一个是最后反转的开销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal2(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 后序遍历的顺序是  左右根</span><br><span class="line">        &#x2F;&#x2F; 反转后是 根右左，和前序遍历的 根左右 很像</span><br><span class="line">        &#x2F;&#x2F; 所以来用前序遍历的变形写法，然后把得的数据反转就行了</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.reversed()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; title=&quot;145. 二叉树的后序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>144. 二叉树的前序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T05:09:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" >144. 二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树的前序遍历 根 左 右</p><p>当根节点不为空时,直接把 root.val add list</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        preorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func preorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        preorder(root.left, &amp;list)</span><br><span class="line">        preorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. 二叉树的前序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>94. 二叉树的中序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T03:05:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树中序遍历顺序为 左 根 右<br>当根节点的左子树为空时添加该根节点，即在 root.left = nil, 后 add root.val</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度 O(n)<br>空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        inorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func inorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 中序遍历 左 中 右</span><br><span class="line">        &#x2F;&#x2F; 即中序遍历，左根右。当根结点的左子树为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即前序遍历，根左右。当根节点不为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即后序遍历，左右根。当根节点的左右子树均为空时，那么 add root.val</span><br><span class="line">        inorder(root.left, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        inorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度 O(n)<br>空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var tempList: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line"></span><br><span class="line">        while root !&#x3D; nil || !tempList.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                tempList.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; tempList.popLast()</span><br><span class="line">            list.append(root!.val)</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>53. 最大子序和-简单</title>
    <link href="http://example.com/2021/02/23/2000-007-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://example.com/2021/02/23/2000-007-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2021-02-23T01:59:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a class="link"   href="https://leetcode-cn.com/problems/maximum-subarray/" >53. 最大子序和<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/o6raa6.png"                      alt="53. 最大子序和"                ></p><h1 id="动态规划-解法"><a href="#动态规划-解法" class="headerlink" title="动态规划 解法"></a>动态规划 解法</h1><ul><li>时间复杂度 O(n)<br>一次遍历，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li><li>空间复杂度 O(1)<br>只开辟了两个额外的空间，即只需要常数空间存放若干变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func maxSubArray(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为和</span><br><span class="line">        var sum &#x3D; nums[0]</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为当前最大值</span><br><span class="line">        var ans &#x3D; nums[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 因为已经把 nums[0] 计算了，所以从 nums[1] 开始</span><br><span class="line">        for i in 1 ..&lt; nums.count &#123;</span><br><span class="line">            if sum &lt; 0 &#123; &#x2F;&#x2F; 如果 sum 小于 0 ，那么 sum + nums[i] 只会让 nums[i] 更小</span><br><span class="line">                sum &#x3D; nums[i] &#x2F;&#x2F; 所以接把 num[i] 赋值给 sum</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; sum &gt;&#x3D; 0 那么就直接加 nums[i] 不用考虑 nums[i] 是大于零 还是小于零</span><br><span class="line">                sum &#x3D; sum + nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; (sum &gt; ans) ? sum : ans</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/maxi</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>912. 排序数组</title>
    <link href="http://example.com/2021/02/22/2000-006-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/02/22/2000-006-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-02-22T15:16:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/sort-an-array/" >912. 排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/stmaiz.png"                      alt="912. 排序数组"                ></p><h1 id="快速排序-递归解法"><a href="#快速排序-递归解法" class="headerlink" title="快速排序 递归解法"></a>快速排序 递归解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">        var nums &#x3D; nums</span><br><span class="line">        sort2(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort2(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        if left &lt; right &#123;</span><br><span class="line">            let p &#x3D; partition(&amp;nums, left, right)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值左边的数据 分界值的位置已经确定 所以传入 right &#x3D; p - 1</span><br><span class="line">            sort2(&amp;nums, left, p - 1)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值右边的数据 分界值的位置已经确定 所以传入 left &#x3D; p + 1</span><br><span class="line">            sort2(&amp;nums, p + 1, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func partition(_ nums: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 直接以 nums[right] 为分界值</span><br><span class="line">        let p &#x3D; nums[right]</span><br><span class="line">        &#x2F;&#x2F; 记录下一个 比分界值小的值 应该移动到哪个位置， 默认为最左边</span><br><span class="line">        var minL &#x3D; left</span><br><span class="line">        for i in left ..&lt; right &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前值 小于等于分界值，那么交换 i 和 minL 的值。否则不做处理</span><br><span class="line">            if nums[i] &lt;&#x3D; p &#123;</span><br><span class="line">                swap(&amp;nums, minL, i)</span><br><span class="line">                &#x2F;&#x2F; minL 已经被小于等于分界值的值占用，那么 +&#x3D; 1</span><br><span class="line">                minL +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 到这里，在 minL 索引 前的值都是小于等于 分界值的，在 minL 到 right - 1，包括 minL 的值都是大于 分界值的。 分界值一直在最后</span><br><span class="line">        &#x2F;&#x2F; 所以 把分界值 和 nums[minL] 交换位置</span><br><span class="line">        swap(&amp;nums, minL, right)</span><br><span class="line">        &#x2F;&#x2F; 返回分界值所在的 位置</span><br><span class="line">        return minL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func swap(_ nums: inout [Int], _ a: Int, _ b: Int) &#123;</span><br><span class="line">        let temp &#x3D; nums[a]</span><br><span class="line">        nums[a] &#x3D; nums[b]</span><br><span class="line">        nums[b] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序-迭代解法"><a href="#快速排序-迭代解法" class="headerlink" title="快速排序 迭代解法"></a>快速排序 迭代解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">         var nums &#x3D; nums</span><br><span class="line">        sort(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        &#x2F;&#x2F; 取中间值 做为当前的 分界值</span><br><span class="line">        let pivot &#x3D; nums[(right - left) &#x2F; 2 + left]</span><br><span class="line">        var L &#x3D; left</span><br><span class="line">        var R &#x3D; right</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; L &lt; R 说明 L 和 R 没相遇</span><br><span class="line">        while L &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 左边的数小于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从左往右  所以 L +&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数大于 pivot ， 那么跳出这个循环 且这个数的索引位 L</span><br><span class="line"></span><br><span class="line">            while nums[L] &lt; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 右边的数大于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从右往左 所以 R -&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数小于 pivot ， 那么跳出这个循环 且这个数的索引位 R</span><br><span class="line"></span><br><span class="line">            while nums[R] &gt; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; L &gt;&#x3D; R 说明 pivot 左边已经是 全部小于等于 pivot ，右边 全部是 大于等于 pivot。 可以提前退出</span><br><span class="line">            if L &gt;&#x3D; R &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 跳出了上边的两个循环之后 说明 分别找到了</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 左边，但大于等于 pivot 的数，它的索引为 L</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 右边，但小于等于 pivot 的数，它的索引位 R</span><br><span class="line">            &#x2F;&#x2F; 那么交换这两个数的位置</span><br><span class="line"></span><br><span class="line">            let temp &#x3D; nums[L]</span><br><span class="line">            nums[L] &#x3D; nums[R]</span><br><span class="line">            nums[R] &#x3D; temp</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 交换完后 nums[L] 是小于等于 pivot, nums[R] 是大于等于 pivot</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[L] &#x3D;&#x3D; pivot 了,要让 R -&#x3D; 1，</span><br><span class="line">            if nums[L] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[R] &#x3D;&#x3D; pivot 了,要让 L +&#x3D; 1</span><br><span class="line">            if nums[R] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果不处理 交换完后 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 的情况，</span><br><span class="line">            &#x2F;&#x2F; 当 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 都是 true 时，</span><br><span class="line">            &#x2F;&#x2F; 上边的两个 while 也不会在执行了， 那么 L 和 R 的数值也不会再发生变化 就卡死在这里了</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 到这里 L &gt;&#x3D; R 说明相遇了</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 左边的数都是 小于等于 pivot 的</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 右边的数都是 大于等于 pivot 的</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这一步是防止对 pivot 左右分别操作时越界</span><br><span class="line">        if L &#x3D;&#x3D; R &#123;</span><br><span class="line">            L +&#x3D; 1</span><br><span class="line">            R -&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if left &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 左边的数据</span><br><span class="line">            sort(&amp;nums, left, R)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if right &gt; L &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 右边的数据</span><br><span class="line">            sort(&amp;nums, L, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;912-排序数组&quot;&gt;&lt;a href=&quot;#912-排序数组&quot; class=&quot;headerlink&quot; title=&quot;912. 排序数组&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/sort</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="快速排序" scheme="http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简述 TCP 的 TIME_WAIT</title>
    <link href="http://example.com/2021/02/22/1000-019%E7%AE%80%E8%BF%B0%20TCP%20%E7%9A%84%20TIME_WAIT/"/>
    <id>http://example.com/2021/02/22/1000-019%E7%AE%80%E8%BF%B0%20TCP%20%E7%9A%84%20TIME_WAIT/</id>
    <published>2021-02-22T07:09:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么-TIME-WAIT"><a href="#为什么-TIME-WAIT" class="headerlink" title="为什么 TIME_WAIT"></a>为什么 TIME_WAIT</h1><p>主动关闭连接的一方最终进入 <code>TIME_WAIT</code> 状态等待一段才真正的释放内核中的连接记录，在释放记录之前这个连接使用的本地端口将一直被占用。<br>保持一段时间的 <code>TIME_WAIT</code> 的理由是：担心 <code>ack N+1</code> 没有送达，导致被动方重传 <code>FIN N</code>，那么主动方应当再次响应 <code>ack N+1</code>。<br>如果没有 <code>TIME_WAIT</code> 就直接复用该连接占用的端口，那么万一被动方重传<code>FIN N</code>，那么使用相同端口的新连接就会被错误关闭。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/m8c6bs.png"                      alt="四次挥手"                ></p><h1 id="优化-TIME-WAIT"><a href="#优化-TIME-WAIT" class="headerlink" title="优化 TIME_WAIT"></a>优化 TIME_WAIT</h1><p>谁主动关闭 <code>socket</code>，谁<code>TIME_WAIT</code>。<br>如果双方响应正常，TIME_WAIT 应该只是瞬间状态。</p><h1 id="服务端主动关闭"><a href="#服务端主动关闭" class="headerlink" title="服务端主动关闭"></a>服务端主动关闭</h1><p>无论有多少连接，服务端都只有一个端口，那就是监听端口，大量连接之间的差异仅仅是 TCP 4 元祖的客户端 ip 和 port 不同而已。</p><p>因此服务端<code>TIME_WAIT</code>压根不会耗尽端口，因为它就一个端口。</p><p>那么服务端就不需要优化了吗？对，没必要优化，一个<code>TIME_WAIT</code>的 4 元祖当遇到新的 SYN 时会复用，不需要特殊配置。</p><p>另外，当<code>TIME_WAIT</code>数量超过内核选项 net.ipv4.tcp_max_tw_buckets 的限制时，多余的<code>TIME_WAIT</code>连接将被立即关闭，然后在 netstat -s 中留下如下的溢出统计指标：</p><h1 id="客户端主动关闭"><a href="#客户端主动关闭" class="headerlink" title="客户端主动关闭"></a>客户端主动关闭</h1><p>客户端每个连接都会随机选择一个本地端口，所以最终会导致客户端大量端口处于 TIME_WAIT 状态，这和服务端主动关闭是最大的不同。<br>所以我们通常所说的 TIME_WAIT 问题都是针对客户端的，只是好像很少有人提及这一点。<br>网上有一种优化手段是把 net.ipv4.tcp_max_tw_buckets 调低，这样 TIME_WAIT 连接就会被删除，但是这不是一个最佳手段哈。</p><p>目前唯一安全的选项就是同时开启如下 2 个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;1（连接发起方和接收方都需要开启）</span><br><span class="line">net.ipv4.tcp_tw_reuse&#x3D;1（只影响连接发起方）</span><br></pre></td></tr></table></figure><p>上述配置只影响连接发起方，也就是客户端，对服务端是无效的。<br>它的作用是向外发起连接的时候，可以复用 TIME_WAIT 的端口，但是有一个前提<br>该端口最后一次通讯时间距离当前系统时间&gt;1 秒</p><blockquote><p>摘录于 <a class="link"   href="https://yuerblog.cc/2020/03/09/%E5%85%B3%E4%BA%8Etime_wait%E9%97%AE%E9%A2%98%E7%AE%80%E8%BF%B0%E4%B8%8E%E4%BC%98%E5%8C%96/" >https://yuerblog.cc/2020/03/09/关于time_wait问题简述与优化/<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么-TIME-WAIT&quot;&gt;&lt;a href=&quot;#为什么-TIME-WAIT&quot; class=&quot;headerlink&quot; title=&quot;为什么 TIME_WAIT&quot;&gt;&lt;/a&gt;为什么 TIME_WAIT&lt;/h1&gt;&lt;p&gt;主动关闭连接的一方最终进入 &lt;code&gt;TIME_W</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="四次挥手" scheme="http://example.com/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>简述 http 1.0，1.1，2.0 的主要区别</title>
    <link href="http://example.com/2021/02/22/1000-018%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/02/22/1000-018%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</id>
    <published>2021-02-22T06:07:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>http1.0 到 http1.1 的主要区别，就是从无连接到长连接。<br>http2.0 对比 1.X 版本主要区别就是多路复用。</p><h1 id="http-1-0-特性"><a href="#http-1-0-特性" class="headerlink" title="http 1.0 特性"></a>http 1.0 特性</h1><h2 id="1-无状态"><a href="#1-无状态" class="headerlink" title="1. 无状态"></a>1. 无状态</h2><p>服务器不跟踪不记录请求过的状态<br>对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录</p><h2 id="2-无连接"><a href="#2-无连接" class="headerlink" title="2. 无连接"></a>2. 无连接</h2><p>浏览器每次请求都需要建立 tcp 连接</p><p>无连接导致的性能缺陷有两种：</p><ol><li>无法复用连接<br>每次发送请求，都需要进行一次 tcp 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低</li><li>队头阻塞<br>http1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li></ol><h1 id="http-1-1-特性"><a href="#http-1-1-特性" class="headerlink" title="http 1.1 特性"></a>http 1.1 特性</h1><p>为了解决 http1.0 的性能缺陷，http1.1 出现了</p><h2 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1. 长连接"></a>1. 长连接</h2><p>http1.1 默认保持长连接，数据传输完成保持 tcp 连接不断开,继续用这个通道传输数据。<br>新增 Connection 字段，可以设置 keep-alive 值保持连接不断开。</p><h2 id="2-管道化"><a href="#2-管道化" class="headerlink" title="2. 管道化"></a>2. 管道化</h2><p>基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p><p>基于长连接的基础，我们先看没有管道化请求响应：<br>tcp 没有断开，用的同一个通道<br><code>请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></p><p>管道化的请求响应：<br><code>请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</code><br>即使服务器先准备好响应 2,也是按照请求顺序先返回响应 1<br>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h2 id="3-缓存处理"><a href="#3-缓存处理" class="headerlink" title="3. 缓存处理"></a>3. 缓存处理</h2><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。<br>新增字段 cache-control 来控制</p><h2 id="4-断点传输"><a href="#4-断点传输" class="headerlink" title="4. 断点传输"></a>4. 断点传输</h2><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率<br>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p><h1 id="http-2-0-特性"><a href="#http-2-0-特性" class="headerlink" title="http 2.0 特性"></a>http 2.0 特性</h1><h2 id="1-二进制分帧"><a href="#1-二进制分帧" class="headerlink" title="1. 二进制分帧"></a>1. 二进制分帧</h2><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p><h2 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2. 多路复用"></a>2. 多路复用</h2><p>在共享 TCP 链接的基础上同时发送请求和响应<br>一个 Tcp 中多个 http 请求是并行的</p><h2 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h2><p>http2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p><h2 id="4-服务器推送"><a href="#4-服务器推送" class="headerlink" title="4. 服务器推送"></a>4. 服务器推送</h2><p>服务器可以额外的向客户端推送资源，而无需客户端明确的请求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;p&gt;http1.0 到 http1.1 的主要区别，就是从无连接到长连接。&lt;br&gt;http2.0 对比 1.X 版本主要区别就是多路复用。&lt;/p</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>141. 环形链表</title>
    <link href="http://example.com/2021/02/21/2000-005-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/02/21/2000-005-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-02-21T15:49:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a class="link"   href="https://leetcode-cn.com/problems/linked-list-cycle/" >141. 环形链表<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/3k71ua.png"                      alt="141. 环形链表"                ></p><h1 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        var slowTree &#x3D; head</span><br><span class="line">        var fastTree &#x3D; head?.next</span><br><span class="line"></span><br><span class="line">        while slowTree !&#x3D; nil || fastTree !&#x3D; nil &#123;</span><br><span class="line">            if slowTree &#x3D;&#x3D;&#x3D; fastTree &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            slowTree &#x3D; slowTree?.next</span><br><span class="line">            fastTree &#x3D; fastTree?.next?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        &#x2F;&#x2F; 注意这里使用 Set, 使用 Array 会超时</span><br><span class="line">        &#x2F;&#x2F; ListNode 需要实现 Equatable, Hashable 协议</span><br><span class="line">        var list: Set&lt;ListNode&gt; &#x3D; []</span><br><span class="line">        var head &#x3D; head</span><br><span class="line"></span><br><span class="line">        while head !&#x3D; nil &#123;</span><br><span class="line">            if list.contains(head!) &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            list.insert(head!)</span><br><span class="line">            head &#x3D; head?.next</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Swift-链表-及-实现协议"><a href="#Swift-链表-及-实现协议" class="headerlink" title="Swift 链表 及 实现协议"></a>Swift 链表 及 实现协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    public var val: Int</span><br><span class="line">    public var next: ListNode?</span><br><span class="line">    public init() &#123; self.val &#x3D; 0; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int) &#123; self.val &#x3D; val; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int, _ next: ListNode?) &#123; self.val &#x3D; val; self.next &#x3D; next &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Equatable &#123;</span><br><span class="line">    public static func &#x3D;&#x3D; (l: ListNode, r: ListNode) -&gt; Bool &#123;</span><br><span class="line">        return l &#x3D;&#x3D;&#x3D; r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Hashable &#123;</span><br><span class="line">    public func hash(into hasher: inout Hasher) &#123;</span><br><span class="line">        hasher.combine(ObjectIdentifier(self))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;141-环形链表&quot;&gt;&lt;a href=&quot;#141-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. 环形链表&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/link</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="快慢指针" scheme="http://example.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="http://example.com/2021/02/21/2000-004-33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/02/21/2000-004-33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-02-21T14:21:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" >33. 搜索旋转排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/8z9prz.png"                      alt="33. 搜索旋转排序数组"                ></p><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func search(_ nums: [Int], _ target: Int) -&gt; Int &#123;</span><br><span class="line">        if nums.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return (nums[0] &#x3D;&#x3D; target) ? 0 : -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; nums.count - 1</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; left &lt;&#x3D; right 说明相遇了 在变就错过</span><br><span class="line">        while left &lt;&#x3D; right &#123; </span><br><span class="line">            &#x2F;&#x2F; 确定中间值</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; nums[mid] &lt; nums[right] 说明 mid 右边是有序递增的</span><br><span class="line">            if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">                &#x2F;&#x2F;如果 target 值在这个有序递增的范围内那就能确定 left 了，这里包含了右边等于 target 值的情况</span><br><span class="line">                if target &gt; nums[mid], target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right &#x3D; mid - 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; nums[mid] &gt; nums[right]  说明突变值（最小值）在 mid 右边，则 mid 左边是有序递增的</span><br><span class="line">                if target &gt;&#x3D; nums[left], target &lt; nums[mid] &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果 target 值在这个有序递增的范围内那就能确定 right 了，这里包含了左边等于 target 值的情况</span><br><span class="line">                    right &#x3D; mid - 1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;33-搜索旋转排序数组&quot;&gt;&lt;a href=&quot;#33-搜索旋转排序数组&quot; class=&quot;headerlink&quot; title=&quot;33. 搜索旋转排序数组&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="二分搜索" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <link href="http://example.com/2021/02/21/2000-003-1382.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/"/>
    <id>http://example.com/2021/02/21/2000-003-1382.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</id>
    <published>2021-02-21T13:49:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382. 将二叉搜索树变平衡"></a><a class="link"   href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" >1382. 将二叉搜索树变平衡<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/qm12q4.png"                      alt="1382. 将二叉搜索树变平衡"                ></p><h1 id="先变为有序递增数组，再平衡"><a href="#先变为有序递增数组，再平衡" class="headerlink" title="先变为有序递增数组，再平衡"></a>先变为有序递增数组，再平衡</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    func balanceBST(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        getList(root)</span><br><span class="line">        return buildTree(list, 0, list.count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func buildTree(_ nums: [Int], _ left: Int, _ right: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if left &gt; right &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">        let root &#x3D; TreeNode(nums[mid])</span><br><span class="line">        root.left &#x3D; buildTree(nums, left, mid - 1)</span><br><span class="line">        root.right &#x3D; buildTree(nums, mid + 1, right)</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉搜索树</span><br><span class="line">&#x2F;&#x2F;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； </span><br><span class="line">&#x2F;&#x2F; 所以采用中序遍历  先左 再根 最后右  刚好是递增数组</span><br><span class="line">    func getList(_ root: TreeNode?) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        getList(root.left)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        getList(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1382-将二叉搜索树变平衡&quot;&gt;&lt;a href=&quot;#1382-将二叉搜索树变平衡&quot; class=&quot;headerlink&quot; title=&quot;1382. 将二叉搜索树变平衡&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="二叉搜索树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    <category term="平衡树" scheme="http://example.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="http://example.com/2021/02/21/2000-002-108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://example.com/2021/02/21/2000-002-108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2021-02-21T13:23:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a class="link"   href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" >108. 将有序数组转换为二叉搜索树<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/hq8ztg.png"                      alt="108. 将有序数组转换为二叉搜索树"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func sortedArrayToBST(_ nums: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">    return sortTree(nums, 0, nums.count - 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sortTree(_ nums: [Int], _ left: Int, _ right: Int) -&gt; TreeNode? &#123;</span><br><span class="line">    if left &gt; right &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    let mid &#x3D; (left + right) &#x2F; 2</span><br><span class="line">    let root &#x3D; TreeNode(nums[mid])</span><br><span class="line">    root.left &#x3D; sortTree(nums, left, mid - 1)</span><br><span class="line">    root.right &#x3D; sortTree(nums, mid + 1, right)</span><br><span class="line"></span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;108-将有序数组转换为二叉搜索树&quot;&gt;&lt;a href=&quot;#108-将有序数组转换为二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;108. 将有序数组转换为二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://le</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>674. 最长连续递增序列</title>
    <link href="http://example.com/2021/02/21/2000-001-674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2021/02/21/2000-001-674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</id>
    <published>2021-02-21T11:43:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a class="link"   href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" >674. 最长连续递增序列<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/a0hi84.png"                      alt="题目描述"                ></p><h1 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func findLengthOfLCIS(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        var start &#x3D; 0</span><br><span class="line">        var maxCount &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for (index, _) in nums.enumerated() &#123;</span><br><span class="line">            if index &gt; 0, nums[index] &lt;&#x3D; nums[index - 1] &#123;</span><br><span class="line">                start &#x3D; index</span><br><span class="line">            &#125;</span><br><span class="line">            let currentCount &#x3D; index - start + 1</span><br><span class="line">            maxCount &#x3D; (maxCount &gt; currentCount) ? maxCount : currentCount</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func findLengthOfLCIS(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        if nums.count &lt; 2 &#123;</span><br><span class="line">            return nums.count</span><br><span class="line">        &#125;</span><br><span class="line">        var maxCount &#x3D; 0</span><br><span class="line">        var preNumber &#x3D; nums.first</span><br><span class="line">        var tempCount &#x3D; 0</span><br><span class="line">        for item in nums &#123;</span><br><span class="line">            let isAdd &#x3D; item &gt; preNumber!</span><br><span class="line">            if isAdd &#123;</span><br><span class="line">                tempCount +&#x3D; 1</span><br><span class="line">                maxCount &#x3D; (maxCount &gt; tempCount) ? maxCount : tempCount</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tempCount &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">            preNumber &#x3D; item</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount + 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;674-最长连续递增序列&quot;&gt;&lt;a href=&quot;#674-最长连续递增序列&quot; class=&quot;headerlink&quot; title=&quot;674. 最长连续递增序列&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="贪心算法" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>简述 TCP 滑动窗口以及重传机制</title>
    <link href="http://example.com/2021/02/21/1000-017%E7%AE%80%E8%BF%B0%20TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/02/21/1000-017%E7%AE%80%E8%BF%B0%20TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-21T10:35:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h1><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。（TCP 会在以下两种情况发生超时重传：数据包丢失，确认应答丢失）</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-滑动窗口&quot;&gt;&lt;a href=&quot;#TCP-滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;TCP 滑动窗口&quot;&gt;&lt;/a&gt;TCP 滑动窗口&lt;/h1&gt;&lt;p&gt;窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</title>
    <link href="http://example.com/2021/02/21/1000-016TCP%20%E4%B8%8E%20UDP%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2021/02/21/1000-016TCP%20%E4%B8%8E%20UDP%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2021-02-21T10:20:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-与-UDP-在网络协议中的哪一层？"><a href="#TCP-与-UDP-在网络协议中的哪一层？" class="headerlink" title="TCP 与 UDP 在网络协议中的哪一层？"></a>TCP 与 UDP 在网络协议中的哪一层？</h1><p><strong>属于传输层协议</strong></p><h1 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h1><ol><li><p><strong>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。</strong></p></li><li><p><strong>TCP注重数据安全性，UDP数据传输快。</strong>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p></li><li><p><strong>UDP具有较好的实时性，工作效率比TCP高，</strong>适用于对高速传输和实时性有较高的通信或广播通信。</p></li><li><p><strong>TCP 一对一， UDP 一对一、一对多、多对一、多对多。</strong> 每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</p></li><li><p><strong>TCP对系统资源要求较多，UDP对系统资源要求较少。</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-与-UDP-在网络协议中的哪一层？&quot;&gt;&lt;a href=&quot;#TCP-与-UDP-在网络协议中的哪一层？&quot; class=&quot;headerlink&quot; title=&quot;TCP 与 UDP 在网络协议中的哪一层？&quot;&gt;&lt;/a&gt;TCP 与 UDP 在网络协议中的哪一层？&lt;/</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="UDP" scheme="http://example.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>Cookie 和 Session 的关系和区别是什么？</title>
    <link href="http://example.com/2021/02/18/1000-015Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2021/02/18/1000-015Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-02-18T03:55:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie-和-Session-的关系和区别"><a href="#Cookie-和-Session-的关系和区别" class="headerlink" title="Cookie 和 Session 的关系和区别"></a>Cookie 和 Session 的关系和区别</h1><ol><li>Cookie 在客户端（浏览器），Session 在服务器端。 </li><li>Cookie 的安全性一般，他人可通过分析存放在本地的 Cookie 并进行 Cookie 欺骗。在安全性第一的前提下，选择 Session 更优。重要交互信息比如权限等就要放在 Session 中，一般的信息记录放 Cookie 就好了。 </li><li>单个 Cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 Cookie。 </li><li>Session 可以放在文件、数据库或内存中，比如在使用 Node 时将 Session 保存在 redis 中。由于一定时间内它是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用 Cookie。 </li><li>Session 的运行依赖 Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID）。 </li><li>用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即 Session ID。</li></ol><p>题外话，那么话说 Session Cookie 能被篡改么？ 理论上可以，只要改变了连接时的 Session ID 就可以了~</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息。如何识别特定的客户呢？cookie 就可以做到。每次 HTTP 请求时，客户端都会发送相应的 Cookie 信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。<br>既然它是存储在客户端的，换句话说通过某些手法我就可以篡改本地存储的信息来欺骗服务端的某些策略。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session 是在无状态的 HTTP 协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。在浏览器关闭后这次的 Session 就消失了，下次打开就不再拥有这个 Session。其实并不是 Session 消失了，而是 Session ID 变了，服务器端可能还是存着你上次的 Session ID 及其 Session 信息，只是他们是无主状态，也许一段时间后会被删除。</p><hr><p>实际上 Cookie 与 Session 都是会话的一种方式。它们的典型使用场景比如 “购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建 Cookie/Session 来获取这些信息。</p><p>如果你的站点是多节点部署，使用 Nginx 做负载均衡，那么有可能会出现 Session 丢失的情况（比如，忽然就处于未登录状态）。这时可以使用 IP 负载均衡（IP 绑定 ip_hash，每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 Session 的问题），或者将 Session 信息存储在集群中。在大型的网站中，一般会有专门的 Session 服务器集群，用来保存用户会话，这时可以使用缓存服务比如 Memcached 或者 Redis 之类的来存放 Session。</p><p>目前大多数的应用都是用 Cookie 实现 Session 跟踪的。第一次创建 Session 时，服务端会通过在 HTTP 协议中反馈到客户端，需要在 Cookie 中记录一个 Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用 URL 重写技术进行会话跟踪，即每次 HTTP 交互，URL 后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。</p><blockquote><p>摘录于 <a class="link"   href="https://ruby-china.org/topics/33313" >https://ruby-china.org/topics/33313<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cookie-和-Session-的关系和区别&quot;&gt;&lt;a href=&quot;#Cookie-和-Session-的关系和区别&quot; class=&quot;headerlink&quot; title=&quot;Cookie 和 Session 的关系和区别&quot;&gt;&lt;/a&gt;Cookie 和 Session </summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Cookie" scheme="http://example.com/tags/Cookie/"/>
    
    <category term="Session" scheme="http://example.com/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>简述 JWT 的原理和校验机制</title>
    <link href="http://example.com/2021/02/17/1000-014%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/02/17/1000-014%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-17T07:10:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。"><a href="#JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。" class="headerlink" title="JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。"></a>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。</h1><h1 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h1><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h1 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h1><p>实际的 JWT 大概就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGcio1JIUZIINiIsInR5CCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIioiIxMiMONTY30DkwIiwibmFtZSI6IkpvaG4</span><br><span class="line">gRG9IIiwiaXNTb2NpYWwiOnRydWv9.</span><br><span class="line">4pcPyMD09oIPSyXnrXCjTwXyr4BsezdI1AVTmud2fU4</span><br></pre></td></tr></table></figure><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是下面的样子。<br><code>Header.Payload.Signature</code></p><h2 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h2 id="Payload（负载）"><a href="#Payload（负载）" class="headerlink" title="Payload（负载）"></a>Payload（负载）</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h2 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。<br><code>Authorization: Bearer &lt;token&gt;</code><br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。<br>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><blockquote><p>摘录于 <a class="link"   href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" >https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。&quot;&gt;&lt;a href=&quot;#JSON-Web-Token（缩写-JWT）是目前最流行的跨域认证解决方案。&quot; class=&quot;headerlink&quot; title=&quot;JSON Web Token（缩</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="JWT" scheme="http://example.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的方法有哪些？</title>
    <link href="http://example.com/2021/02/17/1000-013HTTP%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2021/02/17/1000-013HTTP%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2021-02-17T06:45:00.000Z</published>
    <updated>2021-02-23T16:02:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h1><p>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</p><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p><h1 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h1><p>POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </p><h1 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h1><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p><h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>DELETE方法删除指定的资源。</p><h1 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h1><p>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p><h1 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h1><p>OPTIONS方法用于描述目标资源的通信选项。</p><h1 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h1><p>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</p><h1 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h1><p>PATCH方法用于对资源应用部分修改。</p><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为HTTP动词. 每一个请求方法都实现了不同的语义, 但一些共同的特征由一组共享：: 例如一个请求方法可以是 safe(安全), idempotent(幂等), 或 cacheable(可缓存).</p><h2 id="safe-安全"><a href="#safe-安全" class="headerlink" title="safe(安全)"></a>safe(安全)</h2><p>如果说一个 HTTP 方法是安全的，是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD 和 OPTIONS。所有安全的方法都是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是。</p><h2 id="idempotent-幂等"><a href="#idempotent-幂等" class="headerlink" title="idempotent(幂等)"></a>idempotent(幂等)</h2><p>一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。</p><h2 id="cacheable-可缓存"><a href="#cacheable-可缓存" class="headerlink" title="cacheable(可缓存)"></a>cacheable(可缓存)</h2><p>可缓存的响应是可被缓存的HTTP 响应，它被存储以供稍后检索和使用，从而将新的请求保存在伺服器。不是所有的 HTTP 响应都可以被缓存，可以被缓存的 HTTP 响应需满足如下列条件:</p><ul><li>请求中使用的方法本身是可以被缓存的，如 GET 或 HEAD 方法。如果下达了新的指示，响应 POST 方法也可以被缓存，但这种实施方式极为罕见。其他方法，如： PUT 或 DELETE 都不可以被缓存，同样他们的处理结果也不可以。</li><li>应用程式是会缓存已知的响应的状态码，并且被认为是可缓存的。这些可缓存的状态码如下： 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 和 501.</li><li>响应中没有指定的头部，如 Cache-Control，它可以阻止缓存。<br>请注意一些不缓存请求/响应到指定的 URI 可能会导致相同 URI 上以前的缓存响应失效。例如，  PUT 到 pageX.html 将使相同 URI 下所有的 GET 或 HEAD 请求缓存失效。</li></ul><blockquote><p>摘录于 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" >https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GET&quot;&gt;&lt;a href=&quot;#GET&quot; class=&quot;headerlink&quot; title=&quot;GET&quot;&gt;&lt;/a&gt;GET&lt;/h1&gt;&lt;p&gt;GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.&lt;/p&gt;
&lt;h1 id=&quot;HEAD&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
