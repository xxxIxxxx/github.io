<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-16T15:32:05.564Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络协议</title>
    <link href="http://example.com/2021/06/16/1000-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/06/16/1000-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-06-15T16:00:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分：协议层次以及它们的服务类型"><a href="#第一部分：协议层次以及它们的服务类型" class="headerlink" title="第一部分：协议层次以及它们的服务类型"></a>第一部分：协议层次以及它们的服务类型</h1><h2 id="OSI-七层模型-🌟🌟🌟🌟🌟"><a href="#OSI-七层模型-🌟🌟🌟🌟🌟" class="headerlink" title="OSI 七层模型 🌟🌟🌟🌟🌟"></a>OSI 七层模型 🌟🌟🌟🌟🌟</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/ptp0ou.png"                                     ><br>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。 OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p><p>① 应用层</p><p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。</p><p>② 表示层</p><p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p><p>③ 会话层</p><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p><p>④ 传输层</p><p>传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p><p>⑤ 网络层</p><p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p><p>⑥ 数据链路层</p><p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p><p>⑦ 物理层</p><p>作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p><h2 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h2><p>OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。而 TCP/IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。</p><p>① 应用层</p><p>TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p><p>② 传输层</p><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p><p>③ 网际互联层</p><p>网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p><p>④ 网络接入层</p><p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p><h2 id="TCP-IP-五层参考模型"><a href="#TCP-IP-五层参考模型" class="headerlink" title="TCP/IP 五层参考模型"></a>TCP/IP 五层参考模型</h2><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h2 id="OSI-模型和-TCP-IP-模型异同比较-🌟🌟🌟🌟"><a href="#OSI-模型和-TCP-IP-模型异同比较-🌟🌟🌟🌟" class="headerlink" title="OSI 模型和 TCP/IP 模型异同比较 🌟🌟🌟🌟"></a>OSI 模型和 TCP/IP 模型异同比较 🌟🌟🌟🌟</h2><p><strong>相同点</strong></p><p>① OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p><p>② 都能够提供面向连接和无连接两种通信服务机制。</p><p><strong>不同点</strong></p><p>① OSI 采用的七层模型； TCP/IP 是四层结构。</p><p>② TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p><p>③ OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p><p>④ TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p><p>⑤ OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p><h2 id="OSI-和-TCP-IP-协议之间的对应关系"><a href="#OSI-和-TCP-IP-协议之间的对应关系" class="headerlink" title="OSI 和 TCP/IP 协议之间的对应关系"></a>OSI 和 TCP/IP 协议之间的对应关系</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/0yqy24.png"                                     ></p><table><thead><tr><th>OSI 七层网络模型</th><th>TCP/IP 四层概念模型</th><th>对应的网络协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP,DNS,FTP,TFTP</td></tr><tr><td>表示层</td><td>应用层</td><td>GIF,JPEG,TIFF,PICT</td></tr><tr><td>会话层</td><td>应用层</td><td>RPC,SQL,NFS</td></tr><tr><td>传输层</td><td>传输层</td><td>TCP,UDP</td></tr><tr><td>网络层层</td><td>网络层</td><td>IP,ARP,ICMP,RARP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>FDDI,Frame Relay,HDLC</td></tr><tr><td>物理层</td><td>数据链路层</td><td>EIA/TIA-232,EIA/TIA-499,V.35</td></tr></tbody></table><h2 id="数据如何在各层之间传输【数据的封装过程】🌟🌟🌟"><a href="#数据如何在各层之间传输【数据的封装过程】🌟🌟🌟" class="headerlink" title="数据如何在各层之间传输【数据的封装过程】🌟🌟🌟"></a>数据如何在各层之间传输【数据的封装过程】🌟🌟🌟</h2><p>在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p><h1 id="第二部分：应用层"><a href="#第二部分：应用层" class="headerlink" title="第二部分：应用层"></a>第二部分：应用层</h1><h2 id="HTTP-头部包含哪些信息-🌟🌟🌟"><a href="#HTTP-头部包含哪些信息-🌟🌟🌟" class="headerlink" title="HTTP 头部包含哪些信息 🌟🌟🌟"></a>HTTP 头部包含哪些信息 🌟🌟🌟</h2><p><strong>通用头部</strong><br>协议头|说明|举例<br>-|-|-<br>Cache-Control |用来指定当前的请求/回复中是否使用缓存机制|Cache-Control: no-store<br>Connection|客户端（浏览器）想要优先使用的连接类型|Connection: keep-alive (Upgrade)<br>Date|报文创建时间|Date: Dec, 26 Dec 2015 17: 30: 00 GMT</p><p><strong>请求头部</strong><br>协议头|说明|举例<br>-|-|-<br>Authorization|用于表示 HTTP 协议中需要认证资源的认证信息|Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==<br>Host|表示服务器的域名以及服务器所监听的端口号|Host: <a class="link"   href="http://www.itbilu.com/" >www.itbilu.com:80<i class="fas fa-external-link-alt"></i></a><br>Range|表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面|Range: bytes=500-999<br>User-Agent |浏览器的身份标识字符串|User-Agent: Mozilla/……</p><p><strong>响应头部</strong><br>协议头|说明|举例<br>-|-|-<br>Age|创建响应的时间|Age：5744337<br>Location|表示重定向后的 URL|Location: <a class="link"   href="http://www.zcmhi.com/archives/94.html" >http://www.zcmhi.com/archives/94.html<i class="fas fa-external-link-alt"></i></a><br>Vary|缓存控制|Vary: Origin</p><p><strong>实体头部</strong><br>协议头|说明|举例<br>-|-|-<br>Content-Length|返回内容的字节长度|Content-Length: 348<br>Content-Range|在整个返回体中本部分的字节位置 |Content-Range: bytes 21010-47021/47022<br>Content-Type |返回内容的 MIME 类型|Content-Type: text/html; charset=utf-8</p><h2 id="Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗？-🌟🌟🌟"><a href="#Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗？-🌟🌟🌟" class="headerlink" title="Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗？ 🌟🌟🌟"></a>Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗？ 🌟🌟🌟</h2><p>在早期的 HTTP/1.0 中，浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在 HTTP/1.1 版本中默认使用持久连接，在此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 connection 的首部字段的值为 Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流，我们用一个示意图来更加生动的表示两者的区别：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/qzbhuj.png"                                     ><br>对于非 Keep=Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担，因为一台 Web 服务器可能同时服务于数以百计的客户机请求。在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。</p><p>然而，Keep-Alive 并不是没有缺点的，当长时间的保持 TCP 连接时容易导致系统资源被无效占用，若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。</p><h2 id="HTTP-长连接短连接使用场景是什么"><a href="#HTTP-长连接短连接使用场景是什么" class="headerlink" title="HTTP 长连接短连接使用场景是什么"></a>HTTP 长连接短连接使用场景是什么</h2><p><strong>长连接：</strong> 多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p><p><strong>短连接：</strong> 用户数目较多的 Web 网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p><h2 id="怎么知道-HTTP-的报文长度"><a href="#怎么知道-HTTP-的报文长度" class="headerlink" title="怎么知道 HTTP 的报文长度"></a>怎么知道 HTTP 的报文长度</h2><p>当响应消息中存在 Content-Length 字段时，我们可以直接根据这个值来判断数据是否接收完成，例如客户端向服务器请求一个静态页面或者一张图片时，服务器能够很清楚的知道请求内容的大小，因此可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据，但是如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length。</p><p>分块传输编码（Chunked transfer encoding）是 HTTP/1.1 中引入的一种数据传输机制，其允许 HTTP 由服务器发送给客户端的数据可以分成多个部分，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为 0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</p><h2 id="HTTP-方法了解哪些"><a href="#HTTP-方法了解哪些" class="headerlink" title="HTTP 方法了解哪些"></a>HTTP 方法了解哪些</h2><p>HTTP/1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。</p><p>HTTP/1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。</p><h2 id="GET-和-POST-的区别-🌟🌟🌟🌟🌟"><a href="#GET-和-POST-的区别-🌟🌟🌟🌟🌟" class="headerlink" title="GET 和 POST 的区别 🌟🌟🌟🌟🌟"></a>GET 和 POST 的区别 🌟🌟🌟🌟🌟</h2><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li></ul><h2 id="GET-的长度限制是多少-🌟🌟🌟"><a href="#GET-的长度限制是多少-🌟🌟🌟" class="headerlink" title="GET 的长度限制是多少 🌟🌟🌟"></a>GET 的长度限制是多少 🌟🌟🌟</h2><p>HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，例如 IE 浏览器对 URL 的最大限制为 2000 多个字符，大概 2KB 左右，像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET 的长度限制不同。</p><p>由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</p><h2 id="HTTP-与-HTTPs-的工作方式【建立连接的过程】🌟🌟🌟🌟"><a href="#HTTP-与-HTTPs-的工作方式【建立连接的过程】🌟🌟🌟🌟" class="headerlink" title="HTTP 与 HTTPs 的工作方式【建立连接的过程】🌟🌟🌟🌟"></a>HTTP 与 HTTPs 的工作方式【建立连接的过程】🌟🌟🌟🌟</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p><p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p><p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p><p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p><p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p><p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p><p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用 pre_master_secre 加密的。</p><p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p><p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p><p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p><h2 id="HTTPS-和-HTTP-的区别-🌟🌟🌟🌟"><a href="#HTTPS-和-HTTP-的区别-🌟🌟🌟🌟" class="headerlink" title="HTTPS 和 HTTP 的区别 🌟🌟🌟🌟"></a>HTTPS 和 HTTP 的区别 🌟🌟🌟🌟</h2><ul><li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</li><li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li><li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</li></ul><h2 id="HTTPS-的加密方式"><a href="#HTTPS-的加密方式" class="headerlink" title="HTTPS 的加密方式"></a>HTTPS 的加密方式</h2><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h2 id="客户端为什么信任第三方证书"><a href="#客户端为什么信任第三方证书" class="headerlink" title="客户端为什么信任第三方证书"></a>客户端为什么信任第三方证书</h2><p>假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</p><p>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</p><h2 id="HTTP-是不保存状态的协议-如何保存用户状态-🌟🌟🌟🌟"><a href="#HTTP-是不保存状态的协议-如何保存用户状态-🌟🌟🌟🌟" class="headerlink" title="HTTP 是不保存状态的协议,如何保存用户状态 🌟🌟🌟🌟"></a>HTTP 是不保存状态的协议,如何保存用户状态 🌟🌟🌟🌟</h2><p>我们知道，假如某个特定的客户机在短时间内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象就不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不久之前所做过的是一样。因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。</p><p>通常有两种解决方案：</p><h3 id="①-基于-Session-实现的会话保持"><a href="#①-基于-Session-实现的会话保持" class="headerlink" title="① 基于 Session 实现的会话保持"></a>① 基于 Session 实现的会话保持</h3><p>在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p><p><strong>优点：</strong> 安全性高，因为状态信息保存在服务器端。</p><p><strong>缺点：</strong> 由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p><p>【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】</p><h3 id="②-基于-Cookie-实现的会话保持"><a href="#②-基于-Cookie-实现的会话保持" class="headerlink" title="② 基于 Cookie 实现的会话保持"></a>② 基于 Cookie 实现的会话保持</h3><p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</p><p><strong>优点：</strong> 服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。</p><p><strong>缺点：</strong> 该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p><h3 id="拓展：Cookie-被禁用了怎么办？"><a href="#拓展：Cookie-被禁用了怎么办？" class="headerlink" title="拓展：Cookie 被禁用了怎么办？"></a>拓展：Cookie 被禁用了怎么办？</h3><p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p><h2 id="面试时针对状态码的常见问法-🌟🌟🌟🌟"><a href="#面试时针对状态码的常见问法-🌟🌟🌟🌟" class="headerlink" title="面试时针对状态码的常见问法 🌟🌟🌟🌟"></a>面试时针对状态码的常见问法 🌟🌟🌟🌟</h2><p>① 状态码 301 和 302 的区别？</p><p>301：永久移动。请求的资源已被永久的移动到新的 URI，旧的地址已经被永久的删除了。返回信息会包括新的 URI，浏览器会自动定向到新的 URI。今后新的请求都应使用新的 URI 代替。</p><p>302：临时移动。与 301 类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有 URI。</p><p>② HTTP 异常状态码知道哪些？</p><p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p><table><thead><tr><th>状态码</th><th>英文名</th><th>中文描述</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有 URI</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解；请求的参数有误</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证</td></tr><tr><td>404</td><td>Not Found</td><td>请求失败，请求所希望得到的资源未被在服务器上发现</td></tr><tr><td>500</td><td>Internal Server</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</td></tr><tr><td>501</td><td>Not Implemented 服务器不支持当前请求所需要的某个功能</td><td></td></tr><tr><td>502</td><td>Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应</td><td></td></tr></tbody></table><h2 id="HTTP-1-1-和-HTTP-1-0-的区别-🌟🌟🌟"><a href="#HTTP-1-1-和-HTTP-1-0-的区别-🌟🌟🌟" class="headerlink" title="HTTP/1.1 和 HTTP/1.0 的区别 🌟🌟🌟"></a>HTTP/1.1 和 HTTP/1.0 的区别 🌟🌟🌟</h2><p>缓存处理：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。</p><p>节约带宽： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p><p>错误通知的管理：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p><p>Host 请求头：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p><p>长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p><h2 id="HTTP-1-X-和-HTTP-2-0-的区别-🌟🌟🌟"><a href="#HTTP-1-X-和-HTTP-2-0-的区别-🌟🌟🌟" class="headerlink" title="HTTP/1.X 和 HTTP/2.0 的区别 🌟🌟🌟"></a>HTTP/1.X 和 HTTP/2.0 的区别 🌟🌟🌟</h2><p>相比于 HTTP/1.X 的文本（字符串）传送， HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。</p><p>HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。</p><p>HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。</p><p>HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。</p><h2 id="HTTP-3-了解吗-🌟🌟🌟"><a href="#HTTP-3-了解吗-🌟🌟🌟" class="headerlink" title="HTTP/3 了解吗 🌟🌟🌟"></a>HTTP/3 了解吗 🌟🌟🌟</h2><h3 id="HTTP-2-存在的问题"><a href="#HTTP-2-存在的问题" class="headerlink" title="HTTP/2 存在的问题"></a>HTTP/2 存在的问题</h3><p>我们知道，传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的 HTTP/2，也无法完全解决 TCP 协议存在的固有问题（慢启动，拥塞窗口尺寸的设置等）。此外，HTTP/2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP/2 的表现将不如 HTTP/1.1。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>QUIC（Quick UDP Internet Connections），直译为快速 UDP 网络连接，是谷歌制定的一种基于 UDP 的低延迟传输协议。其主要目的是解决采用传输层 TCP 协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了 TCP, TLS, HTTP/2 等协议的特性，并基于 UDP 传输。该协议带来的主要提升有：</p><p>低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。</p><p>QUIC 复用了 HTTP/2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP/2 存在的队头阻塞问题。<br>基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。</p><p>QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。</p><p>具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。HTTP/3 主要有以下几个特点：</p><p>① 使用 UDP 作为传输层进行通信；</p><p>② 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手；</p><p>③ 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；</p><p>④ 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；</p><p>⑤ 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。</p><p>最后我们使用一张图来清晰的表示出 HTTP 协议的发展变化：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/aqw6ns.png"                                     ></p><h2 id="DNS-的作用和原理-🌟🌟🌟🌟"><a href="#DNS-的作用和原理-🌟🌟🌟🌟" class="headerlink" title="DNS 的作用和原理 🌟🌟🌟🌟"></a>DNS 的作用和原理 🌟🌟🌟🌟</h2><p>DNS</p><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。</p><p>DNS 的作用</p><p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>DNS 域名解析原理</p><p>DNS 采用了分布式的设计方案，其域名空间采用一种树形的层次结构：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/lian6m.png"                                     ><br>上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。其实根域名服务器在因特网上有 13 个，大部分位于北美洲。第二层为顶级域服务器，这些服务器负责顶级域名（如 com、org、net、edu）和所有国家的顶级域名（如 uk、fr、ca 和 jp）。在第三层为权威 DNS 服务器，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/hwcxay.png"                                     ><br>在上图中，IP 地址的查询其实经历了两种查询方式，分别是递归查询和迭代查询。</p><p>拓展：域名解析查询的两种方式</p><p><strong>递归查询：</strong> 如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。<br><strong>迭代查询：</strong> 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）。</p><h2 id="DNS-为什么用-UDP"><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h2><p>更正确的答案是 DNS 既使用 TCP 又使用 UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><h2 id="怎么实现-DNS-劫持"><a href="#怎么实现-DNS-劫持" class="headerlink" title="怎么实现 DNS 劫持"></a>怎么实现 DNS 劫持</h2><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。</p><p>具体实施步骤如下：</p><p>① 获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息。</p><p>② 控制域名相应的 E-MAIL 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码。更高级的攻击者甚至能够直接对 E-mail 进行信息窃取。</p><p>③ 修改注册信息：当攻击者破解了 E-MAIL 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。</p><p>④ 使用 E-MAIL 收发确认函：在修改完注册信息后，攻击者在 E-mail 真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。</p><p>用户端的一些预防手段：</p><p>直接通过 IP 地址访问网站，避开 DNS 劫持。<br>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8。</p><h2 id="socket-套接字有哪些-🌟🌟🌟"><a href="#socket-套接字有哪些-🌟🌟🌟" class="headerlink" title="socket() 套接字有哪些 🌟🌟🌟"></a>socket() 套接字有哪些 🌟🌟🌟</h2><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p><p>套接字主要有以下三种类型：</p><p>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</p><p>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</p><p>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</p><h2 id="URI（统一资源标识符）和-URL（统一资源定位符）之间的区别-🌟🌟🌟"><a href="#URI（统一资源标识符）和-URL（统一资源定位符）之间的区别-🌟🌟🌟" class="headerlink" title="URI（统一资源标识符）和 URL（统一资源定位符）之间的区别 🌟🌟🌟"></a>URI（统一资源标识符）和 URL（统一资源定位符）之间的区别 🌟🌟🌟</h2><p>URL，即统一资源定位符 (Uniform Resource Locator )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。例如 <a class="link"   href="https://leetcode-cn.com/problemset/all/" >https://leetcode-cn.com/problemset/all/<i class="fas fa-external-link-alt"></i></a> 这个 URL，标识一个特定资源并表示该资源的某种形式是可以通过 HTTP 协议从相应位置获得。</p><p>从定义即可看出，URL 是 URI 的一个子集，两者都定义了资源是什么，而 URL 还定义了如何能访问到该资源。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而 URL 则必须提供足够的信息来定位，是绝对的。简单地说，只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL。</p><h2 id="为什么-fidder，charles-能抓到你的包【抓取数据包的过程】"><a href="#为什么-fidder，charles-能抓到你的包【抓取数据包的过程】" class="headerlink" title="为什么 fidder，charles 能抓到你的包【抓取数据包的过程】"></a>为什么 fidder，charles 能抓到你的包【抓取数据包的过程】</h2><p>假如我们需要抓取客户端的数据包，需要监控客户端与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。而中间的网络节点不受我们控制，是基本无法实现抓包的，因此只能在客户端与服务器之间进行抓包。</p><p>① 当采用抓包工具抓取 HTTP 数据包时，过程较为简单：</p><p>首先抓包工具会提出代理服务，客户端需要连接该代理；<br>客户端发出 HTTP 请求时，会经过抓包工具的代理，抓包工具将请求的原文进行展示；<br>抓包工具使用该原文将请求发送给服务器；<br>服务器返回结果给抓包工具，抓包工具将返回结果进行展示；<br>抓包工具将服务器返回的结果原样返回给客户端。<br>这里抓包工具相当于透明人，数据经过的时候它一只手接到数据，然后另一只手把数据传出去。</p><p>② 当抓取 HTTPS 数据包时：</p><p>客户端连接抓包工具提供的代理服务，并安装抓包工具的根证书；<br>客户端发出 HTTPS 请求，抓包工具模拟服务器与客户端进行 TLS 握手交换密钥等流程；<br>抓包工具发送一个 HTTPS 请求给客户端请求的目标服务器，并与目标服务器进行 TLS 握手交换密钥等流程；<br>客户端使用与抓包工具协定好的密钥加密数据后发送给抓包工具；<br>抓包工具使用与客户端协定好的密钥解密数据，并将结果进行展示；<br>抓包工具将解密后的客户端数据，使用与服务器协定好的密钥进行加密后发送给目标服务器；<br>服务器解密数据后，做对应的逻辑处理，然后将返回结果使用与抓包工具协定好的密钥进行加密发送给抓包工具；<br>抓包工具将服务器返回的结果，用与服务器协定好的密钥解密，并将结果进行展示；<br>抓包工具将解密后的服务器返回数据，使用与客户端协定好的密钥进行加密后发送给客户端；<br>客户端解密数据。<br>这个时候抓包工具对客户端来说相当于服务器，对服务器来说相当于客户端。在这个传输过程中，客户端会以为它就是目标服务器，服务器也会以为它就是请求发起的客户端。</p><h2 id="如果你访问一个网站很慢，怎么排查和解决"><a href="#如果你访问一个网站很慢，怎么排查和解决" class="headerlink" title="如果你访问一个网站很慢，怎么排查和解决"></a>如果你访问一个网站很慢，怎么排查和解决</h2><p>网页打开速度慢的原因有很多，这里列举出一些较常出现的问题：</p><p>① 首先最直接的方法是查看本地网络是否正常，可以通过网络测速软件例如电脑管家等对电脑进行测速，若网速正常，我们查看网络带宽是否被占用，例如当你正在下载电影时并且没有限速，是会影响你打开网页的速度的，这种情况往往是处理器内存小导致的；</p><p>② 当网速测试正常时，我们对网站服务器速度进行排查，通过 ping 命令查看链接到服务器的时间和丢包等情况，一个速度好的机房，首先丢包率不能超过 1%，其次 ping 值要小，最后是 ping 值要稳定，如最大和最小差值过大说明路由不稳定。或者我们也可以查看同台服务器上其他网站的打开速度，看是否其他网站打开也慢。</p><p>③ 如果网页打开的速度时快时慢，甚至有时候打不开，有可能是空间不稳定的原因。当确定是该问题时，就要找你的空间商解决或换空间商了，如果购买空间的话，可选择购买购买双线空间或多线空间；如果是在有的地方打开速度快，有的地方打开速度慢，那应该是网络线路的问题。电信线路用户访问放在联通服务器的网站，联通线路用户访问放在电信服务器上的网站，相对来说打开速度肯定是比较慢。</p><p>④ 从网站本身找原因。网站的问题主要包括网站程序设计、网页设计结构和网页内容三个部分。</p><p>网站程序设计：当访问网页中有拖慢网站打开速度的代码，会影响网页的打开速度，例如网页中的统计代码，我们最好将其放在网站的末尾。因此我们需要查看网页程序的设计结构是否合理；<br>网页设计结构：如果是 table 布局的网站，查看是否嵌套次数太多，或是一个大表格分成多个表格这样的网页布局，此时我们可以采用 div 布局并配合 css 进行优化。<br>网页内容：查看网页中是否有许多尺寸大的图片或者尺寸大的 flash 存在，我们可以通过降低图片质量，减小图片尺寸，少用大型 flash 加以解决。此外，有的网页可能过多地引用了其他网站的内容，若某些被引用的网站访问速度慢，或者一些页面已经不存在了，打开的速度也会变慢。一种直接的解决方法是去除不必要的加载项。</p><h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><p>FTP</p><ul><li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li><li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户/服务器方式，使用 UDP 数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定。</li></ul><p>SMTP<br>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</p><p>DHCP<br>DHCP ( Dynamic Host Configuration Protocol，动态主机设置协议 ) 是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p><ul><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ul><h2 id="网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟"><a href="#网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟" class="headerlink" title="网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟"></a>网页解析全过程【用户输入网址到显示对应页面的全过程】🌟🌟🌟🌟🌟</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/wmooux.png"                                     ><br>① DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。【具体细节参看问题 16，17】</p><p>② TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。【三次握手放在传输层详细讲解】</p><p>③ 发送 HTTP 请求：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的 TCP 连接中，按照 HTTP 协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</p><p>拓展：什么是负载均衡？</p><p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。</p><p>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p><p>④ 处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</p><p>⑤ 浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p><p>⑥ 断开连接：客户端和服务器通过四次挥手终止 TCP 连接。【其中的细节放在传输层详细讲解】</p><h1 id="第三部分：传输层"><a href="#第三部分：传输层" class="headerlink" title="第三部分：传输层"></a>第三部分：传输层</h1><h2 id="三次握手和四次挥手机制-🌟🌟🌟🌟🌟"><a href="#三次握手和四次挥手机制-🌟🌟🌟🌟🌟" class="headerlink" title="三次握手和四次挥手机制 🌟🌟🌟🌟🌟"></a>三次握手和四次挥手机制 🌟🌟🌟🌟🌟</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/tc9f5u.png"                                     ><br>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><p>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p><p>标志位为 SYN，表示请求建立连接；<br>序号为 Seq = x（x 一般为 1）；<br>随后客户端进入 SYN-SENT 阶段。<br>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p><p>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；<br>序号为 Seq = y；<br>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。<br>③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p><p>标志位为 ACK，表示确认收到服务器端同意连接的信号；<br>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；<br>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。<br>随后客户端进入 ESTABLISHED。<br>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/dxkghq.png"                                     ><br>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p><p>① 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：</p><p>标记位为 FIN，表示请求释放连接；<br>序号为 Seq = u；<br>随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。<br>② 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：</p><p>标记位为 ACK，表示接收到客户端释放连接的请求；<br>序号为 Seq = v；<br>确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；<br>随后服务器开始准备释放服务器端到客户端方向上的连接。<br>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段。</p><p>③ 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：</p><p>标记位为 FIN 和 ACK，表示已经准备好释放连接了；<br>序号为 Seq = w；<br>确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。<br>随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。</p><p>④ 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：</p><p>标记位为 ACK，表示接收到服务器准备好释放连接的信号；<br>序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；<br>确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。<br>随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p><h2 id="如果三次握手的时候每次握手信息对方没有收到会怎么样"><a href="#如果三次握手的时候每次握手信息对方没有收到会怎么样" class="headerlink" title="如果三次握手的时候每次握手信息对方没有收到会怎么样"></a>如果三次握手的时候每次握手信息对方没有收到会怎么样</h2><p>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。</p><p>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</p><p>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态。</p><h2 id="为什么要进行三次握手？两次握手可以吗？"><a href="#为什么要进行三次握手？两次握手可以吗？" class="headerlink" title="为什么要进行三次握手？两次握手可以吗？"></a>为什么要进行三次握手？两次握手可以吗？</h2><p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</p><p>我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p><h2 id="第-2-次握手传回了-ACK，为什么还要传回-SYN"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN</h2><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了告诉客户端，服务端收到的消息确实是客户端发送的消息。</p><h2 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h2><p>释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h2 id="CLOSE-WAIT-和-TIME-WAIT-的状态和意义"><a href="#CLOSE-WAIT-和-TIME-WAIT-的状态和意义" class="headerlink" title="CLOSE-WAIT 和 TIME-WAIT 的状态和意义"></a>CLOSE-WAIT 和 TIME-WAIT 的状态和意义</h2><p>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</p><p>TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</p><h2 id="TIME-WAIT-状态会导致什么问题，怎么解决"><a href="#TIME-WAIT-状态会导致什么问题，怎么解决" class="headerlink" title="TIME_WAIT 状态会导致什么问题，怎么解决"></a>TIME_WAIT 状态会导致什么问题，怎么解决</h2><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p><p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p><h2 id="TIME-WAIT-为什么是-2MSL"><a href="#TIME-WAIT-为什么是-2MSL" class="headerlink" title="TIME-WAIT 为什么是 2MSL"></a>TIME-WAIT 为什么是 2MSL</h2><p>当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。</p><p>若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。</p><p>若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。</p><p>所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。</p><h2 id="有很多-TIME-WAIT-状态如何解决"><a href="#有很多-TIME-WAIT-状态如何解决" class="headerlink" title="有很多 TIME-WAIT 状态如何解决"></a>有很多 TIME-WAIT 状态如何解决</h2><p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。</p><p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p><h2 id="有很多-CLOSE-WAIT-怎么解决"><a href="#有很多-CLOSE-WAIT-怎么解决" class="headerlink" title="有很多 CLOSE-WAIT 怎么解决"></a>有很多 CLOSE-WAIT 怎么解决</h2><p>首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码。</p><p>调整系统参数，包括句柄相关参数和 TCP/IP 的参数，一般一个 CLOSE_WAIT 会维持至少 2 个小时的时间，我们可以通过调整参数来缩短这个时间。</p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/srgsce.png"                                     ></p><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>所需资源</th><th>应用场景</th><th>首部字节</th></tr></thead><tbody><tr><td>TCP</td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件传输、邮件传输</td><td>20~60</td></tr><tr><td>UDP</td><td>否</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>即时通讯、域名转换</td><td>8 个字节</td></tr></tbody></table><h2 id="TCP-是如何保证可靠性的"><a href="#TCP-是如何保证可靠性的" class="headerlink" title="TCP 是如何保证可靠性的"></a>TCP 是如何保证可靠性的</h2><p><strong>数据分块：</strong> 应用数据被分割成 TCP 认为最适合发送的数据块。</p><p><strong>序列号和确认应答：</strong> TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</p><p><strong>校验和：</strong> TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</p><p><strong>流量控制：</strong> TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</p><p><strong>拥塞控制：</strong> 当网络某个节点发生拥塞时，减少数据的发送。</p><p><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p><strong>超时重传：</strong> 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p><h2 id="UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么-🌟🌟🌟"><a href="#UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么-🌟🌟🌟" class="headerlink" title="UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么 🌟🌟🌟"></a>UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么 🌟🌟🌟</h2><p>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故 UDP 的数据传输是不可靠的。</p><p>和 TCP 建立连接时采用三次握手不同，UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号（通过设置 connect 函数的第二个参数）。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。</p><p>当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p><h2 id="TCP-超时重传的原理-🌟🌟🌟"><a href="#TCP-超时重传的原理-🌟🌟🌟" class="headerlink" title="TCP 超时重传的原理 🌟🌟🌟"></a>TCP 超时重传的原理 🌟🌟🌟</h2><p>发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</p><h2 id="TCP-的停止等待协议是什么-🌟🌟🌟"><a href="#TCP-的停止等待协议是什么-🌟🌟🌟" class="headerlink" title="TCP 的停止等待协议是什么 🌟🌟🌟"></a>TCP 的停止等待协议是什么 🌟🌟🌟</h2><p>停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。我们通过四种情形来帮助理解停等协议是如何实现可靠传输的：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/g2ioim.png"                                     ><br>① 无差错传输</p><p>如上述左图所示，A 发送分组 Msg 1，发完就暂停发送，直到收到接收方确认收到 Msg 1 的报文后，继续发送 Msg 2，以此类推，该情形是通信中的一种理想状态。</p><p>② 出现差错</p><p>如上述右图所示，发送方发送的报文出现差错导致接收方不能正确接收数据，出现差错的情况主要分为两种：</p><p>发送方发送的 Msg 1 在中途丢失了，接收方完全没收到数据。<br>接收方收到 Msg 1 后检测出现了差错，直接丢弃 Msg 1。<br>上面两种情形，接收方都不会回任何消息给发送方，此时就会触发超时传输机制，即发送方在等待一段时间后仍然没有收到接收方的确认，就认为刚才发送的数据丢失了，因此重传前面发送过的数据。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/ku1p3d.png"                                     ><br>③ 确认丢失</p><p>当接收方回应的 Msg 1 确认报文在传输过程中丢失，发送方无法接收到确认报文。于是发送方等待一段时间后重传 Msg 1，接收方将收到重复的 Msg1 数据包，此时接收方会丢弃掉这个重复报文并向发送方再次发送 Msg1 的确认报文。</p><p>④ 确认迟到</p><p>当接收方回应的 Msg 1 确认报文由于网络各种原因导致发送方没有及时收到，此时发送方在超时重传机制的作用下再次发送了 Msg 数据包，接收方此时进行和确认丢失情形下相同的动作（丢弃重复的数据包并再次发送 Msg 1 确认报文）。发送方此时收到了接收方的确认数据包，于是继续进行数据发送。过了一段时间后，发送方收到了迟到的 Msg 1 确认包会直接丢弃。</p><p>上述四种情形即停止等待协议中所出现的所有可能情况。</p><h2 id="TCP-最大连接数限制"><a href="#TCP-最大连接数限制" class="headerlink" title="TCP 最大连接数限制"></a>TCP 最大连接数限制</h2><h3 id="Client-最大-TCP-连接数"><a href="#Client-最大-TCP-连接数" class="headerlink" title="Client 最大 TCP 连接数"></a>Client 最大 TCP 连接数</h3><p>client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0 不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。</p><h3 id="Server-最大-TCP-连接数"><a href="#Server-最大-TCP-连接数" class="headerlink" title="Server 最大 TCP 连接数"></a>Server 最大 TCP 连接数</h3><p>server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方。</p><p>然而上面给出的是只是理论上的单机最大连接数，在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的。</p><h2 id="TCP-流量控制与拥塞控制-🌟🌟🌟🌟"><a href="#TCP-流量控制与拥塞控制-🌟🌟🌟🌟" class="headerlink" title="TCP 流量控制与拥塞控制 🌟🌟🌟🌟"></a>TCP 流量控制与拥塞控制 🌟🌟🌟🌟</h2><ul><li><p><strong>流量控制</strong><br>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。</p></li><li><p><strong>拥塞控制</strong><br>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p></li><li><p><strong>拥塞控制和流量控制的区别</strong><br>拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而 TCP 连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。</p></li></ul><h2 id="如果接收方滑动窗口满了，发送方会怎么做-🌟🌟🌟🌟"><a href="#如果接收方滑动窗口满了，发送方会怎么做-🌟🌟🌟🌟" class="headerlink" title="如果接收方滑动窗口满了，发送方会怎么做 🌟🌟🌟🌟"></a>如果接收方滑动窗口满了，发送方会怎么做 🌟🌟🌟🌟</h2><p>基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，发送方便继续发送数据。</p><h2 id="TCP-拥塞控制采用的四种算法-🌟🌟🌟"><a href="#TCP-拥塞控制采用的四种算法-🌟🌟🌟" class="headerlink" title="TCP 拥塞控制采用的四种算法 🌟🌟🌟"></a>TCP 拥塞控制采用的四种算法 🌟🌟🌟</h2><ul><li><strong>慢开始</strong><br>当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd 为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。<br>但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。<br>① 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法；<br>② 当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；<br>③ 当 cwnd == ssthresh 时，两者均可。</li></ul><ul><li><strong>拥塞避免</strong><br>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。</li></ul><p>当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p><ul><li><p><strong>快重传</strong><br>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p></li><li><p><strong>快恢复</strong><br>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：<br>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；<br>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。</p></li></ul><h2 id="TCP-粘包问题-🌟🌟🌟"><a href="#TCP-粘包问题-🌟🌟🌟" class="headerlink" title="TCP 粘包问题 🌟🌟🌟"></a>TCP 粘包问题 🌟🌟🌟</h2><p>为什么会发生 TCP 粘包和拆包?</p><p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p><p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p><p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p><p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p><p>常见解决方法</p><p>① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p><p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p><p>③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p><p>什么时候需要处理粘包问题？</p><p>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。</p><h2 id="TCP-报文包含哪些信息"><a href="#TCP-报文包含哪些信息" class="headerlink" title="TCP 报文包含哪些信息"></a>TCP 报文包含哪些信息</h2><p>TCP 报文是 TCP 传输的的数据单元，也叫做报文段，其报文格式如下图所示：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/4w7vow.png"                                     ></p><ul><li>源端口和目的端口号：它用于多路复用/分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。</li><li>序号和确认号字段：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。</li><li>首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。</li><li>保留：为将来用于新的用途而保留。</li><li>控制位：URG 表示紧急指针标志，该位为 1 时表示紧急指针有效，为 0 则忽略；ACK 为确认序号标志，即相应报文段包括一个对已被成功接收报文段的确认；PSH 为 push 标志，当该位为 1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队； RST 为重置连接标志，当出现错误连接时，使用此标志来拒绝非法的请求；SYN 为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；FIN 为 finish 标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。</li><li>接收窗口：主要用于 TCP 流量控制。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。</li><li>校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该 TCP 报文。</li><li>紧急数据指针：紧急数据用于告知紧急数据所在的位置，在 URG 标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。</li><li>选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：<br>① TCP 连接初始化时，通信双方确认最大报文长度。</li></ul><p>② 在高速数据传输时，可使用该选项协商窗口扩大因子。</p><p>③ 作为时间戳时，提供一个 较为精准的 RTT，主要为了更好的实现 TCP 流量控制协议。</p><ul><li>数据：TCP 报文中的数据部分也是可选的，例如在 TCP 三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据。</li></ul><h2 id="SYN-FLOOD-是什么"><a href="#SYN-FLOOD-是什么" class="headerlink" title="SYN FLOOD 是什么"></a>SYN FLOOD 是什么</h2><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p><h1 id="为什么服务端易受到-SYN-攻击-🌟🌟🌟"><a href="#为什么服务端易受到-SYN-攻击-🌟🌟🌟" class="headerlink" title="为什么服务端易受到 SYN 攻击 🌟🌟🌟"></a>为什么服务端易受到 SYN 攻击 🌟🌟🌟</h1><p>在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p><p>服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p><p>解决方法：</p><ul><li>直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；</li><li>部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</li></ul><p>上述两种方法虽然在一定程度上能够提高服务器的防御能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽。</p><ul><li>SYN Cache：该方法首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。和服务器传输资源相比，维护表的开销要小得多。</li><li>SYN Cookies：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端发送 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</li></ul><p>然而该方案也存在一些缺点，由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p><ul><li>SYN Proxy：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）。</li></ul><h1 id="第四部分：网络层"><a href="#第四部分：网络层" class="headerlink" title="第四部分：网络层"></a>第四部分：网络层</h1><h2 id="IP-协议的定义和作用-🌟🌟🌟"><a href="#IP-协议的定义和作用-🌟🌟🌟" class="headerlink" title="IP 协议的定义和作用 🌟🌟🌟"></a>IP 协议的定义和作用 🌟🌟🌟</h2><p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成了 TCP/IP 协议族的核心。IP 协议主要有以下几个作用：</p><ul><li>寻址和路由：在 IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li>分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li></ul><h2 id="域名和-IP-的关系，一个-IP-可以对应多个域名吗"><a href="#域名和-IP-的关系，一个-IP-可以对应多个域名吗" class="headerlink" title="域名和 IP 的关系，一个 IP 可以对应多个域名吗"></a>域名和 IP 的关系，一个 IP 可以对应多个域名吗</h2><p>IP 在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号；域名在同一个网络中也是唯一的，就像一个人的名字，绰号。假如你有多个不同的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是唯一的。由此我们可以看出一个域名只能对应一个 IP 地址，是一对一的关系；而一个 IP 却可以对应多个域名，是一对多的关系。</p><h2 id="IPV4-地址不够如何解决"><a href="#IPV4-地址不够如何解决" class="headerlink" title="IPV4 地址不够如何解决"></a>IPV4 地址不够如何解决</h2><ul><li><p><strong>DHCP：</strong> 动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</p></li><li><p><strong>CIDR：</strong> 无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效的分配 IPv4 的地址空间，但无法从根本上解决地址耗尽问题。</p></li><li><p><strong>NAT：</strong> 网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</p></li><li><p><strong>IPv6 ：</strong> 作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个 IP 地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</p></li></ul><h2 id="路由器的分组转发流程-🌟🌟🌟"><a href="#路由器的分组转发流程-🌟🌟🌟" class="headerlink" title="路由器的分组转发流程 🌟🌟🌟"></a>路由器的分组转发流程 🌟🌟🌟</h2><p>① 从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络；</p><p>② 判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 ③；</p><p>③ 检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 ④；</p><p>④ 逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 ⑤；</p><p>⑤ 若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 ⑥；</p><p>⑥ 无法找到合适路由，向源主机报错。</p><h2 id="路由器和交换机的区别-🌟🌟🌟🌟"><a href="#路由器和交换机的区别-🌟🌟🌟🌟" class="headerlink" title="路由器和交换机的区别 🌟🌟🌟🌟"></a>路由器和交换机的区别 🌟🌟🌟🌟</h2><ul><li><strong>交换机：</strong> 交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li></ul><ul><li><strong>路由器：</strong> 路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li></ul><ul><li>交换机的端口不具有实际的 MAC 地址,因此交换机只是把接收到的消息转发出去而已，它的各端口并不以实际的发送方或接收方的身份参与到以太网包的传递过程；而路由器的端口具有 MAC 地址 IP 地址，所以它的端口是作为以太网包实际的接收方与发送方的身份存在的。</li><li>当交换机不知道将包转发到哪一个端口时，它会将包转发到除了源端口以外的所有端口；而当路由器不知道将包转发到哪一端口时，它就直接丢弃这个包。产生这种区别的原因是他们所连接的网络的规模不同——交换机工作在局域网，它所连接的网络规模比较小，向所有端口转发也不会造成多大问题；但路由器工作的环境是互联网，它的规模是远大于互联网的，若向所有端口转发则会产生大量的网络包，造成网络拥塞。</li></ul><h2 id="ICMP-协议概念-作用"><a href="#ICMP-协议概念-作用" class="headerlink" title="ICMP 协议概念/作用"></a>ICMP 协议概念/作用</h2><p>ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）。</p><h2 id="两台电脑连起来后-ping-不通，你觉得可能存在哪些问题？"><a href="#两台电脑连起来后-ping-不通，你觉得可能存在哪些问题？" class="headerlink" title="两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？"></a>两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？</h2><ul><li>首先看网络是否连接正常，检查网卡驱动是否正确安装。</li><li>局域网设置问题，检查 IP 地址是否设置正确。</li><li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 。</li><li>看是否被第三方软件拦截。</li><li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到。</li></ul><h2 id="ARP-地址解析协议的原理和地址解析过程-🌟🌟🌟🌟"><a href="#ARP-地址解析协议的原理和地址解析过程-🌟🌟🌟🌟" class="headerlink" title="ARP 地址解析协议的原理和地址解析过程 🌟🌟🌟🌟"></a>ARP 地址解析协议的原理和地址解析过程 🌟🌟🌟🌟</h2><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48 位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p><p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p><p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p><p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p><p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p><p>使用 ARP 的 4 种情况：</p><ol><li>发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ol><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p><p>NAT 的实现方式主要有三种：</p><ul><li>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</li><li>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</li><li>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</li></ul><h2 id="TTL-是什么？有什么作用"><a href="#TTL-是什么？有什么作用" class="headerlink" title="TTL 是什么？有什么作用"></a>TTL 是什么？有什么作用</h2><p>TTL 是指生存时间，简单来说，它表示了数据包在网络中的时间。每经过一个路由器后 TTL 就减一，这样 TTL 最终会减为 0 ，当 TTL 为 0 时，则将数据包丢弃。通过设置 TTL 可以避免这两个路由器之间形成环导致数据包在环路上死转的情况，由于有了 TTL ，当 TTL 为 0 时，数据包就会被抛弃。</p><h2 id="运输层协议和网络层协议的区别"><a href="#运输层协议和网络层协议的区别" class="headerlink" title="运输层协议和网络层协议的区别"></a>运输层协议和网络层协议的区别</h2><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p><h1 id="第五部分：数据链路层"><a href="#第五部分：数据链路层" class="headerlink" title="第五部分：数据链路层"></a>第五部分：数据链路层</h1><h2 id="MAC-地址和-IP-地址分别有什么作用"><a href="#MAC-地址和-IP-地址分别有什么作用" class="headerlink" title="MAC 地址和 IP 地址分别有什么作用"></a>MAC 地址和 IP 地址分别有什么作用</h2><ul><li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li></ul><h2 id="为什么有了-MAC-地址还需要-IP-地址-🌟🌟🌟🌟"><a href="#为什么有了-MAC-地址还需要-IP-地址-🌟🌟🌟🌟" class="headerlink" title="为什么有了 MAC 地址还需要 IP 地址 🌟🌟🌟🌟"></a>为什么有了 MAC 地址还需要 IP 地址 🌟🌟🌟🌟</h2><p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的。</p><p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p><h2 id="为什么有了-IP-地址还需要-MAC-地址-🌟🌟🌟🌟"><a href="#为什么有了-IP-地址还需要-MAC-地址-🌟🌟🌟🌟" class="headerlink" title="为什么有了 IP 地址还需要 MAC 地址 🌟🌟🌟🌟"></a>为什么有了 IP 地址还需要 MAC 地址 🌟🌟🌟🌟</h2><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p><h2 id="私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗-🌟🌟🌟"><a href="#私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗-🌟🌟🌟" class="headerlink" title="私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗 🌟🌟🌟"></a>私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗 🌟🌟🌟</h2><p>当采用静态或者动态转换时，由于一个私网 IP 地址对应一个公网地址，因此经过转换之后的公网 IP 地址是不同的；而采用端口复用方式的话，在一个子网中的所有地址都采用一个公网地址，但是使用的端口是不同的。</p><h1 id="第六部分：物理层"><a href="#第六部分：物理层" class="headerlink" title="第六部分：物理层"></a>第六部分：物理层</h1><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ul><li>单工通信：也叫单向通信，发送方和接收方是固定的，消息只能单向传输。例如采集气象数据、家庭电费，网费等数据收集系统，或者打印机等应用主要采用单工通信。</li><li>半双工通信：也叫双向交替通信，通信双方都可以发送消息，但同一时刻同一信道只允许单方向发送数据。例如传统的对讲机使用的就是半双工通信。</li><li>全双工通信：也叫双向同时通信，全双工通信允许通信双方同时在两个方向是传输，其要求通信双方都具有独立的发送和接收数据的能力。例如平时我们打电话，自己说话的同时也能听到对面的声音。</li></ul><h1 id="第七部分：计算机网络中的安全"><a href="#第七部分：计算机网络中的安全" class="headerlink" title="第七部分：计算机网络中的安全"></a>第七部分：计算机网络中的安全</h1><h2 id="ARP-攻击"><a href="#ARP-攻击" class="headerlink" title="ARP 攻击"></a>ARP 攻击</h2><p>在 ARP 的解析过程中，局域网上的任何一台主机如果接收到一个 ARP 应答报文，并不会去检测这个报文的真实性，而是直接记入自己的 ARP 缓存表中。并且这个 ARP 表是可以被更改的，当表中的某一列长时间不适使用，就会被删除。ARP 攻击就是利用了这一点，攻击者疯狂发送 ARP 报文，其源 MAC 地址为攻击者的 MAC 地址，而源 IP 地址为被攻击者的 IP 地址。通过不断发送这些伪造的 ARP 报文，让网络内部的所有主机和网关的 ARP 表中被攻击者的 IP 地址所对应的 MAC 地址为攻击者的 MAC 地址。这样所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。通常可以把 ARP 欺骗分为以下几种：</p><ul><li>洪泛攻击</li></ul><p>攻击者恶意向局域网中的网关、路由器和交换机等发送大量 ARP 报文，设备的 CPU 忙于处理 ARP 协议，而导致难以响应正常的服务请求。其表现通常为：网络中断或者网速很慢。</p><ul><li>欺骗主机</li></ul><p>这种攻击方式也叫仿冒网关攻击。攻击者通过 ARP 欺骗使得网络内部被攻击主机发送给网关的信息实际上都发送给了攻击者，主机更新的 ARP 表中对应的 MAC 地址为攻击者的 MAC。当用户主机向网关发送重要信息使，该攻击方式使得用户的数据存在被窃取的风险。</p><ul><li>欺骗网关</li></ul><p>该攻击方式和欺骗主机的攻击方式类似，不过这种攻击的欺骗对象是局域网的网关，当局域网中的主机向网关发送数据时，网关会把数据发送给攻击者，这样攻击者就会源源不断地获得局域网中用户的信息。该攻击方式同样会造成用户数据外泄。</p><ul><li>中间人攻击</li></ul><p>攻击者同时欺骗网关和主机，局域网的网关和主机发送的数据最后都会到达攻击者这边。这样，网关和用户的数据就会泄露。</p><ul><li>IP 地址冲突</li></ul><p>攻击者对局域网中的主机进行扫描，然后根据物理主机的 MAC 地址进行攻击，导致局域网内的主机产生 IP 冲突，使得用户的网络无法正常使用。</p><h2 id="对称加密和非对称的区别，非对称加密有哪些"><a href="#对称加密和非对称的区别，非对称加密有哪些" class="headerlink" title="对称加密和非对称的区别，非对称加密有哪些"></a>对称加密和非对称的区别，非对称加密有哪些</h2><ul><li>加密和解密的过程不同：对称加密和解密过程使用同一个密钥；非对称加密中加密和解密采用公钥和私钥两个密钥，一般使用公钥进行加密，使用私钥进行解密。</li><li>加密和解密的速度不同：对称加密和解密速度较快，当数据量比较大时适合使用；非对称加密和解密时间较长，速度相对较慢，适合少量数据传输的场景。</li><li>传输的安全性不同：采用对称加密方式进行通信时，收发双方在数据传送前需要协定好密钥，而这个密钥还有可能被第三方窃听到的，一旦密钥泄漏，之后的通信就完全暴漏给攻击者了；非对称加密采用公钥加密和私钥解密的方式，其中私钥是基于不同的算法生成的随机数，公钥可以通过私钥通过一定的算法推导得出，并且私钥到公钥的推导过程是不可逆的，也就是说公钥无法反推导出私钥，即使攻击者窃听到传输的公钥，也无法正确解出数据，所以安全性较高。</li></ul><p>常见的非对称加密算法主要有：RSA、Elgamal、背包算法、Rabin、D-H 算法等等。<br>对称加密算法：AES</p><h2 id="RSA-和-AES-算法有什么区别"><a href="#RSA-和-AES-算法有什么区别" class="headerlink" title="RSA 和 AES 算法有什么区别"></a>RSA 和 AES 算法有什么区别</h2><ul><li><p><strong>RSA</strong><br>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，除此之外，由于需要大数的乘幂求模等运算，其运算速度较慢，不适合大量数据文件加密。</p></li><li><p><strong>AES</strong><br>采用对称加密的方式，其密钥长度最长只有 256 个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p></li></ul><p>基于上述两种算法的特点，一般使用 RSA 传输密钥给对方，之后使用 AES 进行加密通信。</p><h2 id="DDoS-有哪些，如何防范"><a href="#DDoS-有哪些，如何防范" class="headerlink" title="DDoS 有哪些，如何防范"></a>DDoS 有哪些，如何防范</h2><p>DDoS 为分布式拒绝服务攻击，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了不同位置上的多台机器并利用这些机器对受害者同时实施攻击。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机一起发起网络攻击。</p><p>DDoS 攻击主要有两种形式：流量攻击和资源耗尽攻击。前者主要针对网络带宽，攻击者和已受害主机同时发起大量攻击导致网络带宽被阻塞，从而淹没合法的网络数据包；后者主要针对服务器进行攻击，大量的攻击包会使得服务器资源耗尽或者 CPU 被内核应用程序占满从而无法提供网络服务。</p><p>常见的 DDos 攻击主要有：TCP 洪水攻击（SYN Flood）、放射性攻击（DrDos）、CC 攻击（HTTP Flood）等。</p><p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足网络带宽的前提下，我们应尽量提升路由器、网卡、交换机等硬件设施的配置。</p><p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。此外，负载均衡，CDN 等技术都能够有效对抗 DDoS 攻击</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一部分：协议层次以及它们的服务类型&quot;&gt;&lt;a href=&quot;#第一部分：协议层次以及它们的服务类型&quot; class=&quot;headerlink&quot; title=&quot;第一部分：协议层次以及它们的服务类型&quot;&gt;&lt;/a&gt;第一部分：协议层次以及它们的服务类型&lt;/h1&gt;&lt;h2 id=&quot;O</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swift 实用技巧</title>
    <link href="http://example.com/2021/06/05/100-Swift%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2021/06/05/100-Swift%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-06-05T08:13:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-protocol-extension-初始化后直接配置相应属性"><a href="#1-protocol-extension-初始化后直接配置相应属性" class="headerlink" title="1. protocol + extension 初始化后直接配置相应属性"></a>1. protocol + extension 初始化后直接配置相应属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol XXXBuilder &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension XXXBuilder &#123;</span><br><span class="line">    public func with(configure: (inout Self) -&gt; Void) -&gt; Self &#123;</span><br><span class="line">        var this &#x3D; self</span><br><span class="line">        configure(&amp;this)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension NSObject: XXXBuilder &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">let tipLab &#x3D; UILabel().with &#123; lab in</span><br><span class="line">            lab.textColor &#x3D; .red</span><br><span class="line">            lab.backgroundColor &#x3D; .black</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="2-Double-转-String-限制小数位数"><a href="#2-Double-转-String-限制小数位数" class="headerlink" title="2. Double 转 String,限制小数位数"></a>2. Double 转 String,限制小数位数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    func format(_ count: Int) -&gt; String &#123;</span><br><span class="line">        String(format: &quot;%.\(count)f&quot;, self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-protocol-extension-初始化后直接配置相应属性&quot;&gt;&lt;a href=&quot;#1-protocol-extension-初始化后直接配置相应属性&quot; class=&quot;headerlink&quot; title=&quot;1. protocol + extension 初始</summary>
      
    
    
    
    <category term="Swift" scheme="http://example.com/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Swift 中为 String 添加扩展</title>
    <link href="http://example.com/2021/06/05/100-Swift%E4%B8%ADString%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2021/06/05/100-Swift%E4%B8%ADString%E6%89%A9%E5%B1%95/</id>
    <published>2021-06-05T07:55:00.000Z</published>
    <updated>2021-06-16T15:32:05.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-extension-代码"><a href="#String-extension-代码" class="headerlink" title="String extension 代码"></a>String extension 代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">    func index(from: Int) -&gt; Index &#123;</span><br><span class="line">        &#x2F;&#x2F; 增加越界防护， 负数就不考虑了吧</span><br><span class="line">        if from &lt; count &#123;</span><br><span class="line">            return index(startIndex, offsetBy: from)</span><br><span class="line">        &#125;</span><br><span class="line">        return endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(from: Int) -&gt; String &#123;</span><br><span class="line">        let fromIndex &#x3D; index(from: from)</span><br><span class="line">        return String(self[fromIndex...])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(to: Int) -&gt; String &#123;</span><br><span class="line">        String(prefix(to))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(with r: Range&lt;Int&gt;) -&gt; String &#123;</span><br><span class="line">        let startIndex &#x3D; index(from: r.lowerBound)</span><br><span class="line">        let endIndex &#x3D; index(from: r.upperBound)</span><br><span class="line">        return String(self[startIndex ..&lt; endIndex])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;01234567&quot;</span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(from: 0) &#x2F;&#x2F; &quot;01234567&quot;</span><br><span class="line">_ &#x3D; str.substring(from: 4) &#x2F;&#x2F; &quot;4567&quot;</span><br><span class="line">_ &#x3D; str.substring(from: 100) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(to: 0) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line">_ &#x3D; str.substring(to: 1) &#x2F;&#x2F; &quot;0&quot;</span><br><span class="line">_ &#x3D; str.substring(to: 100) &#x2F;&#x2F; &quot;01234567&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(with: 0 ..&lt; 1) &#x2F;&#x2F; &quot;0&quot;</span><br><span class="line">_ &#x3D; str.substring(with: 0 ..&lt; 100) &#x2F;&#x2F; &quot;01234567&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String-extension-代码&quot;&gt;&lt;a href=&quot;#String-extension-代码&quot; class=&quot;headerlink&quot; title=&quot;String extension 代码&quot;&gt;&lt;/a&gt;String extension 代码&lt;/h1&gt;&lt;figu</summary>
      
    
    
    
    <category term="Swift" scheme="http://example.com/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>运输层协议和网络层协议的区别</title>
    <link href="http://example.com/2021/06/02/1000-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/02/1000-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-02T14:42:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运输层协议和网络层协议的区别"><a href="#运输层协议和网络层协议的区别" class="headerlink" title="运输层协议和网络层协议的区别"></a>运输层协议和网络层协议的区别</h1><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运输层协议和网络层协议的区别&quot;&gt;&lt;a href=&quot;#运输层协议和网络层协议的区别&quot; class=&quot;headerlink&quot; title=&quot;运输层协议和网络层协议的区别&quot;&gt;&lt;/a&gt;运输层协议和网络层协议的区别&lt;/h1&gt;&lt;p&gt;网络层协议负责提供主机间的逻辑通信；运输层协</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>网络地址转换 NAT</title>
    <link href="http://example.com/2021/06/02/1000-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20NAT/"/>
    <id>http://example.com/2021/06/02/1000-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20NAT/</id>
    <published>2021-06-02T14:38:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h1><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p><p>NAT 的实现方式主要有三种：</p><ul><li><p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p></li><li><p>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p></li><li><p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络地址转换-NAT&quot;&gt;&lt;a href=&quot;#网络地址转换-NAT&quot; class=&quot;headerlink&quot; title=&quot;网络地址转换 NAT&quot;&gt;&lt;/a&gt;网络地址转换 NAT&lt;/h1&gt;&lt;p&gt;NAT（Network Address Translation），即网络地址</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>ARP 地址解析协议的原理和地址解析过程</title>
    <link href="http://example.com/2021/06/02/1000-ARP%20%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/06/02/1000-ARP%20%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</id>
    <published>2021-06-02T14:37:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARP-地址解析协议的原理和地址解析过程"><a href="#ARP-地址解析协议的原理和地址解析过程" class="headerlink" title="ARP 地址解析协议的原理和地址解析过程"></a>ARP 地址解析协议的原理和地址解析过程</h1><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48 位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p><p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p><p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p><p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p><p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p><p>使用 ARP 的 4 种情况：</p><ol><li>发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARP-地址解析协议的原理和地址解析过程&quot;&gt;&lt;a href=&quot;#ARP-地址解析协议的原理和地址解析过程&quot; class=&quot;headerlink&quot; title=&quot;ARP 地址解析协议的原理和地址解析过程&quot;&gt;&lt;/a&gt;ARP 地址解析协议的原理和地址解析过程&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器和交换机的区别</title>
    <link href="http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-02T14:30:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h1><ul><li><strong>交换机：</strong> 交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li></ul><ul><li><strong>路由器：</strong> 路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li></ul><ul><li>交换机的端口不具有实际的 MAC 地址,因此交换机只是把接收到的消息转发出去而已，它的各端口并不以实际的发送方或接收方的身份参与到以太网包的传递过程；而路由器的端口具有 MAC 地址 IP 地址，所以它的端口是作为以太网包实际的接收方与发送方的身份存在的。</li><li>当交换机不知道将包转发到哪一个端口时，它会将包转发到除了源端口以外的所有端口；而当路由器不知道将包转发到哪一端口时，它就直接丢弃这个包。产生这种区别的原因是他们所连接的网络的规模不同——交换机工作在局域网，它所连接的网络规模比较小，向所有端口转发也不会造成多大问题；但路由器工作的环境是互联网，它的规模是远大于互联网的，若向所有端口转发则会产生大量的网络包，造成网络拥塞。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器和交换机的区别&quot;&gt;&lt;a href=&quot;#路由器和交换机的区别&quot; class=&quot;headerlink&quot; title=&quot;路由器和交换机的区别&quot;&gt;&lt;/a&gt;路由器和交换机的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;交换机：&lt;/strong&gt; 交换机用于局域网，利</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器的分组转发流程</title>
    <link href="http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-02T14:25:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器的分组转发流程"><a href="#路由器的分组转发流程" class="headerlink" title="路由器的分组转发流程"></a>路由器的分组转发流程</h1><ol><li><p>从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络；</p></li><li><p>判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 2.；</p></li><li><p>检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4.；</p></li><li><p>逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5.；</p></li><li><p>若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6.；</p></li><li><p>无法找到合适路由，向源主机报错。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器的分组转发流程&quot;&gt;&lt;a href=&quot;#路由器的分组转发流程&quot; class=&quot;headerlink&quot; title=&quot;路由器的分组转发流程&quot;&gt;&lt;/a&gt;路由器的分组转发流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从 IP 数据包中提取出目的主机的 IP 地址，找到其所在</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>IPV4 地址不够如何解决</title>
    <link href="http://example.com/2021/06/02/1000-IPV4%20%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/2021/06/02/1000-IPV4%20%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</id>
    <published>2021-06-02T14:23:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPV4-地址不够如何解决"><a href="#IPV4-地址不够如何解决" class="headerlink" title="IPV4 地址不够如何解决"></a>IPV4 地址不够如何解决</h1><ul><li><p><strong>DHCP：</strong> 动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</p></li><li><p><strong>CIDR：</strong> 无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效的分配 IPv4 的地址空间，但无法从根本上解决地址耗尽问题。</p></li><li><p><strong>NAT：</strong> 网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</p></li><li><p><strong>IPv6 ：</strong> 作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个 IP 地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IPV4-地址不够如何解决&quot;&gt;&lt;a href=&quot;#IPV4-地址不够如何解决&quot; class=&quot;headerlink&quot; title=&quot;IPV4 地址不够如何解决&quot;&gt;&lt;/a&gt;IPV4 地址不够如何解决&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DHCP：&lt;/st</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="IPV4" scheme="http://example.com/tags/IPV4/"/>
    
  </entry>
  
  <entry>
    <title>IP 协议的定义和作用</title>
    <link href="http://example.com/2021/06/02/1000-IP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2021/06/02/1000-IP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8/</id>
    <published>2021-06-02T14:19:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成了 TCP/IP 协议族的核心。</p><p>IP 协议主要有以下几个作用：</p><ul><li>寻址和路由：在 IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li>分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="IP" scheme="http://example.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>在 M1 芯片的 Mac 上使用 CocoaPods</title>
    <link href="http://example.com/2021/05/17/500-%E5%9C%A8%20M1%E8%8A%AF%E7%89%87%E7%9A%84%20Mac%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20CocoaPods/"/>
    <id>http://example.com/2021/05/17/500-%E5%9C%A8%20M1%E8%8A%AF%E7%89%87%E7%9A%84%20Mac%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20CocoaPods/</id>
    <published>2021-05-17T12:36:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近换了 M1 芯片的 MacBook Pro，在配置环境完成后 <code>pod install</code> 操作发现出错了。</p><h1 id="在-M1-上使用-CocoaPods-的方法。"><a href="#在-M1-上使用-CocoaPods-的方法。" class="headerlink" title="在 M1 上使用 CocoaPods 的方法。"></a>在 M1 上使用 CocoaPods 的方法。</h1><h2 id="1-首先执行一次"><a href="#1-首先执行一次" class="headerlink" title="1. 首先执行一次"></a>1. 首先执行一次</h2><p><code>sudo arch -x86_64 gem install ffi</code></p><h2 id="2-然后再替换之前-pod-install"><a href="#2-然后再替换之前-pod-install" class="headerlink" title="2. 然后再替换之前 pod install"></a>2. 然后再替换之前 pod install</h2><p><code>arch -x86_64 pod install</code></p><h1 id="如何查找解决方案"><a href="#如何查找解决方案" class="headerlink" title="如何查找解决方案"></a>如何查找解决方案</h1><p>第一时间想到去 <a class="link"   href="https://github.com/CocoaPods/CocoaPods/issues" >CocoaPods issues<i class="fas fa-external-link-alt"></i></a> 搜索相关问题。<br>然后果然在 <a class="link"   href="https://github.com/CocoaPods/CocoaPods/issues/10220" >Got error while trying pod install<i class="fas fa-external-link-alt"></i></a> 中找到了解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;最近换了 M1 芯片的 MacBook Pro，在配置环境完成后 &lt;code&gt;pod install&lt;/code&gt; 操作发现出错了。&lt;/p&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="CocoaPods" scheme="http://example.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代理检测</title>
    <link href="http://example.com/2021/04/14/500-iOS%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2021/04/14/500-iOS%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%90%86/</id>
    <published>2021-04-14T08:05:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *proxySettings &#x3D; CFBridgingRelease(CFNetworkCopySystemProxySettings());</span><br><span class="line">    NSArray *proxies &#x3D; CFBridgingRelease(CFNetworkCopyProxiesForURL((__bridge CFURLRef)[NSURL URLWithString:@&quot;https:&#x2F;&#x2F;www.baidu.com&quot;], (__bridge CFDictionaryRef)proxySettings));</span><br><span class="line">    if (proxies.count &gt; 0) &#123;</span><br><span class="line">        NSDictionary *settings &#x3D; proxies[0];</span><br><span class="line">        NSString *type &#x3D; [settings objectForKey:(NSString *)kCFProxyTypeKey];</span><br><span class="line">        if (![type isEqualToString:(NSString *)kCFProxyTypeNone]) &#123;</span><br><span class="line">            NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 开启代理&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 未开启代理&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Runtime 相关知识</title>
    <link href="http://example.com/2021/03/08/6666-001-runtime/"/>
    <id>http://example.com/2021/03/08/6666-001-runtime/</id>
    <published>2021-03-08T14:35:00.000Z</published>
    <updated>2021-06-16T15:32:05.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"><a href="#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）" class="headerlink" title="1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"></a>1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</h1><ul><li><strong>对象(实例)</strong><br>OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object *id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。</li><li><strong>类(Class)</strong><ol><li>在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class *Class.</li><li>OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;</li><li>当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。</li></ol></li><li><strong>OC 对象、类、元类之间的关系</strong><br>对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/kj1q75.png"                      alt="OC 对象、类、元类之间的关系"                ></li></ul><h1 id="2-为什么要设计-metaclass"><a href="#2-为什么要设计-metaclass" class="headerlink" title="2.为什么要设计 metaclass?"></a>2.为什么要设计 metaclass?</h1><ul><li>类对象、元类对象能够复用消息发送流程机制；</li><li>单一职责原则<br>metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。</li></ul><h1 id="3-class-copyIvarList-amp-class-copyPropertyList-区别"><a href="#3-class-copyIvarList-amp-class-copyPropertyList-区别" class="headerlink" title="3.class_copyIvarList &amp; class_copyPropertyList 区别"></a>3.class_copyIvarList &amp; class_copyPropertyList 区别</h1><ul><li><strong>class_copyIvarList</strong><br>会返回所有的成员变量，包括属性生成的成员变量。<br>获取类对象中的所有实例变量信息，从 class_ro_t 中获取。</li><li><strong>class_copyPropertyList</strong><br>获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_ddd;</span><br><span class="line">    NSString *_ccc;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *abc1;</span><br><span class="line">@property (nonatomic, copy) NSString *abc2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyIvarList</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar * ivars &#x3D; class_copyIvarList(self.class, &amp;count);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">      const char *name &#x3D; ivar_getName(ivars[i]);</span><br><span class="line">      NSLog(@&quot;name &#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:name]);</span><br><span class="line">  &#125;</span><br><span class="line">free(ivars);</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ddd</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ccc</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc1</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyPropertyList</span><br><span class="line">unsigned int outCount &#x3D; 0;</span><br><span class="line">objc_property_t *prs &#x3D; class_copyPropertyList(self.class, &amp;outCount);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; outCount; i++) &#123;</span><br><span class="line">    const char *pname &#x3D;  property_getName(prs[i]);</span><br><span class="line">    NSLog(@&quot;pname &#x3D;&#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:pname]);</span><br><span class="line">&#125;</span><br><span class="line">free(prs);</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc1</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc2</span><br></pre></td></tr></table></figure><h1 id="4-class-rw-t-和-class-ro-t-的区别"><a href="#4-class-rw-t-和-class-ro-t-的区别" class="headerlink" title="4.class_rw_t 和 class_ro_t 的区别"></a>4.class_rw_t 和 class_ro_t 的区别</h1><ul><li><p>class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only</p></li><li><p>class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write</p></li></ul><h1 id="5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序"><a href="#5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序" class="headerlink" title="5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序"></a>5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序</h1><p>+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看<br>分类添加到了 rw = cls-&gt;data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。同名方法调用后编译的。</p><h1 id="6-initialize-amp-amp-Load"><a href="#6-initialize-amp-amp-Load" class="headerlink" title="6.initialize &amp;&amp; Load"></a>6.initialize &amp;&amp; Load</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot; load &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D;&#x3D; [self class]) &#123;</span><br><span class="line">        NSLog(@&quot; initialize &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，<strong>如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。</strong>。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。</p><p>不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。<br>调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。</p><h1 id="7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何"><a href="#7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何" class="headerlink" title="7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何"></a>7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何</h1><ul><li>category 可以给类添加方法和属性(需要借助 runtime<br><code>objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</code><br>及<code>objc_getAssociatedObject(self, &amp;redXXKey);</code>)</li><li>extension 可以给类添加成员变量和方法，但是是私有的在 .m 内(只有在.m 里才是私有的)。</li><li>不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m</li></ul><h1 id="8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么"><a href="#8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么" class="headerlink" title="8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么"></a>8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</h1><p>OC 中的方法调用，编译后的代码最终都会转成 <code>objc_msgSend(id , SEL, ...)</code> 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用<code>_objc_msgForward(id, SEL, ...)</code>进行消息转发。</p><h1 id="9-IMP、SEL、Method-的区别和使用场景"><a href="#9-IMP、SEL、Method-的区别和使用场景" class="headerlink" title="9.IMP、SEL、Method 的区别和使用场景"></a>9.IMP、SEL、Method 的区别和使用场景</h1><ul><li><p>IMP:IMP 定义为 <code>id (*IMP) (id, SEL, …)</code>。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。</p></li><li><p>SEL:是“selector”的一个类型，表示一个方法的名字</p></li><li><p>Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关</p></li></ul><h1 id="10-load、initialize-方法的区别什么？在继承关系中他们有什么区别"><a href="#10-load、initialize-方法的区别什么？在继承关系中他们有什么区别" class="headerlink" title="10.load、initialize 方法的区别什么？在继承关系中他们有什么区别"></a>10.load、initialize 方法的区别什么？在继承关系中他们有什么区别</h1><p>load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。</p><p>继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。</p><h1 id="11-说说消息转发机制的优劣"><a href="#11-说说消息转发机制的优劣" class="headerlink" title="11.说说消息转发机制的优劣"></a>11.说说消息转发机制的优劣</h1><ul><li>优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。</li><li>劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。</li></ul><h2 id="消息转发三部曲"><a href="#消息转发三部曲" class="headerlink" title="消息转发三部曲"></a>消息转发三部曲</h2><p><strong>1. 第一步动态添加一个实现方法。</strong> 如果是实例对象会调用这个实例所属的类方法<br><code>resolveInstanceMethod</code>，如果是类方法会调用<code>+ (BOOL)resolveClassMethod:(SEL)sel;</code></p><p>我们可以动态的给该对象添加该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F;v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        class_addMethod(self, sel, (IMP)aaa, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C 方法</span><br><span class="line">void aaa (id self,SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;添加了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2. 消息转发，可以将消息转发给实现了该方法的对象。</strong> 系统会调用下面的这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个实现了该方法的对象</span><br><span class="line">        return [SubViewController new];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 完整的消息转发</strong><br>先调用 <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code><br>获取一个方法签名，如果没有返回一个有效的签名则直接调用<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector;</code>抛出异常。<br>如果获取到则将签名包装成<code>NSInvocation</code><br>传给<code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code><br>进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个方法签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果返回了有效的签名将调用这个方法进行转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取方法</span><br><span class="line">    SEL selector &#x3D; [anInvocation selector];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象</span><br><span class="line">    &#x2F;&#x2F; 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃</span><br><span class="line"></span><br><span class="line">    SubViewController *subVC &#x3D; [SubViewController new];</span><br><span class="line">    if ([subVC respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:subVC];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ABC *abc &#x3D; [ABC new];</span><br><span class="line">    if ([abc respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:abc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-weak-的实现原理？SideTable-的结构是什么样的"><a href="#12-weak-的实现原理？SideTable-的结构是什么样的" class="headerlink" title="12.weak 的实现原理？SideTable 的结构是什么样的"></a>12.weak 的实现原理？SideTable 的结构是什么样的</h1><p>runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，<br>value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.<br>runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数<br>weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.</p><p>SideTable 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">     spinlock_t slock;&#x2F;&#x2F;操作SideTable时用到的自旋锁</span><br><span class="line">     RefcountMap refcnts;&#x2F;&#x2F;引用计数器的 map</span><br><span class="line">     weak_table_t weak_table;&#x2F;&#x2F;存放weak指针的哈希表</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="13-关联对象的应用？系统如何实现关联对象的"><a href="#13-关联对象的应用？系统如何实现关联对象的" class="headerlink" title="13.关联对象的应用？系统如何实现关联对象的"></a>13.关联对象的应用？系统如何实现关联对象的</h1><ul><li>应用：给 category 添加属性。</li><li>如何实现关联的？<br>首先系统中有一个全局 AssociationsManager,里面有个 AssociationsHashMap 哈希表，哈希表中的 key 是对象的内存地址，value 是 ObjectAssociationMap,也是一个哈希表。<br>ObjectAssociationMap 中的 key 是我们设置关联对象时所设置的唯一 key，value 是 ObjcAssociation,里面存放着关联对象设置的值和内存管理的策略。<br>以<code>void objc_setAssociatedObject(id object, const void * key,id value, objc_AssociationPolicy policy)</code>为例，<br>首先会通过 AssociationsManager 获取 AssociationsHashMap，然后以 object 的内存地址为 key，从 AssociationsHashMap 中取出 ObjectAssociationMap，若没有，则新创建一个 ObjectAssociationMap，<br>然后通过 key 获取旧值，以及通过 key 和 policy 生成新值 ObjcAssociation(policy, new_value)，把新值存放到 ObjectAssociationMap 中，<br>若新值不为 nil，并且内存管理策略为 retain，则会对新值进行一次 retain，若新值为 nil，则会删除旧值，若旧值不为空并且内存管理的策略是 retain，则对旧值进行一次 release.</li><li>其被释放的时候需要手动将所有的关联对象的指针置空么？<br>对这个问题我的理解是：当对象被释放时，需要手动移除该对象所设置的关联对象吗？ 不需要，因为在对象的 dealloc 中，若发现对象有关联对象时，会调用<code>_object_remove_assocations</code> 方法来移除所有的关联对象，并根据内存策略，来判断是否需要对关联对象的值进行 release</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface UIView (XX)</span><br><span class="line">@property (nonatomic, copy) NSString *redXX;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIView (XX)</span><br><span class="line">static char redXXKey;</span><br><span class="line">- (void)setRedXX:(NSString *)redXX &#123;</span><br><span class="line">    &#x2F;&#x2F; 被关联的对象、关联的key唯一、关联的对象、内存管理策略</span><br><span class="line">    objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)redXX &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;redXXKey);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性"><a href="#14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性" class="headerlink" title="14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性"></a>14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性</h1><p>在关联对象时又一个参数<code>objc_AssociationPolicy policy</code>设置内存管理策略<br>OBJC_ASSOCIATION_ASSIGN 类型的关联对象和 weak 有一定差别，而更加接近于 unsafe_unretained，<br>即当目标对象遭到摧毁时，属性值不会自动清空。<br>然后内部封装一个 weak 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil 操作。</p><h1 id="15-Autoreleasepool-的原理？所使用的的数据结构是什么"><a href="#15-Autoreleasepool-的原理？所使用的的数据结构是什么" class="headerlink" title="15.Autoreleasepool 的原理？所使用的的数据结构是什么"></a>15.Autoreleasepool 的原理？所使用的的数据结构是什么</h1><ul><li>Autoreleasepool 是由多个 AutoreleasePoolPage 以双向链表的形式连接起来的。</li><li>释放时机: 当前 RunLoop 迭代结束时候释放。</li><li>Autoreleasepool 的基本原理：在每个自动释放池创建的时候，会在当前的 AutoreleasePoolPage 中设置一个标记位，在此期间，当有对象调用 autorelsease 时，会把对象添加到 AutoreleasePoolPage 中，若当前页添加满了，会初始化一个新页，然后用双向量表链接起来，并把新初始化的这一页设置为 hotPage,当自动释放池 pop 时，从最下面依次往上 pop，调用每个对象的 release 方法，直到遇到标志位。</li><li>AutoreleasePoolPage 结构如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">     magic_t const magic;</span><br><span class="line">     id *next;&#x2F;&#x2F;下一个存放autorelease对象的地址</span><br><span class="line">     pthread_t const thread; &#x2F;&#x2F;AutoreleasePoolPage 所在的线程</span><br><span class="line">     AutoreleasePoolPage * const parent;&#x2F;&#x2F;父节点</span><br><span class="line">     AutoreleasePoolPage *child;&#x2F;&#x2F;子节点</span><br><span class="line">     uint32_t const depth;&#x2F;&#x2F;深度,也可以理解为当前page在链表中的位置</span><br><span class="line">     uint32_t hiwat;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化"><a href="#16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化" class="headerlink" title="16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化"></a>16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化</h1><ul><li>Automatic Reference Counting，自动引用计数，即 ARC,ARC 会自动帮你插入 retain 和 release 语句,<br>ARC 编译器有两部分，分别是前端编译器和优化器</li><li>前端编译器:前端编译器会为“拥有的”每一个对象插入相应的 release 语句。如果对象的所有权修饰符是<code>__strong</code>，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入 release 语句以销毁它。而类拥有的对象（实例变量/属性）会在 dealloc 方法内被释放。事实上，你并不需要写 dealloc 方法或调用父类的 dealloc 方法，ARC 会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的 release 语句的性能还要好，因为编辑器可以作出一些假设。在 ARC 中，没有类可以覆盖 release 方法，也没有调用它的必要。ARC 会通过直接使用 objc_release 来优化调用过程。而对于 retain 也是同样的方法。ARC 会调用 objc_retain 来取代保留消息</li><li>ARC 优化器: 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对 retain 和 release 的重复调用。ARC 优化器负责移除多余的 retain 和 release 语句，确保生成的代码运行速度高于手动引用计数的代码</li></ul><h1 id="17-ARC-下哪些情况会造成内存泄漏"><a href="#17-ARC-下哪些情况会造成内存泄漏" class="headerlink" title="17.ARC 下哪些情况会造成内存泄漏"></a>17.ARC 下哪些情况会造成内存泄漏</h1><ul><li>循环引用</li><li>注册通知，不移除</li></ul><h1 id="18-Method-Swizzle-注意事项"><a href="#18-Method-Swizzle-注意事项" class="headerlink" title="18. Method Swizzle 注意事项"></a>18. Method Swizzle 注意事项</h1><p>如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议先添加：class_addMethod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AFNetworking 源码涉及代码</span><br><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod &#x3D; class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod &#x3D; class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="19-iOS-中内省的几个方法有哪些？内部实现原理是什么"><a href="#19-iOS-中内省的几个方法有哪些？内部实现原理是什么" class="headerlink" title="19. iOS 中内省的几个方法有哪些？内部实现原理是什么"></a>19. iOS 中内省的几个方法有哪些？内部实现原理是什么</h1><p>对象在运行时获取其类型的能力称为内省</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例</span><br><span class="line">-(BOOL) isMemberOfClass:      判断是否是这个类的实例</span><br><span class="line">-(BOOL) respondsToSelector:            判读实例是否实现了该方法</span><br><span class="line">+(BOOL) instancesRespondToSelector:    判断类的实例是否实现了这个方法</span><br></pre></td></tr></table></figure><h1 id="20-属性修饰符-atomic-的内部实现是怎么样的-能保证线程安全吗"><a href="#20-属性修饰符-atomic-的内部实现是怎么样的-能保证线程安全吗" class="headerlink" title="20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗"></a>20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗</h1><ul><li><p>实现机制：atomic 是 property 的修饰词之一，表示是原子性的，使用方式为@property(atomic)int age;,此时编译器会自动生成 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法来进行存取属性。若此时属性用 atomic 修饰的话，在这两个方法内部使用 os_unfair_lock 来进行加锁，来保证读写的原子性。锁都在 PropertyLocks 中保存着（在 iOS 平台会初始化 8 个，mac 平台 64 个），在用之前，会把锁都初始化好，在需要用到时，用对象的地址加上成员变量的偏移量为 key，去 PropertyLocks 中去取。因此存取时用的是同一个锁，所以 atomic 能保证属性的存取时是线程安全的。注：由于锁是有限的，不用对象，不同属性的读取用的也可能是同一个锁</p></li><li><p>不能保证：atomic 在 getter/setter 方法中加锁，仅保证了存取时的线程安全，假设我们的属性是 @property(atomic)NSMutableArray *array;可变的容器时,无法保证对容器的修改是线程安全的</p></li><li><p>在编译器自动生产的 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法存取属性，在此方法内部保证了读写时的线程安全的，当我们重写 getter/setter 方法时，就只能依靠自己在 getter/setter 中保证线程安全</p></li><li><p>os_unfair_lock(互斥锁) 锁，iOS 10 之前使用 OSSpinLock(自旋锁)不能完全保证。</p></li><li><p>OSSpinLock 忙等 是会一直循环等待，循环等待的时候会消耗 cpu 的性能</p></li><li><p>os_unfair_lock 线程休眠，cpu 线程调度的时候会消耗 cpu 性能</p></li></ul><h1 id="21-class、objc-getClass、object-getclass-方法有什么区别"><a href="#21-class、objc-getClass、object-getclass-方法有什么区别" class="headerlink" title="21. class、objc_getClass、object_getclass 方法有什么区别?"></a>21. class、objc_getClass、object_getclass 方法有什么区别?</h1><ul><li>object_getClass:获得的是 isa 的指向</li><li>self.class:当 self 是实例对象的时候，返回的是类对象，否则则返回自身。</li><li>类方法 class，返回的是 self，所以当查找 meta class 时，需要对类对象调用 object_getClass 方法</li></ul><h1 id="22-NSNotification"><a href="#22-NSNotification" class="headerlink" title="22.NSNotification"></a>22.NSNotification</h1><h2 id="1-通知的发送时同步的，还是异步的"><a href="#1-通知的发送时同步的，还是异步的" class="headerlink" title="1. 通知的发送时同步的，还是异步的"></a>1. 通知的发送时同步的，还是异步的</h2><p>同步发送，所有接受者处理完后，才会走发送后下边的代码。</p><h2 id="2-NSNotificationCenter-接受消息和发送消息是在一个线程里吗？如何异步发送消息"><a href="#2-NSNotificationCenter-接受消息和发送消息是在一个线程里吗？如何异步发送消息" class="headerlink" title="2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息"></a>2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息</h2><p>NSNotificationQueue</p><h2 id="3-NSNotificationQueue-是异步还是同步发送？在哪个线程响应"><a href="#3-NSNotificationQueue-是异步还是同步发送？在哪个线程响应" class="headerlink" title="3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应"></a>3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应</h2><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用 NSNotificationCenter 的发送接口进行发送通知，这么看 NSNotificationQueue 最终还是调用 NSNotificationCenter 进行消息的分发。</p><ul><li>依赖 runloop，所以如果在其他子线程使用 NSNotificationQueue，需要开启 runloop</li><li>最终还是通过 NSNotificationCenter 进行发送通知，所以这个角度讲它还是同步的</li><li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程</li></ul><h2 id="4-如何保证通知接收的线程在主线程"><a href="#4-如何保证通知接收的线程在主线程" class="headerlink" title="4.如何保证通知接收的线程在主线程"></a>4.如何保证通知接收的线程在主线程</h2><p>使用 addObserverForName: object: queue: usingBlock 方法注册通知，指定在 mainqueue 上响应 block</p><h2 id="5-下面的方式能接收到通知吗？为什么"><a href="#5-下面的方式能接收到通知吗？为什么" class="headerlink" title="5.下面的方式能接收到通知吗？为什么"></a>5.下面的方式能接收到通知吗？为什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">&#x2F;&#x2F; 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure><p>不会<br>存储是以 name 和 object 为维度的，即判定是不是同一个通知要从 name 和 object 区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的</p><h1 id="23-runloop"><a href="#23-runloop" class="headerlink" title="23.runloop"></a>23.runloop</h1><h2 id="1-app-如何接收到触摸事件的"><a href="#1-app-如何接收到触摸事件的" class="headerlink" title="1.app 如何接收到触摸事件的"></a>1.app 如何接收到触摸事件的</h2><h3 id="1-系统响应阶段-SpringBoad-app-是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。"><a href="#1-系统响应阶段-SpringBoad-app-是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。" class="headerlink" title="1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)"></a>1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)</h3><ul><li>指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。</li><li>IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoad 进程。</li><li>SpringBoard 进程因接收到触摸事件，将触摸事件交给前台 app 进程来处理。</li></ul><h3 id="2-APP-响应阶段"><a href="#2-APP-响应阶段" class="headerlink" title="2.APP 响应阶段"></a>2.APP 响应阶段</h3><ul><li>APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。</li><li>source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。</li><li>source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 hit-testing，另外，此处开始便是与我们平时开发相关的工作了。</li><li>寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。</li><li>触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</li></ul><h2 id="2-事件响应者链"><a href="#2-事件响应者链" class="headerlink" title="2.事件响应者链"></a>2.事件响应者链</h2><p>这个传递的过程叫做 hit-Testing</p><ul><li>事件是自上而下传递的即<br>UIApplication -&gt; UIWindow -&gt; 子试图 -&gt; ..-&gt;子试图中的子试图</li><li>后加试图响应程度更高，即最靠近我们的试图。</li></ul><ol><li>首先调用当前视图的 pointInside:withEvent:方法判断触摸点是否在当前视图内</li><li>若 pointInside:withEvent:方法返回 NO，说明触摸点不在当前视图内，则当前视图的 hitTest:withEvent:返回 nil</li><li>若 pointInside:withEvent:方法返回 YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的 hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从 top 到 bottom，即从 subviews 数组的末尾向前遍历，直到有子视图的 hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕。</li><li>若第一次有子视图的 hitTest:withEvent:方法返回非空对象,则当前视图的 hitTest:withEvent:方法就返回此对象，处理结束</li><li>若所有子视图的 hitTest:withEvent:方法都返回 nil，则当前视图的 hitTest:withEvent:方法返回当前视图自身(self)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断点击的位置是不是在视图内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;返回点击的视图</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (UIView _)hitTest:(CGPoint)point withEvent:(UIEvent _)event&#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 前置条件要满足</span><br><span class="line">   if (self.userInteractionEnabled &#x3D;&#x3D; NO ||</span><br><span class="line">  self.hidden &#x3D;&#x3D; YES ||</span><br><span class="line">   self.alpha &lt;&#x3D; 0.01) return nil;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2. 判断点是否在视图内部 这是最起码的 note point 是在当前视图坐标系的点位置</span><br><span class="line">  if ([self pointInside:point withEvent:event] &#x3D;&#x3D; NO) return nil;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3. 现在起码能确定当前视图能够是响应者 接下去询问子视图</span><br><span class="line">  int count &#x3D; (int)self.subviews.count;</span><br><span class="line">  for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">  &#123;</span><br><span class="line">  &#x2F;&#x2F; 子视图</span><br><span class="line">  UIView *childView &#x3D; self.subviews[i];</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 点需要先转换坐标系</span><br><span class="line">   CGPoint childP &#x3D; [self convertPoint:point toView:childView];</span><br><span class="line">   &#x2F;&#x2F; 子视图开始询问</span><br><span class="line">  UIView *fitView &#x3D; [childView hitTest:childP withEvent:event];</span><br><span class="line">  if (fitView)</span><br><span class="line">  &#123;</span><br><span class="line">  return fitView;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   return self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-为什么只有主线程的-runloop-是开启的"><a href="#3-为什么只有主线程的-runloop-是开启的" class="headerlink" title="3.为什么只有主线程的 runloop 是开启的"></a>3.为什么只有主线程的 runloop 是开启的</h2><ul><li>主线程需要维持一份 RunLoop，保持 App 在 Main 后不会直接退出。</li><li>其他线程默认并没有调用 NSRunLoop *runloop = [NSRunLoop currentRunLoop]</li></ul><h2 id="4-runloop-的-mode-作用是什么？"><a href="#4-runloop-的-mode-作用是什么？" class="headerlink" title="4.runloop 的 mode 作用是什么？"></a>4.runloop 的 mode 作用是什么？</h2><p>mode 主要是用来指定事件在运行循环中的优先级分为:</p><ul><li>NSDefaultRunLoopMode：默认，空闲状态</li><li>UITrackingRunLoopMode: ScrollView 滑动</li><li>UIInitializationRunloopMode: 启动时</li><li>NSRunloopCommonModes：Mode 集合</li></ul><p>苹果公开的有 2 个：<br>NSDefaultRunLoopMode<br>NSRunLoopCommonModes</p><p>定时在 scrollview 滑动时通过添加到 NSRunLoopCommonModes<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p><h2 id="5-为什么只在主线程刷新-UI"><a href="#5-为什么只在主线程刷新-UI" class="headerlink" title="5.为什么只在主线程刷新 UI"></a>5.为什么只在主线程刷新 UI</h2><ul><li>UIKit 并不是一个 线程安全 的类，UI 操作涉及到渲染访问各种 View 对象的属性</li><li>如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度</li><li>另一方面因为整个程序的起点 UIApplication 是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以 view 只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以 60 帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</li></ul><h2 id="6-PerformSelector-和-runloop-的关系"><a href="#6-PerformSelector-和-runloop-的关系" class="headerlink" title="6.PerformSelector 和 runloop 的关系"></a>6.PerformSelector 和 runloop 的关系</h2><ul><li><p>perform 有几种方式，如 [self performSelector:@selector(perform) withObject:nil] 同步执行的，等同于 objc_msgSend 方法执行调用方法。</p></li><li><p><code>[self performSelector:@selector(perform) withObject:nil afterDelay:0]</code> 则是会在当前 runloop 中起一个 timer，如果当前线程没有起 runloop(也就是上面说的没有调用 <code>[NSRunLoop currentRunLoop]</code> 方法的话)，则不会有输出</p></li></ul><h2 id="7-如何使线程保活"><a href="#7-如何使线程保活" class="headerlink" title="7.如何使线程保活"></a>7.如何使线程保活</h2><p>线程保活就是不让线程退出，所以往简单说就是搞个 “while(1)” 自己实现一套处理流程，事件派发就可以了。<br>runloop 线程保活前提就是有事情要处理，这里指 timer，source0，source1 事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Timer</span><br><span class="line">NSTimer *timer &#x3D; [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">   NSLog(@&quot;timer 定时任务&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">[runloop addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runloop run];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Port</span><br><span class="line">NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runLoop run];</span><br></pre></td></tr></table></figure><h2 id="8-runloop-和线程有什么关系？"><a href="#8-runloop-和线程有什么关系？" class="headerlink" title="8.runloop 和线程有什么关系？"></a>8.runloop 和线程有什么关系？</h2><p>runloop 为线程而生，没有线程他就没有存在的必要。<br>runloop 是线程的基础架构部分，runloop 和线程是一一对应关系<br>主线程的 runloop 是默认启动的，其他线程的 runloop 是没有启动的，<br>如果你需要更多的线程交互则可以手动配置和启动。</p><h1 id="24-KVO、KVC"><a href="#24-KVO、KVC" class="headerlink" title="24.KVO、KVC"></a>24.KVO、KVC</h1><h2 id="1-KVO-实现原理"><a href="#1-KVO-实现原理" class="headerlink" title="1.KVO 实现原理"></a>1.KVO 实现原理</h2><p>当你观察一个对象时，系统会动态的创建一个以 <code>NSKVONotifying_</code> 为前缀的类。<br>然后将被观察对象的 isa 指针指向这个新创建的类。<br>这个类继承自该对象的原本类，并重写了被观察属性的 setter 方法。<br>同时也会重写 class 方法，返回原先类对象，这样外部就无感知了。</p><p>重写所有要观察属性的 setter 方法，统一会走一个方法，<br>内部实现是 willChangeValueForKey 和 didChangevlueForKey 方法，<br>然后就是 observeValueForKey:ofObject:change:context:<br>通知所有观察对象值的更改。</p><h2 id="2-如何手动关闭-KVO"><a href="#2-如何手动关闭-KVO" class="headerlink" title="2.如何手动关闭 KVO"></a>2.如何手动关闭 KVO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;closeType&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setProperty:(NSString *)Property&#123;</span><br><span class="line"></span><br><span class="line">    if (_Property!&#x3D;Property) &#123;</span><br><span class="line"></span><br><span class="line">        [self willChangeValueForKey:@&quot;Property&quot;];</span><br><span class="line">        _Property&#x3D;Property;</span><br><span class="line">        [self didChangeValueForKey:@&quot;Property&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通过-KVC-修改属性会触发-KVO-么"><a href="#3-通过-KVC-修改属性会触发-KVO-么" class="headerlink" title="3.通过 KVC 修改属性会触发 KVO 么"></a>3.通过 KVC 修改属性会触发 KVO 么</h2><p>会触发 KVO 操作，KVC 时候会先查询对应的 getter 和 setter 方法。</p><h2 id="4-KVC"><a href="#4-KVC" class="headerlink" title="4.KVC"></a>4.KVC</h2><p>KVC（key-value-codeing）键值编码 是通过一种字符串间接访问对象的方式（即给属性赋值）</p><ul><li><p>KVC 调用 getter 流程：getKEY，KEY，isKEY, _KEY，接着是实例变量 _KEY,_isKEY, KEY, isKEY;</p></li><li><p>KVC 调用 setter 流程：setKEY 和 _setKEY，实例变量顺序 _KEY,_isKEY, KEY, isKEY，没找到就调用 setValue: forUndefinedKey: 当一个对象调用 setValue 方法时，方法内部会做以下操作</p></li></ul><ol><li>检查是否存在相应的 key 的 set 方法，存在就调用 set 方法</li><li>如果 set 方法不存在就找带下划线的成员变量，如果有就直接给成员变量属性赋值。</li><li>如果没有找到_key 就会找相同属性名的 key，有就直接赋值</li><li>如果还没找到，就调用 valueForUndefinedKey:和 setValue:forUndefinedKey:方法。这些方法就抛出异常崩溃了。</li></ol><h2 id="5-哪些情况下使用-kvo-会崩溃，怎么防护崩溃"><a href="#5-哪些情况下使用-kvo-会崩溃，怎么防护崩溃" class="headerlink" title="5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃"></a>5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃</h2><ol><li>添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context:方法，导致崩溃；</li><li>添加或者移除时 keypath == nil，导致崩溃；</li><li>多次重复移除同一个属性，移除了未注册的观察者</li></ol><h2 id="6-KVO-KVC-的优缺点？"><a href="#6-KVO-KVC-的优缺点？" class="headerlink" title="6.KVO/KVC 的优缺点？"></a>6.KVO/KVC 的优缺点？</h2><ul><li>KVC<br>优点：没有 property 的变量（私有）也能通过 KVC 进行设置，或者简化代码（多级属性）<br>缺点：如果 key 只写错，编写的时候不会报错，但是运行的时候会报错</li><li>KVO 优点：<br>能够提供一种简单的方法实现两个对象的同步；<br>能够对内部对象的状态改变作出响应，而且不需要改变内部对象的实现；<br>能够提供被观察者属性的最新值和之前的值；<br>使用 key Path 来观察属性，因此可以观察嵌套对象；<br>完成了对观察对象的抽象，因为不需要额外的代码来允许观察者被观察。</li><li>KVO 缺点：<br>KVO 只能检测类中的属性，并且属性名都是通过 NSString 来查找，编译器不会补全（编译时不会出现警告），容易写错；<br>对属性重构，将导致观察代码不可用；<br>复杂的 “if” 语句要求对象正在观察多个值，是因为所有的观察代码通过一个方法来指向；</li></ul><h1 id="25-Block"><a href="#25-Block" class="headerlink" title="25. Block"></a>25. Block</h1><h2 id="1-block-的内部结构和作用"><a href="#1-block-的内部结构和作用" class="headerlink" title="1.block 的内部结构和作用"></a>1.block 的内部结构和作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    &#x2F;&#x2F; imported variables</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的结构, 可以看出一个 block 实例的构成实际上有 6 个部分：</p><ol><li>isa 指针: 所有对象都有该指针，用于实现对象相关的功能。</li><li>flags: 附加标识位, 在 copy 和 dispose 等情况下可以用到。</li><li>reserved:保留变量。</li><li>invoke: 函数指针，指向 block 的实现代码, 也可以说是函数调用地址。</li><li>descriptor: 表示该 block 的附加描述信息，主要是 size，以及 copy 和 dispose 函数的指针。这两个辅助函数在拷贝及丢弃块对象时运行, 其中会执行一些操作, 比方说, 前者要保留捕获的对象,而后者则将之释放。</li><li>variables: 捕获的变量，block 能够访问它外部的局部变量，就是因为将这些变量复制到了结构体中。</li></ol><h2 id="2-block-的类型"><a href="#2-block-的类型" class="headerlink" title="2.block 的类型"></a>2.block 的类型</h2><p>block 其实是有类型的, 且一共有 3 种类型, 全局块, 栈块, 堆块:</p><ol><li><code>__NSGlobalBlock__</code>: 存储在全局/静态的 block，不会捕获任何外部变量。</li><li><code>__NSStackBlock__</code>: 存储在栈中的 block，当函数返回时会被销毁。</li><li><code>__NSMallocBlock__</code>: 存储在堆中的 block，当引用计数为 0 时会被销毁。</li></ol><ul><li>NSGlobalBlock<br><strong>这种块不会捕捉任何变量, 运行时也无须有状态来参与</strong>。全局块声明在全局内存里, 在编译期已经完全确定了。所以, 无论是 ARC 还是 MRC 下, 如下代码中的 block 都是全局静态的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NSGlobalBlock</span><br><span class="line">- (void)globalBlock &#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;GlobalBlock内部&quot;);               &#x2F;&#x2F; 全局静态区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;GlobalBlock：%@&quot;, block);           &#x2F;&#x2F; 全局静态区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NSStackBlock 或 NSMallocBlock<br>ARC 下为 NSMallocBlock(堆区), MRC 下为 NSStackBlock(栈区)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ARC下为NSMallocBlock(堆区), MRC下为NSStackBlock(栈区)</span><br><span class="line">- (void)stackBlockInMRCAndHeapBlockInARC &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block：%@&quot;, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NSMallocBlock</li></ul><p>要问 MRC 下有没有存储于堆区的 block, 当然有了。但 block 默认会分配在栈区, 需要保留的话, 也可以手动改到堆区, 这样它就是堆块了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MRC下为NSMallocBlock(堆区), ARC下为NSMallocBlock(堆区)</span><br><span class="line">- (void)heapBlock &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    void (^block)(void) &#x3D; [^&#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        NSLog(@&quot;MallocBlock内部：%p&quot;, &amp;a);</span><br><span class="line">    &#125; copy];</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;MallocBlock：%@&quot;, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block 在 ARC 和 MRC 下都是存储于堆区的, 所以其类型是 NSMallocBlock 的。<br>为了解决栈块在其变量作用域结束之后被释放的问题，我们需要把 block copy 到堆中，延长其生命周期。<strong>在开启 ARC 时，编译器会判断其是不是全局块, 若不是全局块则需要将 block 从栈 copy 到堆中，并自动生成相应代码。所以, 上面的例子中, 本不用手动添加 copy 代码的, ARC 会帮我们来做这个事情。</strong></p><ul><li>NSStackBlock<br>创建的 block 没有被持有的时候，编译器就不会做出将其拷贝到堆区的操作，所以这种情况下，它还在栈区。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)stackBlockInARC &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 由于不需要持有block， 所以不需要编译器做多余的拷贝到堆区的操作</span><br><span class="line">    NSLog(@&quot;StackBlock：%@&quot;, ^&#123; NSLog(@&quot;%p&quot;, &amp;a); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-block-类型总结"><a href="#2-block-类型总结" class="headerlink" title="2.block 类型总结"></a>2.block 类型总结</h2><p>总结一下, 在 MRC 中, 可能有三种 block, 就是全局块, 栈块和堆块。 但是在 <strong>ARC 中, 一版情况下只有两种 block, 即全局块和堆块</strong>。由于 ARC 已经能很好地处理对象的生命周期的管理, 所以都放到堆上管理, 不再使用栈区管理了, 所以就栈块的情况就很少了。<br>而且捕获了变量的 block 默认会分配在栈区, 在 MRC 中需要保留的话, 可以手动改到堆区; <strong>在 ARC 中, block 也是在栈区的, 但编译器会并自动将其 copy 到堆中</strong>, 所以会存储在堆区。所以每一个堆块都是由栈块 copy 而来的。<br><strong>在 ARC 下, 当你所创建的 block 没有被指针所持有的时候，编译器就不会做出将其拷贝到堆区的操作。在这种情况下，block 就是一个直接的栈块。</strong></p><h2 id="3-block-捕获局部变量"><a href="#3-block-捕获局部变量" class="headerlink" title="3.block 捕获局部变量"></a>3.block 捕获局部变量</h2><p>不加 <code>__block</code>捕获的是值，加了捕获的是指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)captureVariable &#123;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    NSLog(@&quot;Block前：%p&quot;, &amp;a);             &#x2F;&#x2F; 栈区</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);       &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block后：%p&quot;, &amp;a);             &#x2F;&#x2F; 栈区</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; MRC 下</span><br><span class="line">Block前：0x7ffee3ac9a5c</span><br><span class="line">Block内部：0x7ffee3ac9a48</span><br><span class="line">Block后：0x7ffee3ac9a5c</span><br><span class="line">&#x2F;&#x2F; ARC 下:</span><br><span class="line">Block前：0x7ffee4d91a5c</span><br><span class="line">Block内部：0x6000002590d0</span><br><span class="line">Block后：0x7ffee4d91a5c</span><br></pre></td></tr></table></figure><p>上面的例子 不加<code>__block</code> 在构建 block 的时候, <strong>传入的捕获变量是变量 a 的值(即传入 a)**。 所以对于 block 捕获的变量, block 默认是将其复制到其数据结构中来实现访问的, **且 block 捕获的变量是在 block 内部进行修改是不会影响外部变量的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)capture__blockVariable &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    NSLog(@&quot;Block前：%p&quot;, &amp;a);            &#x2F;&#x2F; 栈区</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);      &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block后：%p&quot;, &amp;a);            &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; MRC 下</span><br><span class="line">Block前：0x7ffee0110a58</span><br><span class="line">Block内部：0x7ffee0110a58</span><br><span class="line">Block后：0x7ffee0110a58</span><br><span class="line">&#x2F;&#x2F; ARC 下</span><br><span class="line">Block前：0x7ffee4d91a58</span><br><span class="line">Block内部：0x600000233578</span><br><span class="line">Block后：0x600000233578</span><br></pre></td></tr></table></figure><p><strong>上面的例子使用 <code>__block</code>修饰 在 ARC 下, block 内部和 block 后的地址是相同的都存在于堆中, 且与 block 前的地址不同。在构建 block 时, 传入捕获变量 a 的地址(即传入&amp;a)。所以对于 block 捕获的<code>__block</code> 修饰的变量，block 是复制其引用地址来实现访问的。自然就可以在 block 内部修改变量从而影响外部的变量了, 且 block 内外打印其地址都是同一个地址。</strong><br><strong>这里的 copy, 都是浅拷贝, 就是所谓的指针拷贝, 所以 a 指针指向的内存地址还是之前定义对象 a 的某块堆区区域。</strong></p><h2 id="4-block-可以用-strong-修饰吗"><a href="#4-block-可以用-strong-修饰吗" class="headerlink" title="4.block 可以用 strong 修饰吗"></a>4.block 可以用 strong 修饰吗</h2><p>ARC 是可以的 strong 和 copy 的操作都是将栈上 block 拷贝到堆上。</p><h2 id="5-block-在修改-NSMutableArray，需不需要添加-block"><a href="#5-block-在修改-NSMutableArray，需不需要添加-block" class="headerlink" title="5.block 在修改 NSMutableArray，需不需要添加__block"></a>5.block 在修改 NSMutableArray，需不需要添加__block</h2><p>不需要，本身 block 内部就捕获了 NSMutableArray 指针，除非你要修改指针指向的对象，而这里明显只是修改内存数据，这个可以类比 NSMutableString。</p><h2 id="6-怎么进行内存管理的"><a href="#6-怎么进行内存管理的" class="headerlink" title="6.怎么进行内存管理的"></a>6.怎么进行内存管理的</h2><ul><li><code>_NSConcreteGlobalBlock</code>:是设置在程序的全局数据区域（.data 区）中的 Block 对象。在全局声明实现的 block 或者 没有用到自动变量的 block 为<code>_NSConcreteGlobalBlock</code>，生命周期从创建到应用程序结束。</li><li><code>_NSConcreteStackBlock</code> 是设置在栈上的 block 对象，生命周期由系统控制的，一旦所属作用域结束，就被系统销毁了。</li></ul><h2 id="7-block-发生-copy-时机"><a href="#7-block-发生-copy-时机" class="headerlink" title="7.block 发生 copy 时机"></a>7.block 发生 copy 时机</h2><ul><li>调用 Block 的 copy 方法</li><li>将 Block 作为函数返回值时</li><li>将 Block 赋值给__strong 修饰的变量或 Block 类型成员变量时</li><li>向 Cocoa 框架含有 usingBlock 的方法或者 GCD 的 API 传递 Block 参数时</li></ul><h1 id="26-多线程"><a href="#26-多线程" class="headerlink" title="26.多线程"></a>26.多线程</h1><h2 id="1-iOS-开发中有多少类型的多线程？分别对比"><a href="#1-iOS-开发中有多少类型的多线程？分别对比" class="headerlink" title="1.iOS 开发中有多少类型的多线程？分别对比"></a>1.iOS 开发中有多少类型的多线程？分别对比</h2><p><strong>1. Pthread</strong>，较少使用。</p><p><strong>2. NSThread</strong>，每个 NSThread 对象对应一个线程，量级较轻，通常我们会起一个 runloop 保活，然后通过添加自定义 source0 源或者 perform onThread 来进行调用。</p><ul><li>优点 轻量级，使用简单，</li><li>缺点：需要自己管理线程的生命周期，保活，另外还会线程同步，加锁、睡眠和唤醒。</li></ul><p><strong>3. GCD</strong>：Grand Central Dispatch（派发） 是基于 C 语言的框架，可以充分利用多核，是苹果推荐使用的多线程技术</p><ul><li>优点：GCD 更接近底层，而 NSOperationQueue 则更高级抽象，所以 GCD 在追求性能的底层操作来说，是速度最快的，有待确认</li><li>缺点：操作之间的事务性，顺序行，依赖关系。GCD 需要自己写更多的代码来实现</li></ul><p><strong>4. NSOperation</strong> 基于 GCD 更高一层封装</p><ul><li>优点： 使用者的关注点都放在了 operation 上，而不需要线程管理。<br>支持在操作对象之间依赖关系，方便控制执行顺序。<br>支持可选的完成块，它在操作的主要任务完成后执行。<br>支持使用 KVO 通知监视操作执行状态的变化。<br>支持设定操作的优先级，从而影响它们的相对执行顺序。<br>支持取消操作，允许您在操作执行时暂停操作。</li><li>缺点：高级抽象，性能方面相较 GCD 来说不足一些;</li></ul><h2 id="2-GCD-有哪些队列，默认提供哪些队列"><a href="#2-GCD-有哪些队列，默认提供哪些队列" class="headerlink" title="2.GCD 有哪些队列，默认提供哪些队列"></a>2.GCD 有哪些队列，默认提供哪些队列</h2><ol><li><p>主队列（main queue ）【串行】<br>保证所有的任务都在主线程执行，而主线程是唯一用于 UI 更新的线程。此外还用于发送消息给视图或发送通知。</p></li><li><p>四个全局调度队列（high、default、low、background【并发】<br>Apple 的接口也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务</p></li><li><p>自定义队列</p><ul><li>多个任务以串行方式执行，但又不想在主线程中</li><li>多个任务以并行方式执行，但不希望队列中有其他系统的任务干扰。</li></ul></li></ol><h2 id="3-GCD-主线程-amp-主队列的关系"><a href="#3-GCD-主线程-amp-主队列的关系" class="headerlink" title="3.GCD 主线程 &amp; 主队列的关系"></a>3.GCD 主线程 &amp; 主队列的关系</h2><p>队列其实就是一个数据结构体，主队列由于是串行队列，所以入队列中的 task 会逐一派发到主线程中执行；但是其他队列也可能会派发到主线程执行</p><h2 id="4-如何实现同步，有多少方式就说多少"><a href="#4-如何实现同步，有多少方式就说多少" class="headerlink" title="4.如何实现同步，有多少方式就说多少"></a>4.如何实现同步，有多少方式就说多少</h2><ul><li>dispatch_sync</li><li>@synchronized</li><li>dispatch_group，</li><li>dispatch_semaphore</li><li>NSLock/NSRecursiveLock</li><li>pthread_mutex_t 互斥锁、递归锁等</li></ul><h2 id="5-有哪些类型的线程锁，分别介绍下作用和使用场景"><a href="#5-有哪些类型的线程锁，分别介绍下作用和使用场景" class="headerlink" title="5.有哪些类型的线程锁，分别介绍下作用和使用场景"></a>5.有哪些类型的线程锁，分别介绍下作用和使用场景</h2><ul><li>@synchronized 性能最差,SD 和 AFN 等框架内部有使用这个.</li><li>NSRecursiveLock 和 NSLock ：建议使用前者，避免循环调用出现死锁</li><li>OSSpinLock 自旋锁,存在的问题是:优先级反转问题,破坏了 spinlock</li><li>dispatch_semaphore 信号量 : 保持线程同步为线程加锁</li></ul><h1 id="27-通过-UIImage-imageNamed-生成的对象什么时候被释放？"><a href="#27-通过-UIImage-imageNamed-生成的对象什么时候被释放？" class="headerlink" title="27.通过[UIImage imageNamed:]生成的对象什么时候被释放？"></a>27.通过[UIImage imageNamed:]生成的对象什么时候被释放？</h1><ul><li>建议针对小图标/场景出现较多图片（此类方式加载，会缓存到内存）</li><li>@autoreleasepool 如果没有使用局部释放池，并且在主线程，则是当前主线程 Runloop 一次循环结束前释放。</li><li>imageWithContentsOfFile ： 加载适用于大图片,不常用的图片,一般无引用时候,会释放</li></ul><h2 id="imageName-amp-imageWithContentsOfFile-区别"><a href="#imageName-amp-imageWithContentsOfFile-区别" class="headerlink" title="imageName &amp; imageWithContentsOfFile 区别"></a>imageName &amp; imageWithContentsOfFile 区别</h2><ul><li>如果图片较小，并且使用频繁的图片使用 imageNamed：方法来加载。相同的图片是不会重复加载的</li><li>如果图片较大，并且使用较少，使用 imageWithContentOfFile:来加载。加载：imageWithContentsOfFile 只能加载 mainBundle 中图片。</li><li>当你不需要重用该图像，或者你需要将图像以数据方式存储到数据库，又或者你要通过网络下载一个很大的图像时，使用 imageWithContentsOfFile；</li><li>如果在程序中经常需要重用的图片，比如用于 UITableView 的图片，那么最好是选择 imageNamed 方法。这种方法可以节省出每次都从磁盘加载图片的时间；</li></ul><h1 id="28-UIView-amp-CALayer-的区别"><a href="#28-UIView-amp-CALayer-的区别" class="headerlink" title="28.UIView &amp; CALayer 的区别"></a>28.UIView &amp; CALayer 的区别</h1><ul><li>UIView 为 CALayer 提供内容，以及负责处理触摸等事件，参与响应链；</li><li>CALayer 负责显示内容 contents</li></ul><h2 id="layoutsubviews"><a href="#layoutsubviews" class="headerlink" title="layoutsubviews"></a>layoutsubviews</h2><ul><li>init 初始化不会触发 layoutSubviews。</li><li>addSubview 会触发 layoutSubviews。</li><li>改变一个 UIView 的 Frame 会触发 layoutSubviews，当然前提是 frame 的值设置前后发生了变化。</li><li>滚动一个 UIScrollView 引发 UIView 的重新布局会触发 layoutSubviews。</li><li>旋转 Screen 会触发父 UIView 上的 layoutSubviews 事件。</li><li>直接调用 setNeedsLayout 或者 layoutIfNeeded。</li><li>setNeedsLayout 标记为需要重新布局，异步调用 layoutIfNeeded 刷新布局，不立即刷新，在下一轮 runloop 结束前刷新，对于这一轮 runloop 之内的所有布局和 UI 上的更新只会刷新一次，layoutSubviews 一定会被调用。</li><li>layoutIfNeeded 如果有需要刷新的标记，立即调用 layoutSubviews 进行布局（如果没有标记，不会调用 layoutSubviews）。</li></ul><h2 id="drawrect"><a href="#drawrect" class="headerlink" title="drawrect"></a>drawrect</h2><ul><li>如果在 UIView 初始化时没有设置 frame，会导致 drawRect 不被自动调用</li><li>sizeToFit 后会调用。这时候可以先用 sizeToFit 中计算出 size，然后系统自动调用 drawRect 方法</li><li>通过设置 contentMode 为.redraw 时，那么在每次设置或更改 frame 的时候自动调用 drawRect</li><li>直接调用 setNeedsDisplay，或者 setNeedsDisplayInRect 会触发 drawRect</li></ul><h1 id="29-图片是什么时候解码的，如何优化"><a href="#29-图片是什么时候解码的，如何优化" class="headerlink" title="29. 图片是什么时候解码的，如何优化"></a>29. 图片是什么时候解码的，如何优化</h1><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</p><h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><ul><li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩</li><li>然后将生成的 UIImage 赋值给 UIImageView ；</li><li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li><li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<ul><li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li><li>将文件数据从磁盘读到内存中；</li><li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li><li>最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。</li></ul></li></ul><h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><p>解码操作是比较耗时的，并且没有 GPU 硬解码，只能通过 CPU，iOS 默认会在主线程对图像进行解码。解码过程是一个相当复杂的任务，需要消耗非常长的时间。60FPS ≈ 0.01666s per frame = 16.7ms per frame，这意味着在主线程超过 16.7ms 的任务都会引起掉帧。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage 的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。</p><ul><li><p>当加载图片的时候，iOS 通常会延迟解压图片的时间，直到加载到内存之后。因为需要在绘制之前进行解压，这就会在准备绘制图片的时候影响性能。</p></li><li><p>iOS 通常会延时解压图片，等到图片在屏幕上显示的时候解压图片。解压图片是非常耗时的操作。</p></li></ul><h1 id="30-性能优化"><a href="#30-性能优化" class="headerlink" title="30.性能优化"></a>30.性能优化</h1><h2 id="1-如何做启动优化，如何监控"><a href="#1-如何做启动优化，如何监控" class="headerlink" title="1.如何做启动优化，如何监控"></a>1.如何做启动优化，如何监控</h2><ul><li>合并或者删减一些 OC 类和函数；可以使用 AppCode 清理项目中没用到的类，属性等。</li><li>将不必须在+load 方法中做的事情延迟到+initialize 中</li><li>类和方法名不要太长：iOS 每个类和方法名都在__cstring 段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的；因还是 object-c 的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c 对象模型会把类/方法名字符串都保存下来；</li><li>在设计师可接受的范围内压缩图片的大小，启动的时候大大小小的图片加载个十来二十个是很正常的，图片小了，IO 操作量就小了，启动当然就会快了，比较靠谱的压缩算法是 TinyPNG。</li><li>减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库；如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库；</li><li>删减一些无用的静态变量，没有被调用到或者已经废弃的方法。</li></ul><h2 id="2-如何做卡顿优化，如何监控"><a href="#2-如何做卡顿优化，如何监控" class="headerlink" title="2.如何做卡顿优化，如何监控"></a>2.如何做卡顿优化，如何监控</h2><blockquote><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></blockquote><h3 id="卡顿原因"><a href="#卡顿原因" class="headerlink" title="卡顿原因"></a>卡顿原因</h3><p>标准情况下，页面滑动流畅是 60FPs ，就是每一秒有 60 帧的画面刷新，每 16.7ms(1/60 秒)有一帧数据。上图两个 VSync 之间的时间就是 16.7ms。<br>如果 CPU 和 GPU 加起来的处理时间超过了 16.7ms，就会造成掉帧甚至卡顿。当 FPs 帧数低于 30 时，人的肉眼就能感觉到画面明显的卡顿。</p><h3 id="卡顿监控"><a href="#卡顿监控" class="headerlink" title="卡顿监控"></a>卡顿监控</h3><ul><li>思路一：监控一秒钟内的帧数是否经常低于或远低于 60FPs。</li><li>思路二：监控每一帧的时长是否超时。</li></ul><p><strong>思路一实现方法：用 CADisplayLinker 来计数</strong></p><p>CADisplayLink 可以以屏幕刷新的频率调用指定 selector，iOS 系统中正常的屏幕刷新率为 60 次/秒，只要在这个方法里面统计每秒这个方法执行的次数，通过次数/时间就可以得出当前屏幕的刷新率了。</p><p><strong>思路二实现方法：通过子线程监测主线程的 RunLoop，判断两个状态 RunLoop 的状态区域之间的耗时是否达到一定阈值。</strong></p><p>开启子线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手，假定连续 6 次超时 50ms 认为卡顿(当然也包含了单次超时 300ms)</p><h3 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h3><p>图像显示的工作是由 CPU 和 GPU 协同完成的， 那么优化的方向和思路就是尽量减少他们的处理时长。</p><ul><li><p><strong>对 CPU 处理的优化:</strong><br>在子线程中进行对象的创建,调整和销毁，节省一部分 CPU 的时间<br>在子线程中预排版(布局计算,文本计算)，让主线程有更多的时间去响应用户的交互<br>对文本等异步绘制,图片编解码等内容进行 预渲染、预排版</p></li><li><p><strong>对 GPU 处理的优化</strong><br>尽量避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这样能少触发离屏渲染<br>尽可能将多张图片合成为一张进行显示，减轻视图层级</p></li></ul><h1 id="31-MVVM-和-MVC-的区别"><a href="#31-MVVM-和-MVC-的区别" class="headerlink" title="31.MVVM 和 MVC 的区别"></a>31.MVVM 和 MVC 的区别</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>M：数据模型， V：视图， C：控制器<br>controller 层拿到 model 更新 view，<br>view 事件传递到 controller 层，更新 model<br><strong>弊端</strong>：C 控制器层 代码逻辑较多</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M：数据模型，V：视图、控制器，VM：处理逻辑、网络</p><ol><li>View 引用 ViewModel，但 ViewModle 不能引用 View 视图、控制器。</li><li>ViewModel 可以引用 Model， Model 不能引用 ViewModel</li><li>viewController 尽量不涉及业务逻辑，让 viewModel 去做这些事情。</li><li>viewController 只是一个中间人，接收 view 的事件、调用 viewModel 的方法、响应 viewModel 的变化。</li></ol><p><strong>优势</strong>：</p><ul><li>低耦合：View 可以独立于 Model 变化和修改，一个 viewModel 可以绑定到不同的 View 上</li><li>可重用性：可以把一些视图逻辑放在一个 viewModel 里面，让很多 view 重用这段视图逻辑</li><li>独立开发：开发人员可以专注于业务逻辑和数据的开发 viewModel，设计人员可以专注于页面设计</li><li>可测试：通常界面是比较难于测试的，而 MVVM 模式可以针对 viewModel 来进行测试</li></ul><p><strong>弊端</strong>：</p><ul><li>对于过大的项目，数据绑定和数据转化需要花费更多的内存（成本）。主要成本在于：</li><li>数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li></ul><h1 id="32-用过设计模式介绍下"><a href="#32-用过设计模式介绍下" class="headerlink" title="32.用过设计模式介绍下"></a>32.用过设计模式介绍下</h1><p><strong>单例模式:</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><ul><li>优点： 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2. 避免对资源的多重占用（比如写文件操作）。</li><li>缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul><p><strong>工厂模式:</strong> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><ul><li>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</li><li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li></ul><p><strong>观察者模式:</strong> 系统的 KVO</p><h1 id="33-描述一个-ViewController-的生命周期"><a href="#33-描述一个-ViewController-的生命周期" class="headerlink" title="33.描述一个 ViewController 的生命周期"></a>33.描述一个 ViewController 的生命周期</h1><ol><li>当我们调用 UIViewControlller 的 view 时，</li><li>系统首先判断当前的 UIViewControlller 是否存在 view，如果存在直接返回 view，</li><li>如果不存在的话，会调用 loadview 方法，</li><li>然后判断 loadview 方法是否是自定义方法，</li><li>如果是自定义方法，就执行自定义方法，</li><li>如果不是自定义方法，判断当时视图控制器是否有 xib、stroyboard。</li><li>如果有 xib、stroyboard 就加载 xib、stroyboard。</li><li>如果没有创建一个空白的 view。</li><li>调用 viewDidLoad 方法。</li><li>最后返回 view</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）&quot;&gt;&lt;a href=&quot;#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="iOS 知识点" scheme="http://example.com/categories/iOS-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>如何通过一个不均匀的硬币得到公平的结果？</title>
    <link href="http://example.com/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/"/>
    <id>http://example.com/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/</id>
    <published>2021-03-07T14:27:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何通过一个不均匀的硬币得到公平的结果？"><a href="#如何通过一个不均匀的硬币得到公平的结果？" class="headerlink" title="如何通过一个不均匀的硬币得到公平的结果？"></a>如何通过一个不均匀的硬币得到公平的结果？</h1><p>假设 60% 概率 正面，40% 概率反面<br>那么抛两次会有下面四种结果</p><ul><li>正 正 36%</li><li>正 反 24%</li><li>反 正 24%</li><li>反 反 16%</li></ul><p>可以看出 正反 与 反正 的概率是相等的。<br>所以抛两次当正反面不同时，都取第一次的结果为最终结果即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何通过一个不均匀的硬币得到公平的结果？&quot;&gt;&lt;a href=&quot;#如何通过一个不均匀的硬币得到公平的结果？&quot; class=&quot;headerlink&quot; title=&quot;如何通过一个不均匀的硬币得到公平的结果？&quot;&gt;&lt;/a&gt;如何通过一个不均匀的硬币得到公平的结果？&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>64匹马,8个赛道,最少比几次找出跑得最快的4匹马？</title>
    <link href="http://example.com/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/"/>
    <id>http://example.com/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/</id>
    <published>2021-03-07T14:27:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<p>11 次<br><a class="link"   href="https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2" >解析文档<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11 次&lt;br&gt;&lt;a class=&quot;link&quot;   href=&quot;https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2&quot; &gt;解析文档&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>10亿个数中找出最大的10000个数（top K问题）</title>
    <link href="http://example.com/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>http://example.com/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/</id>
    <published>2021-03-07T13:16:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-亿个数中找出最大的-10000-个数（top-K-问题）"><a href="#10-亿个数中找出最大的-10000-个数（top-K-问题）" class="headerlink" title="10 亿个数中找出最大的 10000 个数（top K 问题）"></a>10 亿个数中找出最大的 10000 个数（top K 问题）</h1><h2 id="1-对全部数据直接进行排序"><a href="#1-对全部数据直接进行排序" class="headerlink" title="1. 对全部数据直接进行排序"></a>1. 对全部数据直接进行排序</h2><ul><li>时间复杂度 O(nlogn)</li><li>空间复杂度 O(n)</li></ul><p>将 10 亿数据直接进行快排，然后如果大堆长度大于 10000，继续将大堆进行快排。 如果小于 10000 ，那么将最近一次的小堆再次进行快排。如果这个大堆长度加上之前的长度大于 10000，那么对这个大堆进行完整的快排。并取最大的 n 个数。</p><h2 id="2-局部淘汰法"><a href="#2-局部淘汰法" class="headerlink" title="2.局部淘汰法"></a>2.局部淘汰法</h2><ul><li>时间复杂度 O(n+m^2) m 为当前容器大小 10000</li><li>空间复杂度 O(m)</li></ul><p>先保存 10000 个数，然后将后续的数依次与 10000 里最小的数比较，小的直接丢弃，大的进行替换。最后这 10000 个数就是答案。</p><h2 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3.分治法"></a>3.分治法</h2><ul><li>时间复杂度 O(nlogn)</li><li>空间复杂度 O(max(a,b)) a 为每份的长度 这里为 100 万，b 为最后的 m 份的最大 k 这里为 100 份的最大 10000 即 100 万。</li></ul><p>先将 1 亿个数分成 100 份， 每份 100 万个数。然后对每一份进行快排找出最大的 10000 个数。<br>方法是：快排中如果大堆大于 10000 ，继续对大堆进行快排。如果小于 10000，那么对最近的小堆进行快排，如果大堆长度 + 之前的大堆长度满足。那么对大堆进行完全快排取最大的 n 个数。<br>这样找出了 100 份 最大的 10000 个数。继续上边的思路进行快排直到找出最大的 10000 个数。</p><h2 id="4-Hash-法"><a href="#4-Hash-法" class="headerlink" title="4.Hash 法"></a>4.Hash 法</h2><p>先将所有的数存入 hash 表中去重复，减少数据量。然后分治法。</p><blockquote><p><a class="link"   href="https://blog.csdn.net/zyq522376829/article/details/47686867" >https://blog.csdn.net/zyq522376829/article/details/47686867<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-亿个数中找出最大的-10000-个数（top-K-问题）&quot;&gt;&lt;a href=&quot;#10-亿个数中找出最大的-10000-个数（top-K-问题）&quot; class=&quot;headerlink&quot; title=&quot;10 亿个数中找出最大的 10000 个数（top K 问题</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Top K" scheme="http://example.com/tags/Top-K/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-02-28T13:12:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算 &lt;&lt;"></a>左移运算 &lt;&lt;</h1><p>a &lt;&lt; b<br><code>a*(2 的 b 次方)</code></p><p>3 &lt;&lt; 2，则是将数字 3 左移 2 位<br><code>3*(2 的 2 次方)</code></p><h2 id="计算过程："><a href="#计算过程：" class="headerlink" title="计算过程："></a>计算过程：</h2><p>3 &lt;&lt; 2 首先把 3 转换为二进制数字 0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移 2 位，最后在低位(右侧)的两个空位补零。则得到的最终结果是 0000 1100，则转换为十进制是 12。</p><h2 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义:"></a>数学意义:</h2><p>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。</p><h1 id="amp-与运算"><a href="#amp-与运算" class="headerlink" title="&amp; 与运算"></a>&amp; 与运算</h1><p>参加运算的两个数据，按二进制位进行“与”运算。<br>运算规则：0&amp;0=0;0&amp;1=0;1&amp;0=0;1&amp;1=1;<br>即：两位同时为“1”，结果才为“1”，否则为 0<br>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3&amp;5 的值得 1。</p><h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>用 2 整除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为小于 1 时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p><blockquote><p><a class="link"   href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6" >https://baike.baidu.com/item/二进制<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左移运算-lt-lt&quot;&gt;&lt;a href=&quot;#左移运算-lt-lt&quot; class=&quot;headerlink&quot; title=&quot;左移运算 &amp;lt;&amp;lt;&quot;&gt;&lt;/a&gt;左移运算 &amp;lt;&amp;lt;&lt;/h1&gt;&lt;p&gt;a &amp;lt;&amp;lt; b&lt;br&gt;&lt;code&gt;a*(2 的 b 次</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2021-02-24T15:22:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >199. 二叉树的右视图<i class="fas fa-external-link-alt"></i></a></h1><h1 id="解法一-BFS-广度优先-层序遍历"><a href="#解法一-BFS-广度优先-层序遍历" class="headerlink" title="解法一 BFS 广度优先 层序遍历"></a>解法一 BFS 广度优先 层序遍历</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [Int] &#x3D; []</span><br><span class="line">        var treeList &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            let count &#x3D; treeList.count</span><br><span class="line">            for i in 0 ..&lt; count &#123;</span><br><span class="line">                let tree &#x3D; treeList.remove(at: 0)</span><br><span class="line">                if i &#x3D;&#x3D; count - 1 &#123;</span><br><span class="line">                    ans.append(tree.val)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解法二-DFS-深度优先-前序遍历-变形"><a href="#解法二-DFS-深度优先-前序遍历-变形" class="headerlink" title="解法二 DFS 深度优先 前序遍历 变形"></a>解法二 DFS 深度优先 前序遍历 变形</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ans: [Int] &#x3D; []</span><br><span class="line">    func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        dfsSlideView(root, 0)</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfsSlideView(_ root: TreeNode?, _ depth: Int) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        if depth &#x3D;&#x3D; ans.count &#123;</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        let d &#x3D; depth + 1</span><br><span class="line">        dfsSlideView(root.right, d)</span><br><span class="line">        dfsSlideView(root.left, d)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <link href="http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <id>http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</id>
    <published>2021-02-24T15:19:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a class="link"   href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line">        var listTree: [TreeNode] &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        var isLR &#x3D; false</span><br><span class="line">        while !listTree.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempTree: [TreeNode] &#x3D; []</span><br><span class="line">            isLR &#x3D; !isLR</span><br><span class="line">            for tree in listTree &#123;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">                if isLR &#123;</span><br><span class="line">                    valList.append(tree.val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    valList.insert(tree.val, at: 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listTree &#x3D; tempTree</span><br><span class="line">            ans.append(valList)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-32-III-从上到下打印二叉树-III&quot;&gt;&lt;a href=&quot;#剑指-Offer-32-III-从上到下打印二叉树-III&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 32 - III. 从上到下打印二叉树 III&quot;&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-24T15:17:00.000Z</published>
    <updated>2021-06-16T15:32:05.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var treeList: [TreeNode] &#x3D; [root]</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempList: [TreeNode] &#x3D; []</span><br><span class="line">            for tree in treeList &#123;</span><br><span class="line">                valList.append(tree.val)</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(valList)</span><br><span class="line">            treeList &#x3D; tempList</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102. 二叉树的层序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
</feed>
