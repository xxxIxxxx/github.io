<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-24T15:26:37.720Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2021-02-24T15:22:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >199. 二叉树的右视图<i class="fas fa-external-link-alt"></i></a></h1><h1 id="解法一-BFS-广度优先-层序遍历"><a href="#解法一-BFS-广度优先-层序遍历" class="headerlink" title="解法一 BFS 广度优先 层序遍历"></a>解法一 BFS 广度优先 层序遍历</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [Int] &#x3D; []</span><br><span class="line">        var treeList &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            let count &#x3D; treeList.count</span><br><span class="line">            for i in 0 ..&lt; count &#123;</span><br><span class="line">                let tree &#x3D; treeList.remove(at: 0)</span><br><span class="line">                if i &#x3D;&#x3D; count - 1 &#123;</span><br><span class="line">                    ans.append(tree.val)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解法二-DFS-深度优先-前序遍历-变形"><a href="#解法二-DFS-深度优先-前序遍历-变形" class="headerlink" title="解法二 DFS 深度优先 前序遍历 变形"></a>解法二 DFS 深度优先 前序遍历 变形</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ans: [Int] &#x3D; []</span><br><span class="line">    func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        dfsSlideView(root, 0)</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfsSlideView(_ root: TreeNode?, _ depth: Int) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        if depth &#x3D;&#x3D; ans.count &#123;</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        let d &#x3D; depth + 1</span><br><span class="line">        dfsSlideView(root.right, d)</span><br><span class="line">        dfsSlideView(root.left, d)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <link href="http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <id>http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</id>
    <published>2021-02-24T15:19:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a class="link"   href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line">        var listTree: [TreeNode] &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        var isLR &#x3D; false</span><br><span class="line">        while !listTree.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempTree: [TreeNode] &#x3D; []</span><br><span class="line">            isLR &#x3D; !isLR</span><br><span class="line">            for tree in listTree &#123;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">                if isLR &#123;</span><br><span class="line">                    valList.append(tree.val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    valList.insert(tree.val, at: 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listTree &#x3D; tempTree</span><br><span class="line">            ans.append(valList)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-32-III-从上到下打印二叉树-III&quot;&gt;&lt;a href=&quot;#剑指-Offer-32-III-从上到下打印二叉树-III&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 32 - III. 从上到下打印二叉树 III&quot;&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-24T15:17:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var treeList: [TreeNode] &#x3D; [root]</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempList: [TreeNode] &#x3D; []</span><br><span class="line">            for tree in treeList &#123;</span><br><span class="line">                valList.append(tree.val)</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(valList)</span><br><span class="line">            treeList &#x3D; tempList</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102. 二叉树的层序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树 - 中等</title>
    <link href="http://example.com/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-24T10:12:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/zn7zcr.png"                      alt="105. 从前序与中序遍历序列构造二叉树"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是节点的个数，每个节点都访问一次</li><li>空间复杂度<br>O(n) 除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var inorderMap: [Int: Int] &#x3D; [:]</span><br><span class="line"></span><br><span class="line">    func buildTree(_ preorder: [Int], _ inorder: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">        let count &#x3D; preorder.count</span><br><span class="line">        &#x2F;&#x2F; 这一步是为了节省时间 但是增加了空间占用</span><br><span class="line">        for (index, val) in inorder.enumerated() &#123;</span><br><span class="line">            inorderMap[val] &#x3D; index</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, count - 1, 0, count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func myBuildTree(_ preorder: [Int], _ inorder: [Int], _ preorderLeft: Int, _ preorderRight: Int, _ inorderLeft: Int, _ inorderRight: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if preorderLeft &gt; preorderRight &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 前序遍历的第一个节点就是根节点</span><br><span class="line">        let preorderRoot &#x3D; preorderLeft</span><br><span class="line">        &#x2F;&#x2F; 找出中序遍历的根节点位置</span><br><span class="line">        let inorderRoot &#x3D; inorderMap[preorder[preorderRoot]]!</span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        let root &#x3D; TreeNode(preorder[preorderRoot])</span><br><span class="line">        &#x2F;&#x2F; 左子树的节点数目</span><br><span class="line">        let leftTreeCount &#x3D; inorderRoot - inorderLeft</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderLeft + 1 开始的 leftTreeCount 个元素就是 当前 root 左子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderLeft 开始到 inorderRoot - 1]  就是当前 root 左子树的 所有节点</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorderLeft + 1, preorderLeft + leftTreeCount, inorderLeft, inorderRoot - 1)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderRoot + 1(这个1是根节点的长度) + leftTreeCount 到 preorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderRoot + 1 到 inorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorderRoot + 1 + leftTreeCount, preorderRight, inorderRoot + 1, inorderRight)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>226. 翻转二叉树 - 简单</title>
    <link href="http://example.com/2021/02/24/2000-017-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/02/24/2000-017-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-24T07:47:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/invert-binary-tree/" >226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/spum89.png"                      alt="226. 翻转二叉树"                ></p><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从根节点开始反转的</span><br><span class="line">    func invertTree2(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">        var treeRoot &#x3D; root</span><br><span class="line">        let ansRoot &#x3D; root</span><br><span class="line">        var list: [TreeNode] &#x3D; [treeRoot]</span><br><span class="line">        while !list.isEmpty &#123;</span><br><span class="line">            treeRoot &#x3D; list.popLast()!</span><br><span class="line">            let temp &#x3D; treeRoot.right</span><br><span class="line">            treeRoot.right &#x3D; treeRoot.left</span><br><span class="line">            treeRoot.left &#x3D; temp</span><br><span class="line">            if treeRoot.left !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.left!)</span><br><span class="line">            &#125;</span><br><span class="line">            if treeRoot.right !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.right!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ansRoot</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从叶子节点开始反转的</span><br><span class="line">    func invertTree(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        let left &#x3D; invertTree(root.left)</span><br><span class="line">        let right &#x3D; invertTree(root.right)</span><br><span class="line">        root.left &#x3D; right</span><br><span class="line">        root.right &#x3D; left</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;226-翻转二叉树&quot;&gt;&lt;a href=&quot;#226-翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;226. 翻转二叉树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/i</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>70. 爬楼梯 - 简单</title>
    <link href="http://example.com/2021/02/24/2000-016-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://example.com/2021/02/24/2000-016-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2021-02-24T07:09:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a class="link"   href="https://leetcode-cn.com/problems/climbing-stairs/" >70. 爬楼梯<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/kmucz8.png"                      alt="70. 爬楼梯"                ></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li>时间复杂度<br>O(n) n 是输入的，循环执行 n 次</li><li>空间复杂度<br>O(1) 只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; n ans</span><br><span class="line">&#x2F;&#x2F; 1  1</span><br><span class="line">&#x2F;&#x2F; 2  2</span><br><span class="line">&#x2F;&#x2F; 3  3</span><br><span class="line">&#x2F;&#x2F; 4  5</span><br><span class="line">&#x2F;&#x2F;( n 的 ans) &#x3D; (n-1 的 ans) + (n-2 的 ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func climbStairs(_ n: Int) -&gt; Int &#123;</span><br><span class="line">        var b1 &#x3D; 0</span><br><span class="line">        var b2 &#x3D; 1</span><br><span class="line">        var ans &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for _ in 1 ... n &#123;</span><br><span class="line">            ans &#x3D; b1 + b2</span><br><span class="line">            b1 &#x3D; b2</span><br><span class="line">            b2 &#x3D; ans</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. 爬楼梯&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/climbing-s</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>236. 二叉树的最近公共祖先 - 中等</title>
    <link href="http://example.com/2021/02/24/2000-015-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://example.com/2021/02/24/2000-015-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2021-02-24T06:35:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" >236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/8s3kd1.png"                      alt="236. 二叉树的最近公共祖先"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) 其中 N 是二叉树的节点数，所有节点都会被访问一次。</li><li>空间复杂度<br>O(n) 其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var commTree: TreeNode?</span><br><span class="line"></span><br><span class="line">    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        _ &#x3D; dfs(root, p, q)</span><br><span class="line">        return commTree</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfs(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        &#x2F;&#x2F; 左子树是否包含 q 或 q</span><br><span class="line">        let lson &#x3D; dfs(root.left, p, q)</span><br><span class="line">        &#x2F;&#x2F; 右子树是否包含 q 或 q</span><br><span class="line">        let rson &#x3D; dfs(root.right, p, q)</span><br><span class="line">        &#x2F;&#x2F; 左右子树包含pq || (左子树或右子树包含 且 当前root.val &#x3D;&#x3D; p.val 或 q.val)</span><br><span class="line">        if (lson &amp;&amp; rson) || ((lson || rson) &amp;&amp; (root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val)) &#123;</span><br><span class="line">            commTree &#x3D; root</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果包含 p q, 会先命中 root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val</span><br><span class="line">        &#x2F;&#x2F; 这时返回的值是 true, 后面 会命中 lson || rson</span><br><span class="line">        return root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val || lson || rson</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;236. 二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>81. 搜索旋转排序数组 II - 中等</title>
    <link href="http://example.com/2021/02/24/2000-014-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"/>
    <id>http://example.com/2021/02/24/2000-014-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</id>
    <published>2021-02-24T03:08:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" >81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/pwhsby.png"                      alt="81. 搜索旋转排序数组 II"                ></p><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul><li><p>时间复杂度<br>O(n) 大多情况下每次都减少一般的数据</p></li><li><p>空间复杂度<br>O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func search(_ nums: [Int], _ target: Int) -&gt; Bool &#123;</span><br><span class="line">      if nums.isEmpty &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">          return nums[0] &#x3D;&#x3D; target</span><br><span class="line">      &#125;</span><br><span class="line">      var left &#x3D; 0</span><br><span class="line">      var right &#x3D; nums.count - 1</span><br><span class="line">      &#x2F;&#x2F; [1, 2]</span><br><span class="line">      &#x2F;&#x2F; 必须是 &gt;&#x3D; 会存在 到最后左右指针相遇 才找到 目标值的情况</span><br><span class="line">      while right &gt;&#x3D; left &#123;</span><br><span class="line">          let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">          if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">              return true</span><br><span class="line">          &#125;</span><br><span class="line">          if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">              if nums[mid] &lt; target, target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if nums[mid] &gt; nums[right] &#123;</span><br><span class="line">              if nums[left] &lt;&#x3D; target, target &lt; nums[mid] &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              right -&#x3D; 1</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return false</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;81-搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#81-搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;81. 搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字 - 简单</title>
    <link href="http://example.com/2021/02/24/2000-013-%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2021/02/24/2000-013-%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2021-02-24T02:36:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a class="link"   href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" >剑指 Offer 11. 旋转数组的最小数字<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://ftp.bmp.ovh/imgs/2021/02/f8daa4e0fade64f3.png"                      alt="剑指 Offer 11. 旋转数组的最小数字"                ></p><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul><li>时间复杂度<br>O(log n) 在二分查找的过程中，大部分情况都会忽略一半的区间。</li><li>空间复杂度<br>O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return numbers[0]</span><br><span class="line">        &#125;</span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; numbers.count - 1</span><br><span class="line">        while right &gt; left &#123;</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if numbers[mid] &gt; numbers[right] &#123;</span><br><span class="line">                &#x2F;&#x2F; numbers[mid] &gt; numbers[right] mid 已经大于 right 所以 mid 不应该包含在区间内  所以 mid + 1</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            &#125; else if numbers[mid] &lt; numbers[right] &#123;</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;  mid 和 left right 相等的情况， 就让right -&#x3D;1</span><br><span class="line">                right -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[left]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="一次遍历法"><a href="#一次遍历法" class="headerlink" title="一次遍历法"></a>一次遍历法</h1><ul><li>时间复杂度<br>O(n)</li><li>空间复杂度<br>O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        var ans &#x3D; numbers[0]</span><br><span class="line">        for item in numbers &#123;</span><br><span class="line">            ans &#x3D; min(ans, item)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-11-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#剑指-Offer-11-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 11. 旋转数组的最小数字&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>112. 路径总和 - 简单</title>
    <link href="http://example.com/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://example.com/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2021-02-23T15:55:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a class="link"   href="https://leetcode-cn.com/problems/path-sum/" >112. 路径总和<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/lxqfb4.png"                      alt="112. 路径总和"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n),每个节点都要访问一次</li><li>空间复杂度<br>O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        if root.left &#x3D;&#x3D; nil, root.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">            return root.val &#x3D;&#x3D; targetSum</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 递归每次用当前的 sum - 当前 root.val</span><br><span class="line">        &#x2F;&#x2F; 一直 减减减 减到 叶子节点， 就判断当前的 sum 和 root.val 是否相等即可</span><br><span class="line">        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先解法"><a href="#广度优先解法" class="headerlink" title="广度优先解法"></a>广度优先解法</h1><ul><li>时间复杂度<br>O(n),每个节点都要访问一次</li><li>空间复杂度<br>O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; &#x2F;&#x2F; 如果 root &#x3D; nil 那么就一定不存在了</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var stackTree: [TreeNode] &#x3D; [root]</span><br><span class="line">        var treeVal: [Int] &#x3D; [root.val]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;           1</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;   \</span><br><span class="line">        &#x2F;&#x2F;        2     3</span><br><span class="line">        &#x2F;&#x2F;       &#x2F; \    &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;      4   5   6  7</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 1 添加 2 3,同时 treeVal 移除 1.val 添加 1+2.val ，1+3.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 2 添加 4 5,同时 treeVal 移除 2.val 添加 2+4.val ，2+5.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 3 添加 6 7,同时 treeVal 移除 3.val 添加 3+6.val ，3+7.val</span><br><span class="line">        while !stackTree.isEmpty &#123;</span><br><span class="line">            let tree: TreeNode &#x3D; stackTree.popLast()!</span><br><span class="line">            let sum &#x3D; treeVal.popLast()</span><br><span class="line">            if tree.left &#x3D;&#x3D; nil, tree.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">                if sum &#x3D;&#x3D; targetSum &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.left !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.left!)</span><br><span class="line">                treeVal.append(sum! + tree.left!.val)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.right !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.right!)</span><br><span class="line">                treeVal.append(sum! + tree.right!.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;112-路径总和&quot;&gt;&lt;a href=&quot;#112-路径总和&quot; class=&quot;headerlink&quot; title=&quot;112. 路径总和&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/path</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>155. 最小栈 - 简单</title>
    <link href="http://example.com/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://example.com/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2021-02-23T10:23:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a class="link"   href="https://leetcode-cn.com/problems/min-stack/" >155. 最小栈<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/g135og.png"                      alt="155. 最小栈"                ></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ul><li>时间复杂度<br>对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是<br>O(1)，我们定义的每个操作最多调用栈操作两次。</li><li>空间复杂度<br>其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;记录当前最小值</span><br><span class="line">    var minNum: Int?</span><br><span class="line">    &#x2F;&#x2F;只存最小值</span><br><span class="line">    var minNums: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    func push(_ x: Int) &#123;</span><br><span class="line">        list.append(x)</span><br><span class="line">        minNum &#x3D; min(minNum ?? .max, x)</span><br><span class="line">        if minNum &#x3D;&#x3D; x &#123;</span><br><span class="line">            minNums.append(minNum!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func pop() &#123;</span><br><span class="line">        let p &#x3D; list.removeLast()</span><br><span class="line">        if minNum &#x3D;&#x3D; p &#123;</span><br><span class="line">            minNum &#x3D; list.min()</span><br><span class="line">            minNums.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func top() -&gt; Int &#123;</span><br><span class="line">        return list.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getMin() -&gt; Int &#123;</span><br><span class="line">        return minNums.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;155-最小栈&quot;&gt;&lt;a href=&quot;#155-最小栈&quot; class=&quot;headerlink&quot; title=&quot;155. 最小栈&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/min-sta</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是中间人攻击？如何防止攻击？</title>
    <link href="http://example.com/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/"/>
    <id>http://example.com/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/</id>
    <published>2021-02-23T08:10:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h1><p>A &lt;—-&gt; B<br>A &lt;—-&gt; C &lt;—-&gt; B<br>正常是 A 和 B 通信，这时 C 截获了 A 发给 B 的消息，然后假装成 A 给 B 发送消息。</p><p>中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。<br>在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL 协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p><h1 id="如何防止中间人攻击？"><a href="#如何防止中间人攻击？" class="headerlink" title="如何防止中间人攻击？"></a>如何防止中间人攻击？</h1><p>使用由 CA (数字证书认证机构 Certificate Authority)签发或签名的数子证书 来提供认证和加密。证书必须放入服务器和客户端中。</p><p>要信任某个证书真实有效，该证书必须通过属于可信认证中心 (CA) 的根证书进行数字签名。操作系统和浏览器维护有可信 CA 根证书的列表，以便可以轻松验证 CA 签发和签名的证书。</p><blockquote><p>摘录于 <a class="link"   href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" >https://zh.wikipedia.org/wiki/中间人攻击<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN" >https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是中间人攻击？&quot;&gt;&lt;a href=&quot;#什么是中间人攻击？&quot; class=&quot;headerlink&quot; title=&quot;什么是中间人攻击？&quot;&gt;&lt;/a&gt;什么是中间人攻击？&lt;/h1&gt;&lt;p&gt;A &amp;lt;—-&amp;gt; B&lt;br&gt;A &amp;lt;—-&amp;gt; C &amp;lt;—-&amp;gt</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>145. 二叉树的后序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T07:18:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" >145. 二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树的后序遍历 左 右 根</p><p>当根节点的左右子树均为空的时候 add root.val</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        postorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func postorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        postorder(root.left, &amp;list)</span><br><span class="line">        postorder(root.right, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="真迭代解法"><a href="#真迭代解法" class="headerlink" title="真迭代解法"></a>真迭代解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal1(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 用来记录回退的根节点 在回退的时候 要判断这个是不是刚刚回退的节点 如果不加判断会死循环</span><br><span class="line">        var lastTree: TreeNode?</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; root.right &#x3D;&#x3D; nil 时做下列操作很容易理解</span><br><span class="line">            if root?.right &#x3D;&#x3D; nil || root?.right &#x3D;&#x3D;&#x3D; lastTree &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                &#x2F;&#x2F; 这个时候要回退了，所以先记录当前的这个节点</span><br><span class="line">                lastTree &#x3D; root</span><br><span class="line">                &#x2F;&#x2F; 要把 root 置 nil 进行回退， 否则又是死循环</span><br><span class="line">                root &#x3D; nil</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="假后序解法"><a href="#假后序解法" class="headerlink" title="假后序解法"></a>假后序解法</h1><ul><li>时间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。 一个 n 是所有节点的遍历，另一个是最后的反转</li><li>空间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。一个 n 是迭代栈的开销，一个是最后反转的开销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal2(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 后序遍历的顺序是  左右根</span><br><span class="line">        &#x2F;&#x2F; 反转后是 根右左，和前序遍历的 根左右 很像</span><br><span class="line">        &#x2F;&#x2F; 所以来用前序遍历的变形写法，然后把得的数据反转就行了</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.reversed()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; title=&quot;145. 二叉树的后序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>144. 二叉树的前序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T05:09:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" >144. 二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树的前序遍历 根 左 右</p><p>当根节点不为空时,直接把 root.val add list</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        preorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func preorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        preorder(root.left, &amp;list)</span><br><span class="line">        preorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. 二叉树的前序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>94. 二叉树的中序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T03:05:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树中序遍历顺序为 左 根 右<br>当根节点的左子树为空时添加该根节点，即在 root.left = nil, 后 add root.val</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度 O(n)<br>空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        inorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func inorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 中序遍历 左 中 右</span><br><span class="line">        &#x2F;&#x2F; 即中序遍历，左根右。当根结点的左子树为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即前序遍历，根左右。当根节点不为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即后序遍历，左右根。当根节点的左右子树均为空时，那么 add root.val</span><br><span class="line">        inorder(root.left, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        inorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度 O(n)<br>空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var tempList: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line"></span><br><span class="line">        while root !&#x3D; nil || !tempList.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                tempList.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; tempList.popLast()</span><br><span class="line">            list.append(root!.val)</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>53. 最大子序和-简单</title>
    <link href="http://example.com/2021/02/23/2000-007-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://example.com/2021/02/23/2000-007-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2021-02-23T01:59:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a class="link"   href="https://leetcode-cn.com/problems/maximum-subarray/" >53. 最大子序和<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/o6raa6.png"                      alt="53. 最大子序和"                ></p><h1 id="动态规划-解法"><a href="#动态规划-解法" class="headerlink" title="动态规划 解法"></a>动态规划 解法</h1><ul><li>时间复杂度 O(n)<br>一次遍历，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li><li>空间复杂度 O(1)<br>只开辟了两个额外的空间，即只需要常数空间存放若干变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func maxSubArray(_ nums: [Int]) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为和</span><br><span class="line">        var sum &#x3D; nums[0]</span><br><span class="line">        &#x2F;&#x2F; 取nums[0] 为当前最大值</span><br><span class="line">        var ans &#x3D; nums[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 因为已经把 nums[0] 计算了，所以从 nums[1] 开始</span><br><span class="line">        for i in 1 ..&lt; nums.count &#123;</span><br><span class="line">            if sum &lt; 0 &#123; &#x2F;&#x2F; 如果 sum 小于 0 ，那么 sum + nums[i] 只会让 nums[i] 更小</span><br><span class="line">                sum &#x3D; nums[i] &#x2F;&#x2F; 所以接把 num[i] 赋值给 sum</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; sum &gt;&#x3D; 0 那么就直接加 nums[i] 不用考虑 nums[i] 是大于零 还是小于零</span><br><span class="line">                sum &#x3D; sum + nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; (sum &gt; ans) ? sum : ans</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-最大子序和&quot;&gt;&lt;a href=&quot;#53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. 最大子序和&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/maxi</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>912. 排序数组</title>
    <link href="http://example.com/2021/02/22/2000-006-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/02/22/2000-006-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-02-22T15:16:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a class="link"   href="https://leetcode-cn.com/problems/sort-an-array/" >912. 排序数组<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/stmaiz.png"                      alt="912. 排序数组"                ></p><h1 id="快速排序-递归解法"><a href="#快速排序-递归解法" class="headerlink" title="快速排序 递归解法"></a>快速排序 递归解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">        var nums &#x3D; nums</span><br><span class="line">        sort2(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort2(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        if left &lt; right &#123;</span><br><span class="line">            let p &#x3D; partition(&amp;nums, left, right)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值左边的数据 分界值的位置已经确定 所以传入 right &#x3D; p - 1</span><br><span class="line">            sort2(&amp;nums, left, p - 1)</span><br><span class="line">            &#x2F;&#x2F; 同样的方法处理分界值右边的数据 分界值的位置已经确定 所以传入 left &#x3D; p + 1</span><br><span class="line">            sort2(&amp;nums, p + 1, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func partition(_ nums: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123;</span><br><span class="line">        &#x2F;&#x2F; 直接以 nums[right] 为分界值</span><br><span class="line">        let p &#x3D; nums[right]</span><br><span class="line">        &#x2F;&#x2F; 记录下一个 比分界值小的值 应该移动到哪个位置， 默认为最左边</span><br><span class="line">        var minL &#x3D; left</span><br><span class="line">        for i in left ..&lt; right &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前值 小于等于分界值，那么交换 i 和 minL 的值。否则不做处理</span><br><span class="line">            if nums[i] &lt;&#x3D; p &#123;</span><br><span class="line">                swap(&amp;nums, minL, i)</span><br><span class="line">                &#x2F;&#x2F; minL 已经被小于等于分界值的值占用，那么 +&#x3D; 1</span><br><span class="line">                minL +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 到这里，在 minL 索引 前的值都是小于等于 分界值的，在 minL 到 right - 1，包括 minL 的值都是大于 分界值的。 分界值一直在最后</span><br><span class="line">        &#x2F;&#x2F; 所以 把分界值 和 nums[minL] 交换位置</span><br><span class="line">        swap(&amp;nums, minL, right)</span><br><span class="line">        &#x2F;&#x2F; 返回分界值所在的 位置</span><br><span class="line">        return minL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func swap(_ nums: inout [Int], _ a: Int, _ b: Int) &#123;</span><br><span class="line">        let temp &#x3D; nums[a]</span><br><span class="line">        nums[a] &#x3D; nums[b]</span><br><span class="line">        nums[b] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序-迭代解法"><a href="#快速排序-迭代解法" class="headerlink" title="快速排序 迭代解法"></a>快速排序 迭代解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ution &#123;</span><br><span class="line">    func sortArray(_ nums: [Int]) -&gt; [Int] &#123;</span><br><span class="line">         var nums &#x3D; nums</span><br><span class="line">        sort(&amp;nums, 0, nums.count - 1)</span><br><span class="line">        return nums</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func sort(_ nums: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        &#x2F;&#x2F; 取中间值 做为当前的 分界值</span><br><span class="line">        let pivot &#x3D; nums[(right - left) &#x2F; 2 + left]</span><br><span class="line">        var L &#x3D; left</span><br><span class="line">        var R &#x3D; right</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; L &lt; R 说明 L 和 R 没相遇</span><br><span class="line">        while L &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 左边的数小于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从左往右  所以 L +&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数大于 pivot ， 那么跳出这个循环 且这个数的索引位 L</span><br><span class="line"></span><br><span class="line">            while nums[L] &lt; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 pivot 右边的数大于 pivot，那么就不用移动这个数。</span><br><span class="line">            &#x2F;&#x2F; 接着继续看下一个 因为是从右往左 所以 R -&#x3D; 1</span><br><span class="line">            &#x2F;&#x2F; 如果这个数小于 pivot ， 那么跳出这个循环 且这个数的索引位 R</span><br><span class="line"></span><br><span class="line">            while nums[R] &gt; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; L &gt;&#x3D; R 说明 pivot 左边已经是 全部小于等于 pivot ，右边 全部是 大于等于 pivot。 可以提前退出</span><br><span class="line">            if L &gt;&#x3D; R &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 跳出了上边的两个循环之后 说明 分别找到了</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 左边，但大于等于 pivot 的数，它的索引为 L</span><br><span class="line">            &#x2F;&#x2F; 一个在 pivot 右边，但小于等于 pivot 的数，它的索引位 R</span><br><span class="line">            &#x2F;&#x2F; 那么交换这两个数的位置</span><br><span class="line"></span><br><span class="line">            let temp &#x3D; nums[L]</span><br><span class="line">            nums[L] &#x3D; nums[R]</span><br><span class="line">            nums[R] &#x3D; temp</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 交换完后 nums[L] 是小于等于 pivot, nums[R] 是大于等于 pivot</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[L] &#x3D;&#x3D; pivot 了,要让 R -&#x3D; 1，</span><br><span class="line">            if nums[L] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                R -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果 nums[R] &#x3D;&#x3D; pivot 了,要让 L +&#x3D; 1</span><br><span class="line">            if nums[R] &#x3D;&#x3D; pivot &#123;</span><br><span class="line">                L +&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果不处理 交换完后 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 的情况，</span><br><span class="line">            &#x2F;&#x2F; 当 nums[L] &#x3D;&#x3D; pivot 和 nums[R] &#x3D;&#x3D; pivot 都是 true 时，</span><br><span class="line">            &#x2F;&#x2F; 上边的两个 while 也不会在执行了， 那么 L 和 R 的数值也不会再发生变化 就卡死在这里了</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 到这里 L &gt;&#x3D; R 说明相遇了</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 左边的数都是 小于等于 pivot 的</span><br><span class="line">        &#x2F;&#x2F; 那么 pivot 右边的数都是 大于等于 pivot 的</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这一步是防止对 pivot 左右分别操作时越界</span><br><span class="line">        if L &#x3D;&#x3D; R &#123;</span><br><span class="line">            L +&#x3D; 1</span><br><span class="line">            R -&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if left &lt; R &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 左边的数据</span><br><span class="line">            sort(&amp;nums, left, R)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if right &gt; L &#123;</span><br><span class="line">            &#x2F;&#x2F; 继续处理 pivot 右边的数据</span><br><span class="line">            sort(&amp;nums, L, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;912-排序数组&quot;&gt;&lt;a href=&quot;#912-排序数组&quot; class=&quot;headerlink&quot; title=&quot;912. 排序数组&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/sort</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="快速排序" scheme="http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简述 TCP 的 TIME_WAIT</title>
    <link href="http://example.com/2021/02/22/1000-019%E7%AE%80%E8%BF%B0%20TCP%20%E7%9A%84%20TIME_WAIT/"/>
    <id>http://example.com/2021/02/22/1000-019%E7%AE%80%E8%BF%B0%20TCP%20%E7%9A%84%20TIME_WAIT/</id>
    <published>2021-02-22T07:09:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么-TIME-WAIT"><a href="#为什么-TIME-WAIT" class="headerlink" title="为什么 TIME_WAIT"></a>为什么 TIME_WAIT</h1><p>主动关闭连接的一方最终进入 <code>TIME_WAIT</code> 状态等待一段才真正的释放内核中的连接记录，在释放记录之前这个连接使用的本地端口将一直被占用。<br>保持一段时间的 <code>TIME_WAIT</code> 的理由是：担心 <code>ack N+1</code> 没有送达，导致被动方重传 <code>FIN N</code>，那么主动方应当再次响应 <code>ack N+1</code>。<br>如果没有 <code>TIME_WAIT</code> 就直接复用该连接占用的端口，那么万一被动方重传<code>FIN N</code>，那么使用相同端口的新连接就会被错误关闭。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/m8c6bs.png"                      alt="四次挥手"                ></p><h1 id="优化-TIME-WAIT"><a href="#优化-TIME-WAIT" class="headerlink" title="优化 TIME_WAIT"></a>优化 TIME_WAIT</h1><p>谁主动关闭 <code>socket</code>，谁<code>TIME_WAIT</code>。<br>如果双方响应正常，TIME_WAIT 应该只是瞬间状态。</p><h1 id="服务端主动关闭"><a href="#服务端主动关闭" class="headerlink" title="服务端主动关闭"></a>服务端主动关闭</h1><p>无论有多少连接，服务端都只有一个端口，那就是监听端口，大量连接之间的差异仅仅是 TCP 4 元祖的客户端 ip 和 port 不同而已。</p><p>因此服务端<code>TIME_WAIT</code>压根不会耗尽端口，因为它就一个端口。</p><p>那么服务端就不需要优化了吗？对，没必要优化，一个<code>TIME_WAIT</code>的 4 元祖当遇到新的 SYN 时会复用，不需要特殊配置。</p><p>另外，当<code>TIME_WAIT</code>数量超过内核选项 net.ipv4.tcp_max_tw_buckets 的限制时，多余的<code>TIME_WAIT</code>连接将被立即关闭，然后在 netstat -s 中留下如下的溢出统计指标：</p><h1 id="客户端主动关闭"><a href="#客户端主动关闭" class="headerlink" title="客户端主动关闭"></a>客户端主动关闭</h1><p>客户端每个连接都会随机选择一个本地端口，所以最终会导致客户端大量端口处于 TIME_WAIT 状态，这和服务端主动关闭是最大的不同。<br>所以我们通常所说的 TIME_WAIT 问题都是针对客户端的，只是好像很少有人提及这一点。<br>网上有一种优化手段是把 net.ipv4.tcp_max_tw_buckets 调低，这样 TIME_WAIT 连接就会被删除，但是这不是一个最佳手段哈。</p><p>目前唯一安全的选项就是同时开启如下 2 个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps&#x3D;1（连接发起方和接收方都需要开启）</span><br><span class="line">net.ipv4.tcp_tw_reuse&#x3D;1（只影响连接发起方）</span><br></pre></td></tr></table></figure><p>上述配置只影响连接发起方，也就是客户端，对服务端是无效的。<br>它的作用是向外发起连接的时候，可以复用 TIME_WAIT 的端口，但是有一个前提<br>该端口最后一次通讯时间距离当前系统时间&gt;1 秒</p><blockquote><p>摘录于 <a class="link"   href="https://yuerblog.cc/2020/03/09/%E5%85%B3%E4%BA%8Etime_wait%E9%97%AE%E9%A2%98%E7%AE%80%E8%BF%B0%E4%B8%8E%E4%BC%98%E5%8C%96/" >https://yuerblog.cc/2020/03/09/关于time_wait问题简述与优化/<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么-TIME-WAIT&quot;&gt;&lt;a href=&quot;#为什么-TIME-WAIT&quot; class=&quot;headerlink&quot; title=&quot;为什么 TIME_WAIT&quot;&gt;&lt;/a&gt;为什么 TIME_WAIT&lt;/h1&gt;&lt;p&gt;主动关闭连接的一方最终进入 &lt;code&gt;TIME_W</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="四次挥手" scheme="http://example.com/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>简述 http 1.0，1.1，2.0 的主要区别</title>
    <link href="http://example.com/2021/02/22/1000-018%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/02/22/1000-018%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</id>
    <published>2021-02-22T06:07:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>http1.0 到 http1.1 的主要区别，就是从无连接到长连接。<br>http2.0 对比 1.X 版本主要区别就是多路复用。</p><h1 id="http-1-0-特性"><a href="#http-1-0-特性" class="headerlink" title="http 1.0 特性"></a>http 1.0 特性</h1><h2 id="1-无状态"><a href="#1-无状态" class="headerlink" title="1. 无状态"></a>1. 无状态</h2><p>服务器不跟踪不记录请求过的状态<br>对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录</p><h2 id="2-无连接"><a href="#2-无连接" class="headerlink" title="2. 无连接"></a>2. 无连接</h2><p>浏览器每次请求都需要建立 tcp 连接</p><p>无连接导致的性能缺陷有两种：</p><ol><li>无法复用连接<br>每次发送请求，都需要进行一次 tcp 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低</li><li>队头阻塞<br>http1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li></ol><h1 id="http-1-1-特性"><a href="#http-1-1-特性" class="headerlink" title="http 1.1 特性"></a>http 1.1 特性</h1><p>为了解决 http1.0 的性能缺陷，http1.1 出现了</p><h2 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1. 长连接"></a>1. 长连接</h2><p>http1.1 默认保持长连接，数据传输完成保持 tcp 连接不断开,继续用这个通道传输数据。<br>新增 Connection 字段，可以设置 keep-alive 值保持连接不断开。</p><h2 id="2-管道化"><a href="#2-管道化" class="headerlink" title="2. 管道化"></a>2. 管道化</h2><p>基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p><p>基于长连接的基础，我们先看没有管道化请求响应：<br>tcp 没有断开，用的同一个通道<br><code>请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></p><p>管道化的请求响应：<br><code>请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</code><br>即使服务器先准备好响应 2,也是按照请求顺序先返回响应 1<br>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h2 id="3-缓存处理"><a href="#3-缓存处理" class="headerlink" title="3. 缓存处理"></a>3. 缓存处理</h2><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。<br>新增字段 cache-control 来控制</p><h2 id="4-断点传输"><a href="#4-断点传输" class="headerlink" title="4. 断点传输"></a>4. 断点传输</h2><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率<br>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p><h1 id="http-2-0-特性"><a href="#http-2-0-特性" class="headerlink" title="http 2.0 特性"></a>http 2.0 特性</h1><h2 id="1-二进制分帧"><a href="#1-二进制分帧" class="headerlink" title="1. 二进制分帧"></a>1. 二进制分帧</h2><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p><h2 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2. 多路复用"></a>2. 多路复用</h2><p>在共享 TCP 链接的基础上同时发送请求和响应<br>一个 Tcp 中多个 http 请求是并行的</p><h2 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h2><p>http2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p><h2 id="4-服务器推送"><a href="#4-服务器推送" class="headerlink" title="4. 服务器推送"></a>4. 服务器推送</h2><p>服务器可以额外的向客户端推送资源，而无需客户端明确的请求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;p&gt;http1.0 到 http1.1 的主要区别，就是从无连接到长连接。&lt;br&gt;http2.0 对比 1.X 版本主要区别就是多路复用。&lt;/p</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>141. 环形链表</title>
    <link href="http://example.com/2021/02/21/2000-005-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/02/21/2000-005-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-02-21T15:49:00.000Z</published>
    <updated>2021-02-24T15:26:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a class="link"   href="https://leetcode-cn.com/problems/linked-list-cycle/" >141. 环形链表<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/3k71ua.png"                      alt="141. 环形链表"                ></p><h1 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        var slowTree &#x3D; head</span><br><span class="line">        var fastTree &#x3D; head?.next</span><br><span class="line"></span><br><span class="line">        while slowTree !&#x3D; nil || fastTree !&#x3D; nil &#123;</span><br><span class="line">            if slowTree &#x3D;&#x3D;&#x3D; fastTree &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            slowTree &#x3D; slowTree?.next</span><br><span class="line">            fastTree &#x3D; fastTree?.next?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hasCycle(_ head: ListNode?) -&gt; Bool &#123;</span><br><span class="line">        &#x2F;&#x2F; 注意这里使用 Set, 使用 Array 会超时</span><br><span class="line">        &#x2F;&#x2F; ListNode 需要实现 Equatable, Hashable 协议</span><br><span class="line">        var list: Set&lt;ListNode&gt; &#x3D; []</span><br><span class="line">        var head &#x3D; head</span><br><span class="line"></span><br><span class="line">        while head !&#x3D; nil &#123;</span><br><span class="line">            if list.contains(head!) &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">            list.insert(head!)</span><br><span class="line">            head &#x3D; head?.next</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Swift-链表-及-实现协议"><a href="#Swift-链表-及-实现协议" class="headerlink" title="Swift 链表 及 实现协议"></a>Swift 链表 及 实现协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    public var val: Int</span><br><span class="line">    public var next: ListNode?</span><br><span class="line">    public init() &#123; self.val &#x3D; 0; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int) &#123; self.val &#x3D; val; self.next &#x3D; nil &#125;</span><br><span class="line">    public init(_ val: Int, _ next: ListNode?) &#123; self.val &#x3D; val; self.next &#x3D; next &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Equatable &#123;</span><br><span class="line">    public static func &#x3D;&#x3D; (l: ListNode, r: ListNode) -&gt; Bool &#123;</span><br><span class="line">        return l &#x3D;&#x3D;&#x3D; r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ListNode: Hashable &#123;</span><br><span class="line">    public func hash(into hasher: inout Hasher) &#123;</span><br><span class="line">        hasher.combine(ObjectIdentifier(self))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;141-环形链表&quot;&gt;&lt;a href=&quot;#141-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. 环形链表&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/link</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="快慢指针" scheme="http://example.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
