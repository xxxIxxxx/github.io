<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-05T08:18:23.148Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 实用技巧</title>
    <link href="http://example.com/2021/06/05/100-Swift%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2021/06/05/100-Swift%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-06-05T08:13:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-protocol-extension-初始化后直接配置相应属性"><a href="#1-protocol-extension-初始化后直接配置相应属性" class="headerlink" title="1. protocol + extension 初始化后直接配置相应属性"></a>1. protocol + extension 初始化后直接配置相应属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol XXXBuilder &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension XXXBuilder &#123;</span><br><span class="line">    public func with(configure: (inout Self) -&gt; Void) -&gt; Self &#123;</span><br><span class="line">        var this &#x3D; self</span><br><span class="line">        configure(&amp;this)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension NSObject: XXXBuilder &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">let tipLab &#x3D; UILabel().with &#123; lab in</span><br><span class="line">            lab.textColor &#x3D; .red</span><br><span class="line">            lab.backgroundColor &#x3D; .black</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-protocol-extension-初始化后直接配置相应属性&quot;&gt;&lt;a href=&quot;#1-protocol-extension-初始化后直接配置相应属性&quot; class=&quot;headerlink&quot; title=&quot;1. protocol + extension 初始</summary>
      
    
    
    
    <category term="Swift" scheme="http://example.com/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Swift 中为 String 添加扩展</title>
    <link href="http://example.com/2021/06/05/100-Swift%E4%B8%ADString%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2021/06/05/100-Swift%E4%B8%ADString%E6%89%A9%E5%B1%95/</id>
    <published>2021-06-05T07:55:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-extension-代码"><a href="#String-extension-代码" class="headerlink" title="String extension 代码"></a>String extension 代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">extension String &#123;</span><br><span class="line">    func index(from: Int) -&gt; Index &#123;</span><br><span class="line">        &#x2F;&#x2F; 增加越界防护， 负数就不考虑了吧</span><br><span class="line">        if from &lt; count &#123;</span><br><span class="line">            return index(startIndex, offsetBy: from)</span><br><span class="line">        &#125;</span><br><span class="line">        return endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(from: Int) -&gt; String &#123;</span><br><span class="line">        let fromIndex &#x3D; index(from: from)</span><br><span class="line">        return String(self[fromIndex...])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(to: Int) -&gt; String &#123;</span><br><span class="line">        String(prefix(to))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func substring(with r: Range&lt;Int&gt;) -&gt; String &#123;</span><br><span class="line">        let startIndex &#x3D; index(from: r.lowerBound)</span><br><span class="line">        let endIndex &#x3D; index(from: r.upperBound)</span><br><span class="line">        return String(self[startIndex ..&lt; endIndex])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;01234567&quot;</span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(from: 0) &#x2F;&#x2F; &quot;01234567&quot;</span><br><span class="line">_ &#x3D; str.substring(from: 4) &#x2F;&#x2F; &quot;4567&quot;</span><br><span class="line">_ &#x3D; str.substring(from: 100) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(to: 0) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line">_ &#x3D; str.substring(to: 1) &#x2F;&#x2F; &quot;0&quot;</span><br><span class="line">_ &#x3D; str.substring(to: 100) &#x2F;&#x2F; &quot;01234567&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_ &#x3D; str.substring(with: 0 ..&lt; 1) &#x2F;&#x2F; &quot;0&quot;</span><br><span class="line">_ &#x3D; str.substring(with: 0 ..&lt; 100) &#x2F;&#x2F; &quot;01234567&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String-extension-代码&quot;&gt;&lt;a href=&quot;#String-extension-代码&quot; class=&quot;headerlink&quot; title=&quot;String extension 代码&quot;&gt;&lt;/a&gt;String extension 代码&lt;/h1&gt;&lt;figu</summary>
      
    
    
    
    <category term="Swift" scheme="http://example.com/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>运输层协议和网络层协议的区别</title>
    <link href="http://example.com/2021/06/02/1000-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/02/1000-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-02T14:42:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运输层协议和网络层协议的区别"><a href="#运输层协议和网络层协议的区别" class="headerlink" title="运输层协议和网络层协议的区别"></a>运输层协议和网络层协议的区别</h1><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运输层协议和网络层协议的区别&quot;&gt;&lt;a href=&quot;#运输层协议和网络层协议的区别&quot; class=&quot;headerlink&quot; title=&quot;运输层协议和网络层协议的区别&quot;&gt;&lt;/a&gt;运输层协议和网络层协议的区别&lt;/h1&gt;&lt;p&gt;网络层协议负责提供主机间的逻辑通信；运输层协</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>网络地址转换 NAT</title>
    <link href="http://example.com/2021/06/02/1000-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20NAT/"/>
    <id>http://example.com/2021/06/02/1000-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%20NAT/</id>
    <published>2021-06-02T14:38:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h1><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p><p>NAT 的实现方式主要有三种：</p><ul><li><p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p></li><li><p>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p></li><li><p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络地址转换-NAT&quot;&gt;&lt;a href=&quot;#网络地址转换-NAT&quot; class=&quot;headerlink&quot; title=&quot;网络地址转换 NAT&quot;&gt;&lt;/a&gt;网络地址转换 NAT&lt;/h1&gt;&lt;p&gt;NAT（Network Address Translation），即网络地址</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>ARP 地址解析协议的原理和地址解析过程</title>
    <link href="http://example.com/2021/06/02/1000-ARP%20%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/06/02/1000-ARP%20%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</id>
    <published>2021-06-02T14:37:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARP-地址解析协议的原理和地址解析过程"><a href="#ARP-地址解析协议的原理和地址解析过程" class="headerlink" title="ARP 地址解析协议的原理和地址解析过程"></a>ARP 地址解析协议的原理和地址解析过程</h1><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48 位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p><p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p><p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p><p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p><p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p><p>使用 ARP 的 4 种情况：</p><ol><li>发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARP-地址解析协议的原理和地址解析过程&quot;&gt;&lt;a href=&quot;#ARP-地址解析协议的原理和地址解析过程&quot; class=&quot;headerlink&quot; title=&quot;ARP 地址解析协议的原理和地址解析过程&quot;&gt;&lt;/a&gt;ARP 地址解析协议的原理和地址解析过程&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器和交换机的区别</title>
    <link href="http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-02T14:30:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h1><ul><li><strong>交换机：</strong> 交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li></ul><ul><li><strong>路由器：</strong> 路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li></ul><ul><li>交换机的端口不具有实际的 MAC 地址,因此交换机只是把接收到的消息转发出去而已，它的各端口并不以实际的发送方或接收方的身份参与到以太网包的传递过程；而路由器的端口具有 MAC 地址 IP 地址，所以它的端口是作为以太网包实际的接收方与发送方的身份存在的。</li><li>当交换机不知道将包转发到哪一个端口时，它会将包转发到除了源端口以外的所有端口；而当路由器不知道将包转发到哪一端口时，它就直接丢弃这个包。产生这种区别的原因是他们所连接的网络的规模不同——交换机工作在局域网，它所连接的网络规模比较小，向所有端口转发也不会造成多大问题；但路由器工作的环境是互联网，它的规模是远大于互联网的，若向所有端口转发则会产生大量的网络包，造成网络拥塞。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器和交换机的区别&quot;&gt;&lt;a href=&quot;#路由器和交换机的区别&quot; class=&quot;headerlink&quot; title=&quot;路由器和交换机的区别&quot;&gt;&lt;/a&gt;路由器和交换机的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;交换机：&lt;/strong&gt; 交换机用于局域网，利</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器的分组转发流程</title>
    <link href="http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/06/02/1000-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-02T14:25:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器的分组转发流程"><a href="#路由器的分组转发流程" class="headerlink" title="路由器的分组转发流程"></a>路由器的分组转发流程</h1><ol><li><p>从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络；</p></li><li><p>判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 2.；</p></li><li><p>检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4.；</p></li><li><p>逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5.；</p></li><li><p>若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6.；</p></li><li><p>无法找到合适路由，向源主机报错。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器的分组转发流程&quot;&gt;&lt;a href=&quot;#路由器的分组转发流程&quot; class=&quot;headerlink&quot; title=&quot;路由器的分组转发流程&quot;&gt;&lt;/a&gt;路由器的分组转发流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从 IP 数据包中提取出目的主机的 IP 地址，找到其所在</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>IPV4 地址不够如何解决</title>
    <link href="http://example.com/2021/06/02/1000-IPV4%20%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/2021/06/02/1000-IPV4%20%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</id>
    <published>2021-06-02T14:23:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPV4-地址不够如何解决"><a href="#IPV4-地址不够如何解决" class="headerlink" title="IPV4 地址不够如何解决"></a>IPV4 地址不够如何解决</h1><ul><li><p><strong>DHCP：</strong> 动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</p></li><li><p><strong>CIDR：</strong> 无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效的分配 IPv4 的地址空间，但无法从根本上解决地址耗尽问题。</p></li><li><p><strong>NAT：</strong> 网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</p></li><li><p><strong>IPv6 ：</strong> 作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个 IP 地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IPV4-地址不够如何解决&quot;&gt;&lt;a href=&quot;#IPV4-地址不够如何解决&quot; class=&quot;headerlink&quot; title=&quot;IPV4 地址不够如何解决&quot;&gt;&lt;/a&gt;IPV4 地址不够如何解决&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DHCP：&lt;/st</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="IPV4" scheme="http://example.com/tags/IPV4/"/>
    
  </entry>
  
  <entry>
    <title>IP 协议的定义和作用</title>
    <link href="http://example.com/2021/06/02/1000-IP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2021/06/02/1000-IP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8/</id>
    <published>2021-06-02T14:19:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成了 TCP/IP 协议族的核心。</p><p>IP 协议主要有以下几个作用：</p><ul><li>寻址和路由：在 IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li>分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与 TCP 协议（传输控制协议）一起构成</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="IP" scheme="http://example.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>在 M1 芯片的 Mac 上使用 CocoaPods</title>
    <link href="http://example.com/2021/05/17/500-%E5%9C%A8%20M1%E8%8A%AF%E7%89%87%E7%9A%84%20Mac%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20CocoaPods/"/>
    <id>http://example.com/2021/05/17/500-%E5%9C%A8%20M1%E8%8A%AF%E7%89%87%E7%9A%84%20Mac%20%E4%B8%8A%E4%BD%BF%E7%94%A8%20CocoaPods/</id>
    <published>2021-05-17T12:36:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近换了 M1 芯片的 MacBook Pro，在配置环境完成后 <code>pod install</code> 操作发现出错了。</p><h1 id="在-M1-上使用-CocoaPods-的方法。"><a href="#在-M1-上使用-CocoaPods-的方法。" class="headerlink" title="在 M1 上使用 CocoaPods 的方法。"></a>在 M1 上使用 CocoaPods 的方法。</h1><h2 id="1-首先执行一次"><a href="#1-首先执行一次" class="headerlink" title="1. 首先执行一次"></a>1. 首先执行一次</h2><p><code>sudo arch -x86_64 gem install ffi</code></p><h2 id="2-然后再替换之前-pod-install"><a href="#2-然后再替换之前-pod-install" class="headerlink" title="2. 然后再替换之前 pod install"></a>2. 然后再替换之前 pod install</h2><p><code>arch -x86_64 pod install</code></p><h1 id="如何查找解决方案"><a href="#如何查找解决方案" class="headerlink" title="如何查找解决方案"></a>如何查找解决方案</h1><p>第一时间想到去 <a class="link"   href="https://github.com/CocoaPods/CocoaPods/issues" >CocoaPods issues<i class="fas fa-external-link-alt"></i></a> 搜索相关问题。<br>然后果然在 <a class="link"   href="https://github.com/CocoaPods/CocoaPods/issues/10220" >Got error while trying pod install<i class="fas fa-external-link-alt"></i></a> 中找到了解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;最近换了 M1 芯片的 MacBook Pro，在配置环境完成后 &lt;code&gt;pod install&lt;/code&gt; 操作发现出错了。&lt;/p&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="CocoaPods" scheme="http://example.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代理检测</title>
    <link href="http://example.com/2021/04/14/500-iOS%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2021/04/14/500-iOS%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%90%86/</id>
    <published>2021-04-14T08:05:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *proxySettings &#x3D; CFBridgingRelease(CFNetworkCopySystemProxySettings());</span><br><span class="line">    NSArray *proxies &#x3D; CFBridgingRelease(CFNetworkCopyProxiesForURL((__bridge CFURLRef)[NSURL URLWithString:@&quot;https:&#x2F;&#x2F;www.baidu.com&quot;], (__bridge CFDictionaryRef)proxySettings));</span><br><span class="line">    if (proxies.count &gt; 0) &#123;</span><br><span class="line">        NSDictionary *settings &#x3D; proxies[0];</span><br><span class="line">        NSString *type &#x3D; [settings objectForKey:(NSString *)kCFProxyTypeKey];</span><br><span class="line">        if (![type isEqualToString:(NSString *)kCFProxyTypeNone]) &#123;</span><br><span class="line">            NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 开启代理&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 未开启代理&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Runtime 相关知识</title>
    <link href="http://example.com/2021/03/08/6666-001-runtime/"/>
    <id>http://example.com/2021/03/08/6666-001-runtime/</id>
    <published>2021-03-08T14:35:00.000Z</published>
    <updated>2021-06-05T08:18:23.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"><a href="#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）" class="headerlink" title="1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"></a>1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</h1><ul><li><strong>对象(实例)</strong><br>OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object *id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。</li><li><strong>类(Class)</strong><ol><li>在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class *Class.</li><li>OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;</li><li>当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。</li></ol></li><li><strong>OC 对象、类、元类之间的关系</strong><br>对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/kj1q75.png"                      alt="OC 对象、类、元类之间的关系"                ></li></ul><h1 id="2-为什么要设计-metaclass"><a href="#2-为什么要设计-metaclass" class="headerlink" title="2.为什么要设计 metaclass?"></a>2.为什么要设计 metaclass?</h1><ul><li>类对象、元类对象能够复用消息发送流程机制；</li><li>单一职责原则<br>metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。</li></ul><h1 id="3-class-copyIvarList-amp-class-copyPropertyList-区别"><a href="#3-class-copyIvarList-amp-class-copyPropertyList-区别" class="headerlink" title="3.class_copyIvarList &amp; class_copyPropertyList 区别"></a>3.class_copyIvarList &amp; class_copyPropertyList 区别</h1><ul><li><strong>class_copyIvarList</strong><br>会返回所有的成员变量，包括属性生成的成员变量。<br>获取类对象中的所有实例变量信息，从 class_ro_t 中获取。</li><li><strong>class_copyPropertyList</strong><br>获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_ddd;</span><br><span class="line">    NSString *_ccc;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *abc1;</span><br><span class="line">@property (nonatomic, copy) NSString *abc2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyIvarList</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar * ivars &#x3D; class_copyIvarList(self.class, &amp;count);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">      const char *name &#x3D; ivar_getName(ivars[i]);</span><br><span class="line">      NSLog(@&quot;name &#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:name]);</span><br><span class="line">  &#125;</span><br><span class="line">free(ivars);</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ddd</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ccc</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc1</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyPropertyList</span><br><span class="line">unsigned int outCount &#x3D; 0;</span><br><span class="line">objc_property_t *prs &#x3D; class_copyPropertyList(self.class, &amp;outCount);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; outCount; i++) &#123;</span><br><span class="line">    const char *pname &#x3D;  property_getName(prs[i]);</span><br><span class="line">    NSLog(@&quot;pname &#x3D;&#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:pname]);</span><br><span class="line">&#125;</span><br><span class="line">free(prs);</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc1</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc2</span><br></pre></td></tr></table></figure><h1 id="4-class-rw-t-和-class-ro-t-的区别"><a href="#4-class-rw-t-和-class-ro-t-的区别" class="headerlink" title="4.class_rw_t 和 class_ro_t 的区别"></a>4.class_rw_t 和 class_ro_t 的区别</h1><ul><li><p>class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only</p></li><li><p>class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write</p></li></ul><h1 id="5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序"><a href="#5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序" class="headerlink" title="5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序"></a>5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序</h1><p>+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看<br>分类添加到了 rw = cls-&gt;data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。同名方法调用后编译的。</p><h1 id="6-initialize-amp-amp-Load"><a href="#6-initialize-amp-amp-Load" class="headerlink" title="6.initialize &amp;&amp; Load"></a>6.initialize &amp;&amp; Load</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot; load &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D;&#x3D; [self class]) &#123;</span><br><span class="line">        NSLog(@&quot; initialize &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，<strong>如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。</strong>。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。</p><p>不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。<br>调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。</p><h1 id="7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何"><a href="#7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何" class="headerlink" title="7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何"></a>7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何</h1><ul><li>category 可以给类添加方法和属性(需要借助 runtime<br><code>objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</code><br>及<code>objc_getAssociatedObject(self, &amp;redXXKey);</code>)</li><li>extension 可以给类添加成员变量和方法，但是是私有的在 .m 内(只有在.m 里才是私有的)。</li><li>不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m</li></ul><h1 id="8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么"><a href="#8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么" class="headerlink" title="8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么"></a>8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</h1><p>OC 中的方法调用，编译后的代码最终都会转成 <code>objc_msgSend(id , SEL, ...)</code> 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用<code>_objc_msgForward(id, SEL, ...)</code>进行消息转发。</p><h1 id="9-IMP、SEL、Method-的区别和使用场景"><a href="#9-IMP、SEL、Method-的区别和使用场景" class="headerlink" title="9.IMP、SEL、Method 的区别和使用场景"></a>9.IMP、SEL、Method 的区别和使用场景</h1><ul><li><p>IMP:IMP 定义为 <code>id (*IMP) (id, SEL, …)</code>。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。</p></li><li><p>SEL:是“selector”的一个类型，表示一个方法的名字</p></li><li><p>Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关</p></li></ul><h1 id="10-load、initialize-方法的区别什么？在继承关系中他们有什么区别"><a href="#10-load、initialize-方法的区别什么？在继承关系中他们有什么区别" class="headerlink" title="10.load、initialize 方法的区别什么？在继承关系中他们有什么区别"></a>10.load、initialize 方法的区别什么？在继承关系中他们有什么区别</h1><p>load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。</p><p>继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。</p><h1 id="11-说说消息转发机制的优劣"><a href="#11-说说消息转发机制的优劣" class="headerlink" title="11.说说消息转发机制的优劣"></a>11.说说消息转发机制的优劣</h1><ul><li>优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。</li><li>劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。</li></ul><h2 id="消息转发三部曲"><a href="#消息转发三部曲" class="headerlink" title="消息转发三部曲"></a>消息转发三部曲</h2><p><strong>1. 第一步动态添加一个实现方法。</strong> 如果是实例对象会调用这个实例所属的类方法<br><code>resolveInstanceMethod</code>，如果是类方法会调用<code>+ (BOOL)resolveClassMethod:(SEL)sel;</code></p><p>我们可以动态的给该对象添加该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F;v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        class_addMethod(self, sel, (IMP)aaa, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C 方法</span><br><span class="line">void aaa (id self,SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;添加了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2. 消息转发，可以将消息转发给实现了该方法的对象。</strong> 系统会调用下面的这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个实现了该方法的对象</span><br><span class="line">        return [SubViewController new];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 完整的消息转发</strong><br>先调用 <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code><br>获取一个方法签名，如果没有返回一个有效的签名则直接调用<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector;</code>抛出异常。<br>如果获取到则将签名包装成<code>NSInvocation</code><br>传给<code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code><br>进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个方法签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果返回了有效的签名将调用这个方法进行转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取方法</span><br><span class="line">    SEL selector &#x3D; [anInvocation selector];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象</span><br><span class="line">    &#x2F;&#x2F; 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃</span><br><span class="line"></span><br><span class="line">    SubViewController *subVC &#x3D; [SubViewController new];</span><br><span class="line">    if ([subVC respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:subVC];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ABC *abc &#x3D; [ABC new];</span><br><span class="line">    if ([abc respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:abc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-weak-的实现原理？SideTable-的结构是什么样的"><a href="#12-weak-的实现原理？SideTable-的结构是什么样的" class="headerlink" title="12.weak 的实现原理？SideTable 的结构是什么样的"></a>12.weak 的实现原理？SideTable 的结构是什么样的</h1><p>runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，<br>value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.<br>runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数<br>weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.</p><p>SideTable 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">     spinlock_t slock;&#x2F;&#x2F;操作SideTable时用到的自旋锁</span><br><span class="line">     RefcountMap refcnts;&#x2F;&#x2F;引用计数器的 map</span><br><span class="line">     weak_table_t weak_table;&#x2F;&#x2F;存放weak指针的哈希表</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="13-关联对象的应用？系统如何实现关联对象的"><a href="#13-关联对象的应用？系统如何实现关联对象的" class="headerlink" title="13.关联对象的应用？系统如何实现关联对象的"></a>13.关联对象的应用？系统如何实现关联对象的</h1><ul><li>应用：给 category 添加属性。</li><li>如何实现关联的？<br>首先系统中有一个全局 AssociationsManager,里面有个 AssociationsHashMap 哈希表，哈希表中的 key 是对象的内存地址，value 是 ObjectAssociationMap,也是一个哈希表。<br>ObjectAssociationMap 中的 key 是我们设置关联对象时所设置的唯一 key，value 是 ObjcAssociation,里面存放着关联对象设置的值和内存管理的策略。<br>以<code>void objc_setAssociatedObject(id object, const void * key,id value, objc_AssociationPolicy policy)</code>为例，<br>首先会通过 AssociationsManager 获取 AssociationsHashMap，然后以 object 的内存地址为 key，从 AssociationsHashMap 中取出 ObjectAssociationMap，若没有，则新创建一个 ObjectAssociationMap，<br>然后通过 key 获取旧值，以及通过 key 和 policy 生成新值 ObjcAssociation(policy, new_value)，把新值存放到 ObjectAssociationMap 中，<br>若新值不为 nil，并且内存管理策略为 retain，则会对新值进行一次 retain，若新值为 nil，则会删除旧值，若旧值不为空并且内存管理的策略是 retain，则对旧值进行一次 release.</li><li>其被释放的时候需要手动将所有的关联对象的指针置空么？<br>对这个问题我的理解是：当对象被释放时，需要手动移除该对象所设置的关联对象吗？ 不需要，因为在对象的 dealloc 中，若发现对象有关联对象时，会调用<code>_object_remove_assocations</code> 方法来移除所有的关联对象，并根据内存策略，来判断是否需要对关联对象的值进行 release</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface UIView (XX)</span><br><span class="line">@property (nonatomic, copy) NSString *redXX;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIView (XX)</span><br><span class="line">static char redXXKey;</span><br><span class="line">- (void)setRedXX:(NSString *)redXX &#123;</span><br><span class="line">    &#x2F;&#x2F; 被关联的对象、关联的key唯一、关联的对象、内存管理策略</span><br><span class="line">    objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)redXX &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;redXXKey);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性"><a href="#14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性" class="headerlink" title="14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性"></a>14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性</h1><p>在关联对象时又一个参数<code>objc_AssociationPolicy policy</code>设置内存管理策略<br>OBJC_ASSOCIATION_ASSIGN 类型的关联对象和 weak 有一定差别，而更加接近于 unsafe_unretained，<br>即当目标对象遭到摧毁时，属性值不会自动清空。<br>然后内部封装一个 weak 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil 操作。</p><h1 id="15-Autoreleasepool-的原理？所使用的的数据结构是什么"><a href="#15-Autoreleasepool-的原理？所使用的的数据结构是什么" class="headerlink" title="15.Autoreleasepool 的原理？所使用的的数据结构是什么"></a>15.Autoreleasepool 的原理？所使用的的数据结构是什么</h1><ul><li>Autoreleasepool 是由多个 AutoreleasePoolPage 以双向链表的形式连接起来的。</li><li>释放时机: 当前 RunLoop 迭代结束时候释放。</li><li>Autoreleasepool 的基本原理：在每个自动释放池创建的时候，会在当前的 AutoreleasePoolPage 中设置一个标记位，在此期间，当有对象调用 autorelsease 时，会把对象添加到 AutoreleasePoolPage 中，若当前页添加满了，会初始化一个新页，然后用双向量表链接起来，并把新初始化的这一页设置为 hotPage,当自动释放池 pop 时，从最下面依次往上 pop，调用每个对象的 release 方法，直到遇到标志位。</li><li>AutoreleasePoolPage 结构如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">     magic_t const magic;</span><br><span class="line">     id *next;&#x2F;&#x2F;下一个存放autorelease对象的地址</span><br><span class="line">     pthread_t const thread; &#x2F;&#x2F;AutoreleasePoolPage 所在的线程</span><br><span class="line">     AutoreleasePoolPage * const parent;&#x2F;&#x2F;父节点</span><br><span class="line">     AutoreleasePoolPage *child;&#x2F;&#x2F;子节点</span><br><span class="line">     uint32_t const depth;&#x2F;&#x2F;深度,也可以理解为当前page在链表中的位置</span><br><span class="line">     uint32_t hiwat;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化"><a href="#16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化" class="headerlink" title="16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化"></a>16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化</h1><ul><li>Automatic Reference Counting，自动引用计数，即 ARC,ARC 会自动帮你插入 retain 和 release 语句,<br>ARC 编译器有两部分，分别是前端编译器和优化器</li><li>前端编译器:前端编译器会为“拥有的”每一个对象插入相应的 release 语句。如果对象的所有权修饰符是<code>__strong</code>，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入 release 语句以销毁它。而类拥有的对象（实例变量/属性）会在 dealloc 方法内被释放。事实上，你并不需要写 dealloc 方法或调用父类的 dealloc 方法，ARC 会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的 release 语句的性能还要好，因为编辑器可以作出一些假设。在 ARC 中，没有类可以覆盖 release 方法，也没有调用它的必要。ARC 会通过直接使用 objc_release 来优化调用过程。而对于 retain 也是同样的方法。ARC 会调用 objc_retain 来取代保留消息</li><li>ARC 优化器: 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对 retain 和 release 的重复调用。ARC 优化器负责移除多余的 retain 和 release 语句，确保生成的代码运行速度高于手动引用计数的代码</li></ul><h1 id="17-ARC-下哪些情况会造成内存泄漏"><a href="#17-ARC-下哪些情况会造成内存泄漏" class="headerlink" title="17.ARC 下哪些情况会造成内存泄漏"></a>17.ARC 下哪些情况会造成内存泄漏</h1><ul><li>循环引用</li><li>注册通知，不移除</li></ul><h1 id="18-Method-Swizzle-注意事项"><a href="#18-Method-Swizzle-注意事项" class="headerlink" title="18. Method Swizzle 注意事项"></a>18. Method Swizzle 注意事项</h1><p>如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议先添加：class_addMethod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AFNetworking 源码涉及代码</span><br><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod &#x3D; class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod &#x3D; class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="19-iOS-中内省的几个方法有哪些？内部实现原理是什么"><a href="#19-iOS-中内省的几个方法有哪些？内部实现原理是什么" class="headerlink" title="19. iOS 中内省的几个方法有哪些？内部实现原理是什么"></a>19. iOS 中内省的几个方法有哪些？内部实现原理是什么</h1><p>对象在运行时获取其类型的能力称为内省</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例</span><br><span class="line">-(BOOL) isMemberOfClass:      判断是否是这个类的实例</span><br><span class="line">-(BOOL) respondsToSelector:            判读实例是否实现了该方法</span><br><span class="line">+(BOOL) instancesRespondToSelector:    判断类的实例是否实现了这个方法</span><br></pre></td></tr></table></figure><h1 id="20-属性修饰符-atomic-的内部实现是怎么样的-能保证线程安全吗"><a href="#20-属性修饰符-atomic-的内部实现是怎么样的-能保证线程安全吗" class="headerlink" title="20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗"></a>20. 属性修饰符 atomic 的内部实现是怎么样的?能保证线程安全吗</h1><ul><li><p>实现机制：atomic 是 property 的修饰词之一，表示是原子性的，使用方式为@property(atomic)int age;,此时编译器会自动生成 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法来进行存取属性。若此时属性用 atomic 修饰的话，在这两个方法内部使用 os_unfair_lock 来进行加锁，来保证读写的原子性。锁都在 PropertyLocks 中保存着（在 iOS 平台会初始化 8 个，mac 平台 64 个），在用之前，会把锁都初始化好，在需要用到时，用对象的地址加上成员变量的偏移量为 key，去 PropertyLocks 中去取。因此存取时用的是同一个锁，所以 atomic 能保证属性的存取时是线程安全的。注：由于锁是有限的，不用对象，不同属性的读取用的也可能是同一个锁</p></li><li><p>不能保证：atomic 在 getter/setter 方法中加锁，仅保证了存取时的线程安全，假设我们的属性是 @property(atomic)NSMutableArray *array;可变的容器时,无法保证对容器的修改是线程安全的</p></li><li><p>在编译器自动生产的 getter/setter 方法，最终会调用 objc_getProperty 和 objc_setProperty 方法存取属性，在此方法内部保证了读写时的线程安全的，当我们重写 getter/setter 方法时，就只能依靠自己在 getter/setter 中保证线程安全</p></li><li><p>os_unfair_lock(互斥锁) 锁，iOS 10 之前使用 OSSpinLock(自旋锁)不能完全保证。</p></li><li><p>OSSpinLock 忙等 是会一直循环等待，循环等待的时候会消耗 cpu 的性能</p></li><li><p>os_unfair_lock 线程休眠，cpu 线程调度的时候会消耗 cpu 性能</p></li></ul><h1 id="21-class、objc-getClass、object-getclass-方法有什么区别"><a href="#21-class、objc-getClass、object-getclass-方法有什么区别" class="headerlink" title="21. class、objc_getClass、object_getclass 方法有什么区别?"></a>21. class、objc_getClass、object_getclass 方法有什么区别?</h1><ul><li>object_getClass:获得的是 isa 的指向</li><li>self.class:当 self 是实例对象的时候，返回的是类对象，否则则返回自身。</li><li>类方法 class，返回的是 self，所以当查找 meta class 时，需要对类对象调用 object_getClass 方法</li></ul><h1 id="22-NSNotification"><a href="#22-NSNotification" class="headerlink" title="22.NSNotification"></a>22.NSNotification</h1><h2 id="1-通知的发送时同步的，还是异步的"><a href="#1-通知的发送时同步的，还是异步的" class="headerlink" title="1. 通知的发送时同步的，还是异步的"></a>1. 通知的发送时同步的，还是异步的</h2><p>同步发送，所有接受者处理完后，才会走发送后下边的代码。</p><h2 id="2-NSNotificationCenter-接受消息和发送消息是在一个线程里吗？如何异步发送消息"><a href="#2-NSNotificationCenter-接受消息和发送消息是在一个线程里吗？如何异步发送消息" class="headerlink" title="2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息"></a>2. NSNotificationCenter 接受消息和发送消息是在一个线程里吗？如何异步发送消息</h2><p>NSNotificationQueue</p><h2 id="3-NSNotificationQueue-是异步还是同步发送？在哪个线程响应"><a href="#3-NSNotificationQueue-是异步还是同步发送？在哪个线程响应" class="headerlink" title="3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应"></a>3.NSNotificationQueue 是异步还是同步发送？在哪个线程响应</h2><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用 NSNotificationCenter 的发送接口进行发送通知，这么看 NSNotificationQueue 最终还是调用 NSNotificationCenter 进行消息的分发。</p><ul><li>依赖 runloop，所以如果在其他子线程使用 NSNotificationQueue，需要开启 runloop</li><li>最终还是通过 NSNotificationCenter 进行发送通知，所以这个角度讲它还是同步的</li><li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程</li></ul><h2 id="4-如何保证通知接收的线程在主线程"><a href="#4-如何保证通知接收的线程在主线程" class="headerlink" title="4.如何保证通知接收的线程在主线程"></a>4.如何保证通知接收的线程在主线程</h2><p>使用 addObserverForName: object: queue: usingBlock 方法注册通知，指定在 mainqueue 上响应 block</p><h2 id="5-下面的方式能接收到通知吗？为什么"><a href="#5-下面的方式能接收到通知吗？为什么" class="headerlink" title="5.下面的方式能接收到通知吗？为什么"></a>5.下面的方式能接收到通知吗？为什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">&#x2F;&#x2F; 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure><p>不会<br>存储是以 name 和 object 为维度的，即判定是不是同一个通知要从 name 和 object 区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的</p><h1 id="23-runloop"><a href="#23-runloop" class="headerlink" title="23.runloop"></a>23.runloop</h1><h2 id="1-app-如何接收到触摸事件的"><a href="#1-app-如何接收到触摸事件的" class="headerlink" title="1.app 如何接收到触摸事件的"></a>1.app 如何接收到触摸事件的</h2><h3 id="1-系统响应阶段-SpringBoad-app-是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。"><a href="#1-系统响应阶段-SpringBoad-app-是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。" class="headerlink" title="1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)"></a>1.系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)</h3><ul><li>指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。</li><li>IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoad 进程。</li><li>SpringBoard 进程因接收到触摸事件，将触摸事件交给前台 app 进程来处理。</li></ul><h3 id="2-APP-响应阶段"><a href="#2-APP-响应阶段" class="headerlink" title="2.APP 响应阶段"></a>2.APP 响应阶段</h3><ul><li>APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。</li><li>source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。</li><li>source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 hit-testing，另外，此处开始便是与我们平时开发相关的工作了。</li><li>寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。</li><li>触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</li></ul><h2 id="2-事件响应者链"><a href="#2-事件响应者链" class="headerlink" title="2.事件响应者链"></a>2.事件响应者链</h2><p>这个传递的过程叫做 hit-Testing</p><ul><li>事件是自上而下传递的即<br>UIApplication -&gt; UIWindow -&gt; 子试图 -&gt; ..-&gt;子试图中的子试图</li><li>后加试图响应程度更高，即最靠近我们的试图。</li></ul><ol><li>首先调用当前视图的 pointInside:withEvent:方法判断触摸点是否在当前视图内</li><li>若 pointInside:withEvent:方法返回 NO，说明触摸点不在当前视图内，则当前视图的 hitTest:withEvent:返回 nil</li><li>若 pointInside:withEvent:方法返回 YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的 hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从 top 到 bottom，即从 subviews 数组的末尾向前遍历，直到有子视图的 hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕。</li><li>若第一次有子视图的 hitTest:withEvent:方法返回非空对象,则当前视图的 hitTest:withEvent:方法就返回此对象，处理结束</li><li>若所有子视图的 hitTest:withEvent:方法都返回 nil，则当前视图的 hitTest:withEvent:方法返回当前视图自身(self)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断点击的位置是不是在视图内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line">&#x2F;&#x2F;返回点击的视图</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (UIView _)hitTest:(CGPoint)point withEvent:(UIEvent _)event&#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 前置条件要满足</span><br><span class="line">   if (self.userInteractionEnabled &#x3D;&#x3D; NO ||</span><br><span class="line">  self.hidden &#x3D;&#x3D; YES ||</span><br><span class="line">   self.alpha &lt;&#x3D; 0.01) return nil;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2. 判断点是否在视图内部 这是最起码的 note point 是在当前视图坐标系的点位置</span><br><span class="line">  if ([self pointInside:point withEvent:event] &#x3D;&#x3D; NO) return nil;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3. 现在起码能确定当前视图能够是响应者 接下去询问子视图</span><br><span class="line">  int count &#x3D; (int)self.subviews.count;</span><br><span class="line">  for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">  &#123;</span><br><span class="line">  &#x2F;&#x2F; 子视图</span><br><span class="line">  UIView *childView &#x3D; self.subviews[i];</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 点需要先转换坐标系</span><br><span class="line">   CGPoint childP &#x3D; [self convertPoint:point toView:childView];</span><br><span class="line">   &#x2F;&#x2F; 子视图开始询问</span><br><span class="line">  UIView *fitView &#x3D; [childView hitTest:childP withEvent:event];</span><br><span class="line">  if (fitView)</span><br><span class="line">  &#123;</span><br><span class="line">  return fitView;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   return self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-为什么只有主线程的-runloop-是开启的"><a href="#3-为什么只有主线程的-runloop-是开启的" class="headerlink" title="3.为什么只有主线程的 runloop 是开启的"></a>3.为什么只有主线程的 runloop 是开启的</h2><ul><li>主线程需要维持一份 RunLoop，保持 App 在 Main 后不会直接退出。</li><li>其他线程默认并没有调用 NSRunLoop *runloop = [NSRunLoop currentRunLoop]</li></ul><h2 id="4-runloop-的-mode-作用是什么？"><a href="#4-runloop-的-mode-作用是什么？" class="headerlink" title="4.runloop 的 mode 作用是什么？"></a>4.runloop 的 mode 作用是什么？</h2><p>mode 主要是用来指定事件在运行循环中的优先级分为:</p><ul><li>NSDefaultRunLoopMode：默认，空闲状态</li><li>UITrackingRunLoopMode: ScrollView 滑动</li><li>UIInitializationRunloopMode: 启动时</li><li>NSRunloopCommonModes：Mode 集合</li></ul><p>苹果公开的有 2 个：<br>NSDefaultRunLoopMode<br>NSRunLoopCommonModes</p><p>定时在 scrollview 滑动时通过添加到 NSRunLoopCommonModes<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p><h2 id="5-为什么只在主线程刷新-UI"><a href="#5-为什么只在主线程刷新-UI" class="headerlink" title="5.为什么只在主线程刷新 UI"></a>5.为什么只在主线程刷新 UI</h2><ul><li>UIKit 并不是一个 线程安全 的类，UI 操作涉及到渲染访问各种 View 对象的属性</li><li>如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度</li><li>另一方面因为整个程序的起点 UIApplication 是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以 view 只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以 60 帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</li></ul><h2 id="6-PerformSelector-和-runloop-的关系"><a href="#6-PerformSelector-和-runloop-的关系" class="headerlink" title="6.PerformSelector 和 runloop 的关系"></a>6.PerformSelector 和 runloop 的关系</h2><ul><li><p>perform 有几种方式，如 [self performSelector:@selector(perform) withObject:nil] 同步执行的，等同于 objc_msgSend 方法执行调用方法。</p></li><li><p><code>[self performSelector:@selector(perform) withObject:nil afterDelay:0]</code> 则是会在当前 runloop 中起一个 timer，如果当前线程没有起 runloop(也就是上面说的没有调用 <code>[NSRunLoop currentRunLoop]</code> 方法的话)，则不会有输出</p></li></ul><h2 id="7-如何使线程保活"><a href="#7-如何使线程保活" class="headerlink" title="7.如何使线程保活"></a>7.如何使线程保活</h2><p>线程保活就是不让线程退出，所以往简单说就是搞个 “while(1)” 自己实现一套处理流程，事件派发就可以了。<br>runloop 线程保活前提就是有事情要处理，这里指 timer，source0，source1 事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Timer</span><br><span class="line">NSTimer *timer &#x3D; [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">   NSLog(@&quot;timer 定时任务&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">[runloop addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runloop run];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Port</span><br><span class="line">NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">[runLoop run];</span><br></pre></td></tr></table></figure><h2 id="8-runloop-和线程有什么关系？"><a href="#8-runloop-和线程有什么关系？" class="headerlink" title="8.runloop 和线程有什么关系？"></a>8.runloop 和线程有什么关系？</h2><p>runloop 为线程而生，没有线程他就没有存在的必要。<br>runloop 是线程的基础架构部分，runloop 和线程是一一对应关系<br>主线程的 runloop 是默认启动的，其他线程的 runloop 是没有启动的，<br>如果你需要更多的线程交互则可以手动配置和启动。</p><h1 id="24-KVO、KVC"><a href="#24-KVO、KVC" class="headerlink" title="24.KVO、KVC"></a>24.KVO、KVC</h1><h2 id="1-KVO-实现原理"><a href="#1-KVO-实现原理" class="headerlink" title="1.KVO 实现原理"></a>1.KVO 实现原理</h2><p>当你观察一个对象时，系统会动态的创建一个以 <code>NSKVONotifying_</code> 为前缀的类。<br>然后将被观察对象的 isa 指针指向这个新创建的类。<br>这个类继承自该对象的原本类，并重写了被观察属性的 setter 方法。<br>同时也会重写 class 方法，返回原先类对象，这样外部就无感知了。</p><p>重写所有要观察属性的 setter 方法，统一会走一个方法，<br>内部实现是 willChangeValueForKey 和 didChangevlueForKey 方法，<br>然后就是 observeValueForKey:ofObject:change:context:<br>通知所有观察对象值的更改。</p><h2 id="2-如何手动关闭-KVO"><a href="#2-如何手动关闭-KVO" class="headerlink" title="2.如何手动关闭 KVO"></a>2.如何手动关闭 KVO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;closeType&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setProperty:(NSString *)Property&#123;</span><br><span class="line"></span><br><span class="line">    if (_Property!&#x3D;Property) &#123;</span><br><span class="line"></span><br><span class="line">        [self willChangeValueForKey:@&quot;Property&quot;];</span><br><span class="line">        _Property&#x3D;Property;</span><br><span class="line">        [self didChangeValueForKey:@&quot;Property&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通过-KVC-修改属性会触发-KVO-么"><a href="#3-通过-KVC-修改属性会触发-KVO-么" class="headerlink" title="3.通过 KVC 修改属性会触发 KVO 么"></a>3.通过 KVC 修改属性会触发 KVO 么</h2><p>会触发 KVO 操作，KVC 时候会先查询对应的 getter 和 setter 方法。</p><h2 id="4-KVC"><a href="#4-KVC" class="headerlink" title="4.KVC"></a>4.KVC</h2><p>KVC（key-value-codeing）键值编码 是通过一种字符串间接访问对象的方式（即给属性赋值）</p><ul><li><p>KVC 调用 getter 流程：getKEY，KEY，isKEY, _KEY，接着是实例变量 _KEY,_isKEY, KEY, isKEY;</p></li><li><p>KVC 调用 setter 流程：setKEY 和 _setKEY，实例变量顺序 _KEY,_isKEY, KEY, isKEY，没找到就调用 setValue: forUndefinedKey: 当一个对象调用 setValue 方法时，方法内部会做以下操作</p></li></ul><ol><li>检查是否存在相应的 key 的 set 方法，存在就调用 set 方法</li><li>如果 set 方法不存在就找带下划线的成员变量，如果有就直接给成员变量属性赋值。</li><li>如果没有找到_key 就会找相同属性名的 key，有就直接赋值</li><li>如果还没找到，就调用 valueForUndefinedKey:和 setValue:forUndefinedKey:方法。这些方法就抛出异常崩溃了。</li></ol><h2 id="5-哪些情况下使用-kvo-会崩溃，怎么防护崩溃"><a href="#5-哪些情况下使用-kvo-会崩溃，怎么防护崩溃" class="headerlink" title="5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃"></a>5.哪些情况下使用 kvo 会崩溃，怎么防护崩溃</h2><ol><li>添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context:方法，导致崩溃；</li><li>添加或者移除时 keypath == nil，导致崩溃；</li><li>多次重复移除同一个属性，移除了未注册的观察者</li></ol><h2 id="6-KVO-KVC-的优缺点？"><a href="#6-KVO-KVC-的优缺点？" class="headerlink" title="6.KVO/KVC 的优缺点？"></a>6.KVO/KVC 的优缺点？</h2><ul><li>KVC<br>优点：没有 property 的变量（私有）也能通过 KVC 进行设置，或者简化代码（多级属性）<br>缺点：如果 key 只写错，编写的时候不会报错，但是运行的时候会报错</li><li>KVO 优点：<br>能够提供一种简单的方法实现两个对象的同步；<br>能够对内部对象的状态改变作出响应，而且不需要改变内部对象的实现；<br>能够提供被观察者属性的最新值和之前的值；<br>使用 key Path 来观察属性，因此可以观察嵌套对象；<br>完成了对观察对象的抽象，因为不需要额外的代码来允许观察者被观察。</li><li>KVO 缺点：<br>KVO 只能检测类中的属性，并且属性名都是通过 NSString 来查找，编译器不会补全（编译时不会出现警告），容易写错；<br>对属性重构，将导致观察代码不可用；<br>复杂的 “if” 语句要求对象正在观察多个值，是因为所有的观察代码通过一个方法来指向；</li></ul><h1 id="25-Block"><a href="#25-Block" class="headerlink" title="25. Block"></a>25. Block</h1><h2 id="1-block-的内部结构和作用"><a href="#1-block-的内部结构和作用" class="headerlink" title="1.block 的内部结构和作用"></a>1.block 的内部结构和作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    &#x2F;&#x2F; imported variables</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的结构, 可以看出一个 block 实例的构成实际上有 6 个部分：</p><ol><li>isa 指针: 所有对象都有该指针，用于实现对象相关的功能。</li><li>flags: 附加标识位, 在 copy 和 dispose 等情况下可以用到。</li><li>reserved:保留变量。</li><li>invoke: 函数指针，指向 block 的实现代码, 也可以说是函数调用地址。</li><li>descriptor: 表示该 block 的附加描述信息，主要是 size，以及 copy 和 dispose 函数的指针。这两个辅助函数在拷贝及丢弃块对象时运行, 其中会执行一些操作, 比方说, 前者要保留捕获的对象,而后者则将之释放。</li><li>variables: 捕获的变量，block 能够访问它外部的局部变量，就是因为将这些变量复制到了结构体中。</li></ol><h2 id="2-block-的类型"><a href="#2-block-的类型" class="headerlink" title="2.block 的类型"></a>2.block 的类型</h2><p>block 其实是有类型的, 且一共有 3 种类型, 全局块, 栈块, 堆块:</p><ol><li><code>__NSGlobalBlock__</code>: 存储在全局/静态的 block，不会捕获任何外部变量。</li><li><code>__NSStackBlock__</code>: 存储在栈中的 block，当函数返回时会被销毁。</li><li><code>__NSMallocBlock__</code>: 存储在堆中的 block，当引用计数为 0 时会被销毁。</li></ol><ul><li>NSGlobalBlock<br><strong>这种块不会捕捉任何变量, 运行时也无须有状态来参与</strong>。全局块声明在全局内存里, 在编译期已经完全确定了。所以, 无论是 ARC 还是 MRC 下, 如下代码中的 block 都是全局静态的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NSGlobalBlock</span><br><span class="line">- (void)globalBlock &#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;GlobalBlock内部&quot;);               &#x2F;&#x2F; 全局静态区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;GlobalBlock：%@&quot;, block);           &#x2F;&#x2F; 全局静态区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NSStackBlock 或 NSMallocBlock<br>ARC 下为 NSMallocBlock(堆区), MRC 下为 NSStackBlock(栈区)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ARC下为NSMallocBlock(堆区), MRC下为NSStackBlock(栈区)</span><br><span class="line">- (void)stackBlockInMRCAndHeapBlockInARC &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block：%@&quot;, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NSMallocBlock</li></ul><p>要问 MRC 下有没有存储于堆区的 block, 当然有了。但 block 默认会分配在栈区, 需要保留的话, 也可以手动改到堆区, 这样它就是堆块了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MRC下为NSMallocBlock(堆区), ARC下为NSMallocBlock(堆区)</span><br><span class="line">- (void)heapBlock &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    void (^block)(void) &#x3D; [^&#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        NSLog(@&quot;MallocBlock内部：%p&quot;, &amp;a);</span><br><span class="line">    &#125; copy];</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;MallocBlock：%@&quot;, block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block 在 ARC 和 MRC 下都是存储于堆区的, 所以其类型是 NSMallocBlock 的。<br>为了解决栈块在其变量作用域结束之后被释放的问题，我们需要把 block copy 到堆中，延长其生命周期。<strong>在开启 ARC 时，编译器会判断其是不是全局块, 若不是全局块则需要将 block 从栈 copy 到堆中，并自动生成相应代码。所以, 上面的例子中, 本不用手动添加 copy 代码的, ARC 会帮我们来做这个事情。</strong></p><ul><li>NSStackBlock<br>创建的 block 没有被持有的时候，编译器就不会做出将其拷贝到堆区的操作，所以这种情况下，它还在栈区。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)stackBlockInARC &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 由于不需要持有block， 所以不需要编译器做多余的拷贝到堆区的操作</span><br><span class="line">    NSLog(@&quot;StackBlock：%@&quot;, ^&#123; NSLog(@&quot;%p&quot;, &amp;a); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-block-类型总结"><a href="#2-block-类型总结" class="headerlink" title="2.block 类型总结"></a>2.block 类型总结</h2><p>总结一下, 在 MRC 中, 可能有三种 block, 就是全局块, 栈块和堆块。 但是在 <strong>ARC 中, 一版情况下只有两种 block, 即全局块和堆块</strong>。由于 ARC 已经能很好地处理对象的生命周期的管理, 所以都放到堆上管理, 不再使用栈区管理了, 所以就栈块的情况就很少了。<br>而且捕获了变量的 block 默认会分配在栈区, 在 MRC 中需要保留的话, 可以手动改到堆区; <strong>在 ARC 中, block 也是在栈区的, 但编译器会并自动将其 copy 到堆中</strong>, 所以会存储在堆区。所以每一个堆块都是由栈块 copy 而来的。<br><strong>在 ARC 下, 当你所创建的 block 没有被指针所持有的时候，编译器就不会做出将其拷贝到堆区的操作。在这种情况下，block 就是一个直接的栈块。</strong></p><h2 id="3-block-捕获局部变量"><a href="#3-block-捕获局部变量" class="headerlink" title="3.block 捕获局部变量"></a>3.block 捕获局部变量</h2><p>不加 <code>__block</code>捕获的是值，加了捕获的是指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)captureVariable &#123;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    NSLog(@&quot;Block前：%p&quot;, &amp;a);             &#x2F;&#x2F; 栈区</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);       &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block后：%p&quot;, &amp;a);             &#x2F;&#x2F; 栈区</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; MRC 下</span><br><span class="line">Block前：0x7ffee3ac9a5c</span><br><span class="line">Block内部：0x7ffee3ac9a48</span><br><span class="line">Block后：0x7ffee3ac9a5c</span><br><span class="line">&#x2F;&#x2F; ARC 下:</span><br><span class="line">Block前：0x7ffee4d91a5c</span><br><span class="line">Block内部：0x6000002590d0</span><br><span class="line">Block后：0x7ffee4d91a5c</span><br></pre></td></tr></table></figure><p>上面的例子 不加<code>__block</code> 在构建 block 的时候, <strong>传入的捕获变量是变量 a 的值(即传入 a)**。 所以对于 block 捕获的变量, block 默认是将其复制到其数据结构中来实现访问的, **且 block 捕获的变量是在 block 内部进行修改是不会影响外部变量的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)capture__blockVariable &#123;</span><br><span class="line">    __block int a &#x3D; 0;</span><br><span class="line">    NSLog(@&quot;Block前：%p&quot;, &amp;a);            &#x2F;&#x2F; 栈区</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;Block内部：%p&quot;, &amp;a);      &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;Block后：%p&quot;, &amp;a);            &#x2F;&#x2F; ARC下存储于堆区, MRC下存储于栈区</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; MRC 下</span><br><span class="line">Block前：0x7ffee0110a58</span><br><span class="line">Block内部：0x7ffee0110a58</span><br><span class="line">Block后：0x7ffee0110a58</span><br><span class="line">&#x2F;&#x2F; ARC 下</span><br><span class="line">Block前：0x7ffee4d91a58</span><br><span class="line">Block内部：0x600000233578</span><br><span class="line">Block后：0x600000233578</span><br></pre></td></tr></table></figure><p><strong>上面的例子使用 <code>__block</code>修饰 在 ARC 下, block 内部和 block 后的地址是相同的都存在于堆中, 且与 block 前的地址不同。在构建 block 时, 传入捕获变量 a 的地址(即传入&amp;a)。所以对于 block 捕获的<code>__block</code> 修饰的变量，block 是复制其引用地址来实现访问的。自然就可以在 block 内部修改变量从而影响外部的变量了, 且 block 内外打印其地址都是同一个地址。</strong><br><strong>这里的 copy, 都是浅拷贝, 就是所谓的指针拷贝, 所以 a 指针指向的内存地址还是之前定义对象 a 的某块堆区区域。</strong></p><h2 id="4-block-可以用-strong-修饰吗"><a href="#4-block-可以用-strong-修饰吗" class="headerlink" title="4.block 可以用 strong 修饰吗"></a>4.block 可以用 strong 修饰吗</h2><p>ARC 是可以的 strong 和 copy 的操作都是将栈上 block 拷贝到堆上。</p><h2 id="5-block-在修改-NSMutableArray，需不需要添加-block"><a href="#5-block-在修改-NSMutableArray，需不需要添加-block" class="headerlink" title="5.block 在修改 NSMutableArray，需不需要添加__block"></a>5.block 在修改 NSMutableArray，需不需要添加__block</h2><p>不需要，本身 block 内部就捕获了 NSMutableArray 指针，除非你要修改指针指向的对象，而这里明显只是修改内存数据，这个可以类比 NSMutableString。</p><h2 id="6-怎么进行内存管理的"><a href="#6-怎么进行内存管理的" class="headerlink" title="6.怎么进行内存管理的"></a>6.怎么进行内存管理的</h2><ul><li><code>_NSConcreteGlobalBlock</code>:是设置在程序的全局数据区域（.data 区）中的 Block 对象。在全局声明实现的 block 或者 没有用到自动变量的 block 为<code>_NSConcreteGlobalBlock</code>，生命周期从创建到应用程序结束。</li><li><code>_NSConcreteStackBlock</code> 是设置在栈上的 block 对象，生命周期由系统控制的，一旦所属作用域结束，就被系统销毁了。</li></ul><h2 id="7-block-发生-copy-时机"><a href="#7-block-发生-copy-时机" class="headerlink" title="7.block 发生 copy 时机"></a>7.block 发生 copy 时机</h2><ul><li>调用 Block 的 copy 方法</li><li>将 Block 作为函数返回值时</li><li>将 Block 赋值给__strong 修饰的变量或 Block 类型成员变量时</li><li>向 Cocoa 框架含有 usingBlock 的方法或者 GCD 的 API 传递 Block 参数时</li></ul><h1 id="26-多线程"><a href="#26-多线程" class="headerlink" title="26.多线程"></a>26.多线程</h1><h2 id="1-iOS-开发中有多少类型的多线程？分别对比"><a href="#1-iOS-开发中有多少类型的多线程？分别对比" class="headerlink" title="1.iOS 开发中有多少类型的多线程？分别对比"></a>1.iOS 开发中有多少类型的多线程？分别对比</h2><p><strong>1. Pthread</strong>，较少使用。</p><p><strong>2. NSThread</strong>，每个 NSThread 对象对应一个线程，量级较轻，通常我们会起一个 runloop 保活，然后通过添加自定义 source0 源或者 perform onThread 来进行调用。</p><ul><li>优点 轻量级，使用简单，</li><li>缺点：需要自己管理线程的生命周期，保活，另外还会线程同步，加锁、睡眠和唤醒。</li></ul><p><strong>3. GCD</strong>：Grand Central Dispatch（派发） 是基于 C 语言的框架，可以充分利用多核，是苹果推荐使用的多线程技术</p><ul><li>优点：GCD 更接近底层，而 NSOperationQueue 则更高级抽象，所以 GCD 在追求性能的底层操作来说，是速度最快的，有待确认</li><li>缺点：操作之间的事务性，顺序行，依赖关系。GCD 需要自己写更多的代码来实现</li></ul><p><strong>4. NSOperation</strong> 基于 GCD 更高一层封装</p><ul><li>优点： 使用者的关注点都放在了 operation 上，而不需要线程管理。<br>支持在操作对象之间依赖关系，方便控制执行顺序。<br>支持可选的完成块，它在操作的主要任务完成后执行。<br>支持使用 KVO 通知监视操作执行状态的变化。<br>支持设定操作的优先级，从而影响它们的相对执行顺序。<br>支持取消操作，允许您在操作执行时暂停操作。</li><li>缺点：高级抽象，性能方面相较 GCD 来说不足一些;</li></ul><h2 id="2-GCD-有哪些队列，默认提供哪些队列"><a href="#2-GCD-有哪些队列，默认提供哪些队列" class="headerlink" title="2.GCD 有哪些队列，默认提供哪些队列"></a>2.GCD 有哪些队列，默认提供哪些队列</h2><ol><li><p>主队列（main queue ）【串行】<br>保证所有的任务都在主线程执行，而主线程是唯一用于 UI 更新的线程。此外还用于发送消息给视图或发送通知。</p></li><li><p>四个全局调度队列（high、default、low、background【并发】<br>Apple 的接口也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务</p></li><li><p>自定义队列</p><ul><li>多个任务以串行方式执行，但又不想在主线程中</li><li>多个任务以并行方式执行，但不希望队列中有其他系统的任务干扰。</li></ul></li></ol><h2 id="3-GCD-主线程-amp-主队列的关系"><a href="#3-GCD-主线程-amp-主队列的关系" class="headerlink" title="3.GCD 主线程 &amp; 主队列的关系"></a>3.GCD 主线程 &amp; 主队列的关系</h2><p>队列其实就是一个数据结构体，主队列由于是串行队列，所以入队列中的 task 会逐一派发到主线程中执行；但是其他队列也可能会派发到主线程执行</p><h2 id="4-如何实现同步，有多少方式就说多少"><a href="#4-如何实现同步，有多少方式就说多少" class="headerlink" title="4.如何实现同步，有多少方式就说多少"></a>4.如何实现同步，有多少方式就说多少</h2><ul><li>dispatch_sync</li><li>@synchronized</li><li>dispatch_group，</li><li>dispatch_semaphore</li><li>NSLock/NSRecursiveLock</li><li>pthread_mutex_t 互斥锁、递归锁等</li></ul><h2 id="5-有哪些类型的线程锁，分别介绍下作用和使用场景"><a href="#5-有哪些类型的线程锁，分别介绍下作用和使用场景" class="headerlink" title="5.有哪些类型的线程锁，分别介绍下作用和使用场景"></a>5.有哪些类型的线程锁，分别介绍下作用和使用场景</h2><ul><li>@synchronized 性能最差,SD 和 AFN 等框架内部有使用这个.</li><li>NSRecursiveLock 和 NSLock ：建议使用前者，避免循环调用出现死锁</li><li>OSSpinLock 自旋锁,存在的问题是:优先级反转问题,破坏了 spinlock</li><li>dispatch_semaphore 信号量 : 保持线程同步为线程加锁</li></ul><h1 id="27-通过-UIImage-imageNamed-生成的对象什么时候被释放？"><a href="#27-通过-UIImage-imageNamed-生成的对象什么时候被释放？" class="headerlink" title="27.通过[UIImage imageNamed:]生成的对象什么时候被释放？"></a>27.通过[UIImage imageNamed:]生成的对象什么时候被释放？</h1><ul><li>建议针对小图标/场景出现较多图片（此类方式加载，会缓存到内存）</li><li>@autoreleasepool 如果没有使用局部释放池，并且在主线程，则是当前主线程 Runloop 一次循环结束前释放。</li><li>imageWithContentsOfFile ： 加载适用于大图片,不常用的图片,一般无引用时候,会释放</li></ul><h2 id="imageName-amp-imageWithContentsOfFile-区别"><a href="#imageName-amp-imageWithContentsOfFile-区别" class="headerlink" title="imageName &amp; imageWithContentsOfFile 区别"></a>imageName &amp; imageWithContentsOfFile 区别</h2><ul><li>如果图片较小，并且使用频繁的图片使用 imageNamed：方法来加载。相同的图片是不会重复加载的</li><li>如果图片较大，并且使用较少，使用 imageWithContentOfFile:来加载。加载：imageWithContentsOfFile 只能加载 mainBundle 中图片。</li><li>当你不需要重用该图像，或者你需要将图像以数据方式存储到数据库，又或者你要通过网络下载一个很大的图像时，使用 imageWithContentsOfFile；</li><li>如果在程序中经常需要重用的图片，比如用于 UITableView 的图片，那么最好是选择 imageNamed 方法。这种方法可以节省出每次都从磁盘加载图片的时间；</li></ul><h1 id="28-UIView-amp-CALayer-的区别"><a href="#28-UIView-amp-CALayer-的区别" class="headerlink" title="28.UIView &amp; CALayer 的区别"></a>28.UIView &amp; CALayer 的区别</h1><ul><li>UIView 为 CALayer 提供内容，以及负责处理触摸等事件，参与响应链；</li><li>CALayer 负责显示内容 contents</li></ul><h2 id="layoutsubviews"><a href="#layoutsubviews" class="headerlink" title="layoutsubviews"></a>layoutsubviews</h2><ul><li>init 初始化不会触发 layoutSubviews。</li><li>addSubview 会触发 layoutSubviews。</li><li>改变一个 UIView 的 Frame 会触发 layoutSubviews，当然前提是 frame 的值设置前后发生了变化。</li><li>滚动一个 UIScrollView 引发 UIView 的重新布局会触发 layoutSubviews。</li><li>旋转 Screen 会触发父 UIView 上的 layoutSubviews 事件。</li><li>直接调用 setNeedsLayout 或者 layoutIfNeeded。</li><li>setNeedsLayout 标记为需要重新布局，异步调用 layoutIfNeeded 刷新布局，不立即刷新，在下一轮 runloop 结束前刷新，对于这一轮 runloop 之内的所有布局和 UI 上的更新只会刷新一次，layoutSubviews 一定会被调用。</li><li>layoutIfNeeded 如果有需要刷新的标记，立即调用 layoutSubviews 进行布局（如果没有标记，不会调用 layoutSubviews）。</li></ul><h2 id="drawrect"><a href="#drawrect" class="headerlink" title="drawrect"></a>drawrect</h2><ul><li>如果在 UIView 初始化时没有设置 frame，会导致 drawRect 不被自动调用</li><li>sizeToFit 后会调用。这时候可以先用 sizeToFit 中计算出 size，然后系统自动调用 drawRect 方法</li><li>通过设置 contentMode 为.redraw 时，那么在每次设置或更改 frame 的时候自动调用 drawRect</li><li>直接调用 setNeedsDisplay，或者 setNeedsDisplayInRect 会触发 drawRect</li></ul><h1 id="29-图片是什么时候解码的，如何优化"><a href="#29-图片是什么时候解码的，如何优化" class="headerlink" title="29. 图片是什么时候解码的，如何优化"></a>29. 图片是什么时候解码的，如何优化</h1><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</p><h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><ul><li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩</li><li>然后将生成的 UIImage 赋值给 UIImageView ；</li><li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li><li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<ul><li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li><li>将文件数据从磁盘读到内存中；</li><li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li><li>最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。</li></ul></li></ul><h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><p>解码操作是比较耗时的，并且没有 GPU 硬解码，只能通过 CPU，iOS 默认会在主线程对图像进行解码。解码过程是一个相当复杂的任务，需要消耗非常长的时间。60FPS ≈ 0.01666s per frame = 16.7ms per frame，这意味着在主线程超过 16.7ms 的任务都会引起掉帧。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage 的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。</p><ul><li><p>当加载图片的时候，iOS 通常会延迟解压图片的时间，直到加载到内存之后。因为需要在绘制之前进行解压，这就会在准备绘制图片的时候影响性能。</p></li><li><p>iOS 通常会延时解压图片，等到图片在屏幕上显示的时候解压图片。解压图片是非常耗时的操作。</p></li></ul><h1 id="30-性能优化"><a href="#30-性能优化" class="headerlink" title="30.性能优化"></a>30.性能优化</h1><h2 id="1-如何做启动优化，如何监控"><a href="#1-如何做启动优化，如何监控" class="headerlink" title="1.如何做启动优化，如何监控"></a>1.如何做启动优化，如何监控</h2><ul><li>合并或者删减一些 OC 类和函数；可以使用 AppCode 清理项目中没用到的类，属性等。</li><li>将不必须在+load 方法中做的事情延迟到+initialize 中</li><li>类和方法名不要太长：iOS 每个类和方法名都在__cstring 段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的；因还是 object-c 的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c 对象模型会把类/方法名字符串都保存下来；</li><li>在设计师可接受的范围内压缩图片的大小，启动的时候大大小小的图片加载个十来二十个是很正常的，图片小了，IO 操作量就小了，启动当然就会快了，比较靠谱的压缩算法是 TinyPNG。</li><li>减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库；如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库；</li><li>删减一些无用的静态变量，没有被调用到或者已经废弃的方法。</li></ul><h2 id="2-如何做卡顿优化，如何监控"><a href="#2-如何做卡顿优化，如何监控" class="headerlink" title="2.如何做卡顿优化，如何监控"></a>2.如何做卡顿优化，如何监控</h2><blockquote><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></blockquote><h3 id="卡顿原因"><a href="#卡顿原因" class="headerlink" title="卡顿原因"></a>卡顿原因</h3><p>标准情况下，页面滑动流畅是 60FPs ，就是每一秒有 60 帧的画面刷新，每 16.7ms(1/60 秒)有一帧数据。上图两个 VSync 之间的时间就是 16.7ms。<br>如果 CPU 和 GPU 加起来的处理时间超过了 16.7ms，就会造成掉帧甚至卡顿。当 FPs 帧数低于 30 时，人的肉眼就能感觉到画面明显的卡顿。</p><h3 id="卡顿监控"><a href="#卡顿监控" class="headerlink" title="卡顿监控"></a>卡顿监控</h3><ul><li>思路一：监控一秒钟内的帧数是否经常低于或远低于 60FPs。</li><li>思路二：监控每一帧的时长是否超时。</li></ul><p><strong>思路一实现方法：用 CADisplayLinker 来计数</strong></p><p>CADisplayLink 可以以屏幕刷新的频率调用指定 selector，iOS 系统中正常的屏幕刷新率为 60 次/秒，只要在这个方法里面统计每秒这个方法执行的次数，通过次数/时间就可以得出当前屏幕的刷新率了。</p><p><strong>思路二实现方法：通过子线程监测主线程的 RunLoop，判断两个状态 RunLoop 的状态区域之间的耗时是否达到一定阈值。</strong></p><p>开启子线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手，假定连续 6 次超时 50ms 认为卡顿(当然也包含了单次超时 300ms)</p><h3 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h3><p>图像显示的工作是由 CPU 和 GPU 协同完成的， 那么优化的方向和思路就是尽量减少他们的处理时长。</p><ul><li><p><strong>对 CPU 处理的优化:</strong><br>在子线程中进行对象的创建,调整和销毁，节省一部分 CPU 的时间<br>在子线程中预排版(布局计算,文本计算)，让主线程有更多的时间去响应用户的交互<br>对文本等异步绘制,图片编解码等内容进行 预渲染、预排版</p></li><li><p><strong>对 GPU 处理的优化</strong><br>尽量避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这样能少触发离屏渲染<br>尽可能将多张图片合成为一张进行显示，减轻视图层级</p></li></ul><h1 id="31-MVVM-和-MVC-的区别"><a href="#31-MVVM-和-MVC-的区别" class="headerlink" title="31.MVVM 和 MVC 的区别"></a>31.MVVM 和 MVC 的区别</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>M：数据模型， V：视图， C：控制器<br>controller 层拿到 model 更新 view，<br>view 事件传递到 controller 层，更新 model<br><strong>弊端</strong>：C 控制器层 代码逻辑较多</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M：数据模型，V：视图、控制器，VM：处理逻辑、网络</p><ol><li>View 引用 ViewModel，但 ViewModle 不能引用 View 视图、控制器。</li><li>ViewModel 可以引用 Model， Model 不能引用 ViewModel</li><li>viewController 尽量不涉及业务逻辑，让 viewModel 去做这些事情。</li><li>viewController 只是一个中间人，接收 view 的事件、调用 viewModel 的方法、响应 viewModel 的变化。</li></ol><p><strong>优势</strong>：</p><ul><li>低耦合：View 可以独立于 Model 变化和修改，一个 viewModel 可以绑定到不同的 View 上</li><li>可重用性：可以把一些视图逻辑放在一个 viewModel 里面，让很多 view 重用这段视图逻辑</li><li>独立开发：开发人员可以专注于业务逻辑和数据的开发 viewModel，设计人员可以专注于页面设计</li><li>可测试：通常界面是比较难于测试的，而 MVVM 模式可以针对 viewModel 来进行测试</li></ul><p><strong>弊端</strong>：</p><ul><li>对于过大的项目，数据绑定和数据转化需要花费更多的内存（成本）。主要成本在于：</li><li>数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li></ul><h1 id="32-用过设计模式介绍下"><a href="#32-用过设计模式介绍下" class="headerlink" title="32.用过设计模式介绍下"></a>32.用过设计模式介绍下</h1><p><strong>单例模式:</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><ul><li>优点： 1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2. 避免对资源的多重占用（比如写文件操作）。</li><li>缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul><p><strong>工厂模式:</strong> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><ul><li>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</li><li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li></ul><p><strong>观察者模式:</strong> 系统的 KVO</p><h1 id="33-描述一个-ViewController-的生命周期"><a href="#33-描述一个-ViewController-的生命周期" class="headerlink" title="33.描述一个 ViewController 的生命周期"></a>33.描述一个 ViewController 的生命周期</h1><ol><li>当我们调用 UIViewControlller 的 view 时，</li><li>系统首先判断当前的 UIViewControlller 是否存在 view，如果存在直接返回 view，</li><li>如果不存在的话，会调用 loadview 方法，</li><li>然后判断 loadview 方法是否是自定义方法，</li><li>如果是自定义方法，就执行自定义方法，</li><li>如果不是自定义方法，判断当时视图控制器是否有 xib、stroyboard。</li><li>如果有 xib、stroyboard 就加载 xib、stroyboard。</li><li>如果没有创建一个空白的 view。</li><li>调用 viewDidLoad 方法。</li><li>最后返回 view</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）&quot;&gt;&lt;a href=&quot;#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="iOS 知识点" scheme="http://example.com/categories/iOS-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>如何通过一个不均匀的硬币得到公平的结果？</title>
    <link href="http://example.com/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/"/>
    <id>http://example.com/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/</id>
    <published>2021-03-07T14:27:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何通过一个不均匀的硬币得到公平的结果？"><a href="#如何通过一个不均匀的硬币得到公平的结果？" class="headerlink" title="如何通过一个不均匀的硬币得到公平的结果？"></a>如何通过一个不均匀的硬币得到公平的结果？</h1><p>假设 60% 概率 正面，40% 概率反面<br>那么抛两次会有下面四种结果</p><ul><li>正 正 36%</li><li>正 反 24%</li><li>反 正 24%</li><li>反 反 16%</li></ul><p>可以看出 正反 与 反正 的概率是相等的。<br>所以抛两次当正反面不同时，都取第一次的结果为最终结果即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何通过一个不均匀的硬币得到公平的结果？&quot;&gt;&lt;a href=&quot;#如何通过一个不均匀的硬币得到公平的结果？&quot; class=&quot;headerlink&quot; title=&quot;如何通过一个不均匀的硬币得到公平的结果？&quot;&gt;&lt;/a&gt;如何通过一个不均匀的硬币得到公平的结果？&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>64匹马,8个赛道,最少比几次找出跑得最快的4匹马？</title>
    <link href="http://example.com/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/"/>
    <id>http://example.com/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/</id>
    <published>2021-03-07T14:27:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<p>11 次<br><a class="link"   href="https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2" >解析文档<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11 次&lt;br&gt;&lt;a class=&quot;link&quot;   href=&quot;https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2&quot; &gt;解析文档&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>10亿个数中找出最大的10000个数（top K问题）</title>
    <link href="http://example.com/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>http://example.com/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/</id>
    <published>2021-03-07T13:16:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-亿个数中找出最大的-10000-个数（top-K-问题）"><a href="#10-亿个数中找出最大的-10000-个数（top-K-问题）" class="headerlink" title="10 亿个数中找出最大的 10000 个数（top K 问题）"></a>10 亿个数中找出最大的 10000 个数（top K 问题）</h1><h2 id="1-对全部数据直接进行排序"><a href="#1-对全部数据直接进行排序" class="headerlink" title="1. 对全部数据直接进行排序"></a>1. 对全部数据直接进行排序</h2><ul><li>时间复杂度 O(nlogn)</li><li>空间复杂度 O(n)</li></ul><p>将 10 亿数据直接进行快排，然后如果大堆长度大于 10000，继续将大堆进行快排。 如果小于 10000 ，那么将最近一次的小堆再次进行快排。如果这个大堆长度加上之前的长度大于 10000，那么对这个大堆进行完整的快排。并取最大的 n 个数。</p><h2 id="2-局部淘汰法"><a href="#2-局部淘汰法" class="headerlink" title="2.局部淘汰法"></a>2.局部淘汰法</h2><ul><li>时间复杂度 O(n+m^2) m 为当前容器大小 10000</li><li>空间复杂度 O(m)</li></ul><p>先保存 10000 个数，然后将后续的数依次与 10000 里最小的数比较，小的直接丢弃，大的进行替换。最后这 10000 个数就是答案。</p><h2 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3.分治法"></a>3.分治法</h2><ul><li>时间复杂度 O(nlogn)</li><li>空间复杂度 O(max(a,b)) a 为每份的长度 这里为 100 万，b 为最后的 m 份的最大 k 这里为 100 份的最大 10000 即 100 万。</li></ul><p>先将 1 亿个数分成 100 份， 每份 100 万个数。然后对每一份进行快排找出最大的 10000 个数。<br>方法是：快排中如果大堆大于 10000 ，继续对大堆进行快排。如果小于 10000，那么对最近的小堆进行快排，如果大堆长度 + 之前的大堆长度满足。那么对大堆进行完全快排取最大的 n 个数。<br>这样找出了 100 份 最大的 10000 个数。继续上边的思路进行快排直到找出最大的 10000 个数。</p><h2 id="4-Hash-法"><a href="#4-Hash-法" class="headerlink" title="4.Hash 法"></a>4.Hash 法</h2><p>先将所有的数存入 hash 表中去重复，减少数据量。然后分治法。</p><blockquote><p><a class="link"   href="https://blog.csdn.net/zyq522376829/article/details/47686867" >https://blog.csdn.net/zyq522376829/article/details/47686867<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-亿个数中找出最大的-10000-个数（top-K-问题）&quot;&gt;&lt;a href=&quot;#10-亿个数中找出最大的-10000-个数（top-K-问题）&quot; class=&quot;headerlink&quot; title=&quot;10 亿个数中找出最大的 10000 个数（top K 问题</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Top K" scheme="http://example.com/tags/Top-K/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-02-28T13:12:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算 &lt;&lt;"></a>左移运算 &lt;&lt;</h1><p>a &lt;&lt; b<br><code>a*(2 的 b 次方)</code></p><p>3 &lt;&lt; 2，则是将数字 3 左移 2 位<br><code>3*(2 的 2 次方)</code></p><h2 id="计算过程："><a href="#计算过程：" class="headerlink" title="计算过程："></a>计算过程：</h2><p>3 &lt;&lt; 2 首先把 3 转换为二进制数字 0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移 2 位，最后在低位(右侧)的两个空位补零。则得到的最终结果是 0000 1100，则转换为十进制是 12。</p><h2 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义:"></a>数学意义:</h2><p>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。</p><h1 id="amp-与运算"><a href="#amp-与运算" class="headerlink" title="&amp; 与运算"></a>&amp; 与运算</h1><p>参加运算的两个数据，按二进制位进行“与”运算。<br>运算规则：0&amp;0=0;0&amp;1=0;1&amp;0=0;1&amp;1=1;<br>即：两位同时为“1”，结果才为“1”，否则为 0<br>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3&amp;5 的值得 1。</p><h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>用 2 整除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为小于 1 时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p><blockquote><p><a class="link"   href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6" >https://baike.baidu.com/item/二进制<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左移运算-lt-lt&quot;&gt;&lt;a href=&quot;#左移运算-lt-lt&quot; class=&quot;headerlink&quot; title=&quot;左移运算 &amp;lt;&amp;lt;&quot;&gt;&lt;/a&gt;左移运算 &amp;lt;&amp;lt;&lt;/h1&gt;&lt;p&gt;a &amp;lt;&amp;lt; b&lt;br&gt;&lt;code&gt;a*(2 的 b 次</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2021-02-24T15:22:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >199. 二叉树的右视图<i class="fas fa-external-link-alt"></i></a></h1><h1 id="解法一-BFS-广度优先-层序遍历"><a href="#解法一-BFS-广度优先-层序遍历" class="headerlink" title="解法一 BFS 广度优先 层序遍历"></a>解法一 BFS 广度优先 层序遍历</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [Int] &#x3D; []</span><br><span class="line">        var treeList &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            let count &#x3D; treeList.count</span><br><span class="line">            for i in 0 ..&lt; count &#123;</span><br><span class="line">                let tree &#x3D; treeList.remove(at: 0)</span><br><span class="line">                if i &#x3D;&#x3D; count - 1 &#123;</span><br><span class="line">                    ans.append(tree.val)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解法二-DFS-深度优先-前序遍历-变形"><a href="#解法二-DFS-深度优先-前序遍历-变形" class="headerlink" title="解法二 DFS 深度优先 前序遍历 变形"></a>解法二 DFS 深度优先 前序遍历 变形</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ans: [Int] &#x3D; []</span><br><span class="line">    func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        dfsSlideView(root, 0)</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfsSlideView(_ root: TreeNode?, _ depth: Int) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        if depth &#x3D;&#x3D; ans.count &#123;</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        let d &#x3D; depth + 1</span><br><span class="line">        dfsSlideView(root.right, d)</span><br><span class="line">        dfsSlideView(root.left, d)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <link href="http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <id>http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</id>
    <published>2021-02-24T15:19:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a class="link"   href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line">        var listTree: [TreeNode] &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        var isLR &#x3D; false</span><br><span class="line">        while !listTree.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempTree: [TreeNode] &#x3D; []</span><br><span class="line">            isLR &#x3D; !isLR</span><br><span class="line">            for tree in listTree &#123;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">                if isLR &#123;</span><br><span class="line">                    valList.append(tree.val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    valList.insert(tree.val, at: 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listTree &#x3D; tempTree</span><br><span class="line">            ans.append(valList)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-32-III-从上到下打印二叉树-III&quot;&gt;&lt;a href=&quot;#剑指-Offer-32-III-从上到下打印二叉树-III&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 32 - III. 从上到下打印二叉树 III&quot;&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-24T15:17:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var treeList: [TreeNode] &#x3D; [root]</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempList: [TreeNode] &#x3D; []</span><br><span class="line">            for tree in treeList &#123;</span><br><span class="line">                valList.append(tree.val)</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(valList)</span><br><span class="line">            treeList &#x3D; tempList</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102. 二叉树的层序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树 - 中等</title>
    <link href="http://example.com/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-24T10:12:00.000Z</published>
    <updated>2021-06-05T08:18:23.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/zn7zcr.png"                      alt="105. 从前序与中序遍历序列构造二叉树"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是节点的个数，每个节点都访问一次</li><li>空间复杂度<br>O(n) 除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var inorderMap: [Int: Int] &#x3D; [:]</span><br><span class="line"></span><br><span class="line">    func buildTree(_ preorder: [Int], _ inorder: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">        let count &#x3D; preorder.count</span><br><span class="line">        &#x2F;&#x2F; 这一步是为了节省时间 但是增加了空间占用</span><br><span class="line">        for (index, val) in inorder.enumerated() &#123;</span><br><span class="line">            inorderMap[val] &#x3D; index</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, count - 1, 0, count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func myBuildTree(_ preorder: [Int], _ inorder: [Int], _ preorderLeft: Int, _ preorderRight: Int, _ inorderLeft: Int, _ inorderRight: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if preorderLeft &gt; preorderRight &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 前序遍历的第一个节点就是根节点</span><br><span class="line">        let preorderRoot &#x3D; preorderLeft</span><br><span class="line">        &#x2F;&#x2F; 找出中序遍历的根节点位置</span><br><span class="line">        let inorderRoot &#x3D; inorderMap[preorder[preorderRoot]]!</span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        let root &#x3D; TreeNode(preorder[preorderRoot])</span><br><span class="line">        &#x2F;&#x2F; 左子树的节点数目</span><br><span class="line">        let leftTreeCount &#x3D; inorderRoot - inorderLeft</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderLeft + 1 开始的 leftTreeCount 个元素就是 当前 root 左子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderLeft 开始到 inorderRoot - 1]  就是当前 root 左子树的 所有节点</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorderLeft + 1, preorderLeft + leftTreeCount, inorderLeft, inorderRoot - 1)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderRoot + 1(这个1是根节点的长度) + leftTreeCount 到 preorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderRoot + 1 到 inorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorderRoot + 1 + leftTreeCount, preorderRight, inorderRoot + 1, inorderRight)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
</feed>
