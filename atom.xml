<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-12T16:36:58.676Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Runtime 相关知识</title>
    <link href="http://example.com/2021/03/08/6666-001-runtime/"/>
    <id>http://example.com/2021/03/08/6666-001-runtime/</id>
    <published>2021-03-08T14:35:00.000Z</published>
    <updated>2021-03-12T16:36:58.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"><a href="#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）" class="headerlink" title="1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）"></a>1.介绍下 runtime 的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</h1><ul><li><strong>对象(实例)</strong><br>OC 中的对象指向的是一个 objc_object 指针类型，typedef struct objc_object *id;从它的结构体中可以看出，它包括一个 isa 指针，指向的是这个对象的类对象,一个对象实例就是通过这个 isa 找到它自己的 Class，而这个 Class 中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。</li><li><strong>类(Class)</strong><ol><li>在 OC 中的类是用 Class 来表示的，实际上它指向的是一个 objc_class 的指针类型，typedef struct objc_class *Class.</li><li>OC 的 Class 类型包括如下 元数据（metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;</li><li>当然也包括一个 isa 指针，这说明 Class 也是一个对象类型，所以我们称之为类对象，这里的 isa 指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。</li></ol></li><li><strong>OC 对象、类、元类之间的关系</strong><br>对象(实例)的 isa 指针指向类对象(Class)，类对象的 isa 指针指向元类(meta Class), 元类的 isa 指针指向根元类(root meta Class). 根元类的 isa 指针指向他自己。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/kj1q75.png"                      alt="OC 对象、类、元类之间的关系"                ></li></ul><h1 id="2-为什么要设计-metaclass"><a href="#2-为什么要设计-metaclass" class="headerlink" title="2.为什么要设计 metaclass?"></a>2.为什么要设计 metaclass?</h1><ul><li>类对象、元类对象能够复用消息发送流程机制；</li><li>单一职责原则<br>metaclass 代表的是类对象的对象，它存储了类的类方法，它的目的是将实例和类的相关方法列表以及构建信息区分开来，方便各司其职，符合单一职责设计原则。</li></ul><h1 id="3-class-copyIvarList-amp-class-copyPropertyList-区别"><a href="#3-class-copyIvarList-amp-class-copyPropertyList-区别" class="headerlink" title="3.class_copyIvarList &amp; class_copyPropertyList 区别"></a>3.class_copyIvarList &amp; class_copyPropertyList 区别</h1><ul><li><strong>class_copyIvarList</strong><br>会返回所有的成员变量，包括属性生成的成员变量。<br>获取类对象中的所有实例变量信息，从 class_ro_t 中获取。</li><li><strong>class_copyPropertyList</strong><br>获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_ddd;</span><br><span class="line">    NSString *_ccc;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *abc1;</span><br><span class="line">@property (nonatomic, copy) NSString *abc2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyIvarList</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar * ivars &#x3D; class_copyIvarList(self.class, &amp;count);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">      const char *name &#x3D; ivar_getName(ivars[i]);</span><br><span class="line">      NSLog(@&quot;name &#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:name]);</span><br><span class="line">  &#125;</span><br><span class="line">free(ivars);</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ddd</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _ccc</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc1</span><br><span class="line">&#x2F;&#x2F;name &#x3D;&#x3D; _abc2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; class_copyPropertyList</span><br><span class="line">unsigned int outCount &#x3D; 0;</span><br><span class="line">objc_property_t *prs &#x3D; class_copyPropertyList(self.class, &amp;outCount);</span><br><span class="line">for (unsigned int i &#x3D; 0; i &lt; outCount; i++) &#123;</span><br><span class="line">    const char *pname &#x3D;  property_getName(prs[i]);</span><br><span class="line">    NSLog(@&quot;pname &#x3D;&#x3D;&#x3D; %@&quot;,[NSString stringWithUTF8String:pname]);</span><br><span class="line">&#125;</span><br><span class="line">free(prs);</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc1</span><br><span class="line">&#x2F;&#x2F;pname &#x3D;&#x3D;&#x3D; abc2</span><br></pre></td></tr></table></figure><h1 id="4-class-rw-t-和-class-ro-t-的区别"><a href="#4-class-rw-t-和-class-ro-t-的区别" class="headerlink" title="4.class_rw_t 和 class_ro_t 的区别"></a>4.class_rw_t 和 class_ro_t 的区别</h1><ul><li><p>class_ro_t 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议，里面是没有分类的方法的。 ro = read only</p></li><li><p>class_rw_t 运行时添加的方法将会存储在运行时生成的 class_rw_t 中。 rw = read write</p></li></ul><h1 id="5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序"><a href="#5-category-如何被加载的-两个-category-的-load-方法的加载顺序，两个-category-的同名方法的加载顺序" class="headerlink" title="5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序"></a>5.category 如何被加载的,两个 category 的 load 方法的加载顺序，两个 category 的同名方法的加载顺序</h1><p>+load 方法是 images 加载的时候调用，先调用父类的方法然后才是本类的方法。 category 的 +load 则是按照编译顺序来的，先编译的先调用，后编译的后调用，可在 Xcode 的 BuildPhase 中查看<br>分类添加到了 rw = cls-&gt;data() 中的 methods/properties/protocols 中，实际上并无覆盖，只是查找到就返回了，导致本类函数无法加载。</p><h1 id="6-initialize-amp-amp-Load"><a href="#6-initialize-amp-amp-Load" class="headerlink" title="6.initialize &amp;&amp; Load"></a>6.initialize &amp;&amp; Load</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot; load &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D;&#x3D; [self class]) &#123;</span><br><span class="line">        NSLog(@&quot; initialize &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>load 方法会先调用，initialize 方法 当前对象第一次初始化创建时才会调用，<strong>如果该对象的父类的 initialize 方法还未调用，会先调用父类的方法。父类再初始化创建时不再调用。</strong>。这两个方法在 App 生命周期内仅调用一次。 category 的 load 方法按照编译顺序，先编译先调用。category 实现 initialize 方法那么本类的不会调用，多个 category 都实现调用最后编译的(这时走的是消息发送流程)。编译顺序在 BuildPhase 中查看。</p><p>不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 [super load] ,那么会调用父类的 load 方法。<br>调用 [super initialize] 方法，那么调用父类的 initialize 方法。 实际上是走消息发送流程。</p><h1 id="7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何"><a href="#7-category-amp-extension-区别，能给-NSObject-添加-Extension-吗，结果如何" class="headerlink" title="7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何"></a>7.category &amp; extension 区别，能给 NSObject 添加 Extension 吗，结果如何</h1><ul><li>category 可以给类添加方法和属性(需要借助 runtime<br><code>objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</code><br>及<code>objc_getAssociatedObject(self, &amp;redXXKey);</code>)</li><li>extension 可以给类添加成员变量和方法，但是是私有的在 .m 内。</li><li>不能给 NSObject 及系统类 添加 Extension，必须有源码才行 .m</li></ul><h1 id="8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么"><a href="#8-在方法调用的时候，方法查询-gt-动态解析-gt-消息转发-之前做了什么" class="headerlink" title="8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么"></a>8.在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</h1><p>OC 中的方法调用，编译后的代码最终都会转成 <code>objc_msgSend(id , SEL, ...)</code> 方法进行调用。这个方法第一个参数是一个消息接收者对象，runtime 通过这个对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找(哈希查找，bucket 桶实现)是否存在 SEL 对应的 IMP，如果不存在，则会在 method_list 中查找（二分查找或者顺序查找），如果还是没找到，则会到 supper_class 中查找，仍然没找到的话，就会调用<code>_objc_msgForward(id, SEL, ...)</code>进行消息转发。</p><h1 id="9-IMP、SEL、Method-的区别和使用场景"><a href="#9-IMP、SEL、Method-的区别和使用场景" class="headerlink" title="9.IMP、SEL、Method 的区别和使用场景"></a>9.IMP、SEL、Method 的区别和使用场景</h1><ul><li><p>IMP:IMP 定义为 <code>id (*IMP) (id, SEL, …)</code>。这样说来,IMP 是一个指向函数的指针，这个被指向的函数包括 id(“self”指针)，调用的 SEL（方法名），再加上一些其他参数.说白了 IMP 就是实现方法。</p></li><li><p>SEL:是“selector”的一个类型，表示一个方法的名字</p></li><li><p>Method:（我们常说的方法）表示一种类型，这种类型与 selector 和实现(implementation)相关</p></li></ul><h1 id="10-load、initialize-方法的区别什么？在继承关系中他们有什么区别"><a href="#10-load、initialize-方法的区别什么？在继承关系中他们有什么区别" class="headerlink" title="10.load、initialize 方法的区别什么？在继承关系中他们有什么区别"></a>10.load、initialize 方法的区别什么？在继承关系中他们有什么区别</h1><p>load 会在程序启动后自动调用，initialize 会在当前对象初始化创建时调用。在 App 生命周期内都是仅调用一次。</p><p>继承中会先执行父类的 load 方法然后才是本类的，继承中如果本类的父类还未执行过 initialize 方法，父类会先调用 initialize 方法，然后才是本类。如果本类未实现 initialize 方法，会继承父类的并调用执行一次。</p><h1 id="11-说说消息转发机制的优劣"><a href="#11-说说消息转发机制的优劣" class="headerlink" title="11.说说消息转发机制的优劣"></a>11.说说消息转发机制的优劣</h1><ul><li>优势：动态特性，可以动态的为对象添加方法，也可以将消息转发给其他对象去处理间接实现多继承。</li><li>劣势：当一个方法只声明没实现时，编译不会出错，运行时会崩溃。</li></ul><h2 id="消息转发三部曲"><a href="#消息转发三部曲" class="headerlink" title="消息转发三部曲"></a>消息转发三部曲</h2><p><strong>1. 第一步动态添加一个实现方法。</strong> 如果是实例对象会调用这个实例所属的类方法<br><code>resolveInstanceMethod</code>，如果是类方法会调用<code>+ (BOOL)resolveClassMethod:(SEL)sel;</code></p><p>我们可以动态的给该对象添加该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F;v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        class_addMethod(self, sel, (IMP)aaa, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; C 方法</span><br><span class="line">void aaa (id self,SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;添加了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2. 消息转发，可以将消息转发给实现了该方法的对象。</strong> 系统会调用下面的这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个实现了该方法的对象</span><br><span class="line">        return [SubViewController new];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 完整的消息转发</strong><br>先调用 <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code><br>获取一个方法签名，如果没有返回一个有效的签名则直接调用<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector;</code>抛出异常。<br>如果获取到则将签名包装成<code>NSInvocation</code><br>传给<code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code><br>进行消息转发(也可以在这个方法里不进行处理，直接丢弃。但是该方法必须实现)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个方法签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果返回了有效的签名将调用这个方法进行转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取方法</span><br><span class="line">    SEL selector &#x3D; [anInvocation selector];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这一步可以将方法转发给多个对象，第二步的只能转发给一个对象</span><br><span class="line">    &#x2F;&#x2F; 也可以不处理，但是该方法必须实现，否则还是会 unrecognized selector 崩溃</span><br><span class="line"></span><br><span class="line">    SubViewController *subVC &#x3D; [SubViewController new];</span><br><span class="line">    if ([subVC respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:subVC];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ABC *abc &#x3D; [ABC new];</span><br><span class="line">    if ([abc respondsToSelector:selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:abc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-weak-的实现原理？SideTable-的结构是什么样的"><a href="#12-weak-的实现原理？SideTable-的结构是什么样的" class="headerlink" title="12.weak 的实现原理？SideTable 的结构是什么样的"></a>12.weak 的实现原理？SideTable 的结构是什么样的</h1><p>runtime 维护着一个 weak 表，这个表是 hash 表。以 weak 指向对象的内存地址为 key，<br>value 是存放着所有的 weak 指针地址的数组。当对象的引用计数为 0 被回收的时候，会在这个 hash 表中以对象的内存地址为 key 找到所有的 weak 指针置为 nil.<br>runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数<br>weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销.</p><p>SideTable 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">     spinlock_t slock;&#x2F;&#x2F;操作SideTable时用到的自旋锁</span><br><span class="line">     RefcountMap refcnts;&#x2F;&#x2F;引用计数器的 map</span><br><span class="line">     weak_table_t weak_table;&#x2F;&#x2F;存放weak指针的哈希表</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="13-关联对象的应用？系统如何实现关联对象的"><a href="#13-关联对象的应用？系统如何实现关联对象的" class="headerlink" title="13.关联对象的应用？系统如何实现关联对象的"></a>13.关联对象的应用？系统如何实现关联对象的</h1><ul><li>应用：给 category 添加属性。</li><li>如何实现关联的？<br>首先系统中有一个全局 AssociationsManager,里面有个 AssociationsHashMap 哈希表，哈希表中的 key 是对象的内存地址，value 是 ObjectAssociationMap,也是一个哈希表。<br>ObjectAssociationMap 中的 key 是我们设置关联对象时所设置的唯一 key，value 是 ObjcAssociation,里面存放着关联对象设置的值和内存管理的策略。<br>以<code>void objc_setAssociatedObject(id object, const void * key,id value, objc_AssociationPolicy policy)</code>为例，<br>首先会通过 AssociationsManager 获取 AssociationsHashMap，然后以 object 的内存地址为 key，从 AssociationsHashMap 中取出 ObjectAssociationMap，若没有，则新创建一个 ObjectAssociationMap，<br>然后通过 key 获取旧值，以及通过 key 和 policy 生成新值 ObjcAssociation(policy, new_value)，把新值存放到 ObjectAssociationMap 中，<br>若新值不为 nil，并且内存管理策略为 retain，则会对新值进行一次 retain，若新值为 nil，则会删除旧值，若旧值不为空并且内存管理的策略是 retain，则对旧值进行一次 release.</li><li>其被释放的时候需要手动将所有的关联对象的指针置空么？<br>对这个问题我的理解是：当对象被释放时，需要手动移除该对象所设置的关联对象吗？ 不需要，因为在对象的 dealloc 中，若发现对象有关联对象时，会调用<code>_object_remove_assocations</code> 方法来移除所有的关联对象，并根据内存策略，来判断是否需要对关联对象的值进行 release</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface UIView (XX)</span><br><span class="line">@property (nonatomic, copy) NSString *redXX;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIView (XX)</span><br><span class="line">static char redXXKey;</span><br><span class="line">- (void)setRedXX:(NSString *)redXX &#123;</span><br><span class="line">    &#x2F;&#x2F; 被关联的对象、关联的key唯一、关联的对象、内存管理策略</span><br><span class="line">    objc_setAssociatedObject(self, &amp;redXXKey, redXX, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)redXX &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;redXXKey);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性"><a href="#14-关联对象的如何进行内存管理的？关联对象如何实现-weak-属性" class="headerlink" title="14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性"></a>14.关联对象的如何进行内存管理的？关联对象如何实现 weak 属性</h1><p>在关联对象时又一个参数<code>objc_AssociationPolicy policy</code>设置内存管理策略<br>OBJC_ASSOCIATION_ASSIGN 类型的关联对象和 weak 有一定差别，而更加接近于 unsafe_unretained，<br>即当目标对象遭到摧毁时，属性值不会自动清空。<br>然后内部封装一个 weak 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil 操作。</p><h1 id="15-Autoreleasepool-的原理？所使用的的数据结构是什么"><a href="#15-Autoreleasepool-的原理？所使用的的数据结构是什么" class="headerlink" title="15.Autoreleasepool 的原理？所使用的的数据结构是什么"></a>15.Autoreleasepool 的原理？所使用的的数据结构是什么</h1><ul><li>Autoreleasepool 是由多个 AutoreleasePoolPage 以双向链表的形式连接起来的。</li><li>释放时机: 当前 RunLoop 迭代结束时候释放。</li><li>Autoreleasepool 的基本原理：在每个自动释放池创建的时候，会在当前的 AutoreleasePoolPage 中设置一个标记位，在此期间，当有对象调用 autorelsease 时，会把对象添加到 AutoreleasePoolPage 中，若当前页添加满了，会初始化一个新页，然后用双向量表链接起来，并把新初始化的这一页设置为 hotPage,当自动释放池 pop 时，从最下面依次往上 pop，调用每个对象的 release 方法，直到遇到标志位。</li><li>AutoreleasePoolPage 结构如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">     magic_t const magic;</span><br><span class="line">     id *next;&#x2F;&#x2F;下一个存放autorelease对象的地址</span><br><span class="line">     pthread_t const thread; &#x2F;&#x2F;AutoreleasePoolPage 所在的线程</span><br><span class="line">     AutoreleasePoolPage * const parent;&#x2F;&#x2F;父节点</span><br><span class="line">     AutoreleasePoolPage *child;&#x2F;&#x2F;子节点</span><br><span class="line">     uint32_t const depth;&#x2F;&#x2F;深度,也可以理解为当前page在链表中的位置</span><br><span class="line">     uint32_t hiwat;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化"><a href="#16-ARC-的实现原理？ARC-下对-retain-amp-release-做了哪些优化" class="headerlink" title="16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化"></a>16.ARC 的实现原理？ARC 下对 retain &amp; release 做了哪些优化</h1><ul><li>Automatic Reference Counting，自动引用计数，即 ARC,ARC 会自动帮你插入 retain 和 release 语句,<br>ARC 编译器有两部分，分别是前端编译器和优化器</li><li>前端编译器:前端编译器会为“拥有的”每一个对象插入相应的 release 语句。如果对象的所有权修饰符是<code>__strong</code>，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入 release 语句以销毁它。而类拥有的对象（实例变量/属性）会在 dealloc 方法内被释放。事实上，你并不需要写 dealloc 方法或调用父类的 dealloc 方法，ARC 会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的 release 语句的性能还要好，因为编辑器可以作出一些假设。在 ARC 中，没有类可以覆盖 release 方法，也没有调用它的必要。ARC 会通过直接使用 objc_release 来优化调用过程。而对于 retain 也是同样的方法。ARC 会调用 objc_retain 来取代保留消息</li><li>ARC 优化器: 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对 retain 和 release 的重复调用。ARC 优化器负责移除多余的 retain 和 release 语句，确保生成的代码运行速度高于手动引用计数的代码</li></ul><h1 id="17-ARC-下哪些情况会造成内存泄漏"><a href="#17-ARC-下哪些情况会造成内存泄漏" class="headerlink" title="17.ARC 下哪些情况会造成内存泄漏"></a>17.ARC 下哪些情况会造成内存泄漏</h1><ul><li>循环引用</li><li>注册通知，不移除</li></ul><h1 id="18-Method-Swizzle-注意事项"><a href="#18-Method-Swizzle-注意事项" class="headerlink" title="18. Method Swizzle 注意事项"></a>18. Method Swizzle 注意事项</h1><p>如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议先添加：class_addMethod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AFNetworking 源码涉及代码</span><br><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod &#x3D; class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod &#x3D; class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="19-iOS-中内省的几个方法有哪些？内部实现原理是什么"><a href="#19-iOS-中内省的几个方法有哪些？内部实现原理是什么" class="headerlink" title="19. iOS 中内省的几个方法有哪些？内部实现原理是什么"></a>19. iOS 中内省的几个方法有哪些？内部实现原理是什么</h1><p>对象在运行时获取其类型的能力称为内省</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例</span><br><span class="line">-(BOOL) isMemberOfClass:      判断是否是这个类的实例</span><br><span class="line">-(BOOL) respondsToSelector:                      判读实例是否有这样方法</span><br><span class="line">+(BOOL) instancesRespondToSelector:      判断类是否有这个方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）&quot;&gt;&lt;a href=&quot;#1-介绍下-runtime-的内存模型（isa、对象、类、metaclass、结构体的存储信息等）&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="iOS 知识点" scheme="http://example.com/categories/iOS-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>如何通过一个不均匀的硬币得到公平的结果？</title>
    <link href="http://example.com/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/"/>
    <id>http://example.com/2021/03/07/2000-023-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%A1%AC%E5%B8%81%E5%BE%97%E5%88%B0%E5%85%AC%E5%B9%B3%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F/</id>
    <published>2021-03-07T14:27:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何通过一个不均匀的硬币得到公平的结果？"><a href="#如何通过一个不均匀的硬币得到公平的结果？" class="headerlink" title="如何通过一个不均匀的硬币得到公平的结果？"></a>如何通过一个不均匀的硬币得到公平的结果？</h1><p>假设 60% 概率 正面，40% 概率反面<br>那么抛两次会有下面四种结果</p><ul><li>正 正 36%</li><li>正 反 24%</li><li>反 正 24%</li><li>反 反 16%</li></ul><p>可以看出 正反 与 反正 的概率是相等的。<br>所以抛两次当正反面不同时，都取第一次的结果为最终结果即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何通过一个不均匀的硬币得到公平的结果？&quot;&gt;&lt;a href=&quot;#如何通过一个不均匀的硬币得到公平的结果？&quot; class=&quot;headerlink&quot; title=&quot;如何通过一个不均匀的硬币得到公平的结果？&quot;&gt;&lt;/a&gt;如何通过一个不均匀的硬币得到公平的结果？&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>64匹马,8个赛道,最少比几次找出跑得最快的4匹马？</title>
    <link href="http://example.com/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/"/>
    <id>http://example.com/2021/03/07/2000-024-64%E5%8C%B9%E9%A9%AC,8%E4%B8%AA%E8%B5%9B%E9%81%93,%E6%9C%80%E5%B0%91%E6%AF%94%E5%87%A0%E6%AC%A1%E6%89%BE%E5%87%BA%E8%B7%91%E5%BE%97%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%EF%BC%9F/</id>
    <published>2021-03-07T14:27:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<p>11 次<br><a class="link"   href="https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2" >解析文档<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11 次&lt;br&gt;&lt;a class=&quot;link&quot;   href=&quot;https://docs.qq.com/sheet/DQlJSeXBkQ2lIZW5j?tab=BB08J2&quot; &gt;解析文档&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>10亿个数中找出最大的10000个数（top K问题）</title>
    <link href="http://example.com/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>http://example.com/2021/03/07/2000-022-10%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%8410000%E4%B8%AA%E6%95%B0%EF%BC%88top%20K%E9%97%AE%E9%A2%98%EF%BC%89/</id>
    <published>2021-03-07T13:16:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-亿个数中找出最大的-10000-个数（top-K-问题）"><a href="#10-亿个数中找出最大的-10000-个数（top-K-问题）" class="headerlink" title="10 亿个数中找出最大的 10000 个数（top K 问题）"></a>10 亿个数中找出最大的 10000 个数（top K 问题）</h1><h2 id="1-对全部数据直接进行排序"><a href="#1-对全部数据直接进行排序" class="headerlink" title="1. 对全部数据直接进行排序"></a>1. 对全部数据直接进行排序</h2><ul><li>时间复杂度 O(nlogn)</li><li>空间复杂度 O(n)</li></ul><p>将 10 亿数据直接进行快排，然后如果大堆长度大于 10000，继续将大堆进行快排。 如果小于 10000 ，那么将最近一次的小堆再次进行快排。如果这个大堆长度加上之前的长度大于 10000，那么对这个大堆进行完整的快排。并取最大的 n 个数。</p><h2 id="2-局部淘汰法"><a href="#2-局部淘汰法" class="headerlink" title="2.局部淘汰法"></a>2.局部淘汰法</h2><ul><li>时间复杂度 O(n+m^2) m 为当前容器大小 10000</li><li>空间复杂度 O(m)</li></ul><p>先保存 10000 个数，然后将后续的数依次与 10000 里最小的数比较，小的直接丢弃，大的进行替换。最后这 10000 个数就是答案。</p><h2 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3.分治法"></a>3.分治法</h2><ul><li>时间复杂度 O(nlogn)</li><li>空间复杂度 O(max(a,b)) a 为每份的长度 这里为 100 万，b 为最后的 m 份的最大 k 这里为 100 份的最大 10000 即 100 万。</li></ul><p>先将 1 亿个数分成 100 份， 每份 100 万个数。然后对每一份进行快排找出最大的 10000 个数。<br>方法是：快排中如果大堆大于 10000 ，继续对大堆进行快排。如果小于 10000，那么对最近的小堆进行快排，如果大堆长度 + 之前的大堆长度满足。那么对大堆进行完全快排取最大的 n 个数。<br>这样找出了 100 份 最大的 10000 个数。继续上边的思路进行快排直到找出最大的 10000 个数。</p><h2 id="4-Hash-法"><a href="#4-Hash-法" class="headerlink" title="4.Hash 法"></a>4.Hash 法</h2><p>先将所有的数存入 hash 表中去重复，减少数据量。然后分治法。</p><blockquote><p><a class="link"   href="https://blog.csdn.net/zyq522376829/article/details/47686867" >https://blog.csdn.net/zyq522376829/article/details/47686867<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-亿个数中找出最大的-10000-个数（top-K-问题）&quot;&gt;&lt;a href=&quot;#10-亿个数中找出最大的-10000-个数（top-K-问题）&quot; class=&quot;headerlink&quot; title=&quot;10 亿个数中找出最大的 10000 个数（top K 问题</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Top K" scheme="http://example.com/tags/Top-K/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2021/02/28/2000-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-02-28T13:12:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算 &lt;&lt;"></a>左移运算 &lt;&lt;</h1><p>3 &lt;&lt; 2，则是将数字 3 左移 2 位</p><h2 id="计算过程："><a href="#计算过程：" class="headerlink" title="计算过程："></a>计算过程：</h2><p>3 &lt;&lt; 2 首先把 3 转换为二进制数字 0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移 2 位，最后在低位(右侧)的两个空位补零。则得到的最终结果是 0000 1100，则转换为十进制是 12。</p><h2 id="数学意义"><a href="#数学意义" class="headerlink" title="数学意义:"></a>数学意义:</h2><p>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以 2 的 1 次方，左移 n 位就相当于乘以 2 的 n 次方。</p><h1 id="amp-与运算"><a href="#amp-与运算" class="headerlink" title="&amp; 与运算"></a>&amp; 与运算</h1><p>参加运算的两个数据，按二进制位进行“与”运算。<br>运算规则：0&amp;0=0;0&amp;1=0;1&amp;0=0;1&amp;1=1;<br>即：两位同时为“1”，结果才为“1”，否则为 0<br>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3&amp;5 的值得 1。</p><h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>用 2 整除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为小于 1 时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p><blockquote><p><a class="link"   href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6" >https://baike.baidu.com/item/二进制<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左移运算-lt-lt&quot;&gt;&lt;a href=&quot;#左移运算-lt-lt&quot; class=&quot;headerlink&quot; title=&quot;左移运算 &amp;lt;&amp;lt;&quot;&gt;&lt;/a&gt;左移运算 &amp;lt;&amp;lt;&lt;/h1&gt;&lt;p&gt;3 &amp;lt;&amp;lt; 2，则是将数字 3 左移 2 位&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>199. 二叉树的右视图</title>
    <link href="http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2021/02/24/2000-021-199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2021-02-24T15:22:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" >199. 二叉树的右视图<i class="fas fa-external-link-alt"></i></a></h1><h1 id="解法一-BFS-广度优先-层序遍历"><a href="#解法一-BFS-广度优先-层序遍历" class="headerlink" title="解法一 BFS 广度优先 层序遍历"></a>解法一 BFS 广度优先 层序遍历</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [Int] &#x3D; []</span><br><span class="line">        var treeList &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            let count &#x3D; treeList.count</span><br><span class="line">            for i in 0 ..&lt; count &#123;</span><br><span class="line">                let tree &#x3D; treeList.remove(at: 0)</span><br><span class="line">                if i &#x3D;&#x3D; count - 1 &#123;</span><br><span class="line">                    ans.append(tree.val)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    treeList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="解法二-DFS-深度优先-前序遍历-变形"><a href="#解法二-DFS-深度优先-前序遍历-变形" class="headerlink" title="解法二 DFS 深度优先 前序遍历 变形"></a>解法二 DFS 深度优先 前序遍历 变形</h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ans: [Int] &#x3D; []</span><br><span class="line">    func rightSideView(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        dfsSlideView(root, 0)</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfsSlideView(_ root: TreeNode?, _ depth: Int) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        if depth &#x3D;&#x3D; ans.count &#123;</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        let d &#x3D; depth + 1</span><br><span class="line">        dfsSlideView(root.right, d)</span><br><span class="line">        dfsSlideView(root.left, d)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;199-二叉树的右视图&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图&quot; class=&quot;headerlink&quot; title=&quot;199. 二叉树的右视图&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <link href="http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <id>http://example.com/2021/02/24/2000-020-%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</id>
    <published>2021-02-24T15:19:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a class="link"   href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" >剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line">        var listTree: [TreeNode] &#x3D; [root]</span><br><span class="line"></span><br><span class="line">        var isLR &#x3D; false</span><br><span class="line">        while !listTree.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempTree: [TreeNode] &#x3D; []</span><br><span class="line">            isLR &#x3D; !isLR</span><br><span class="line">            for tree in listTree &#123;</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempTree.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">                if isLR &#123;</span><br><span class="line">                    valList.append(tree.val)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    valList.insert(tree.val, at: 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listTree &#x3D; tempTree</span><br><span class="line">            ans.append(valList)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-32-III-从上到下打印二叉树-III&quot;&gt;&lt;a href=&quot;#剑指-Offer-32-III-从上到下打印二叉树-III&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 32 - III. 从上到下打印二叉树 III&quot;&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/24/2000-019-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-24T15:17:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历<i class="fas fa-external-link-alt"></i></a></h1><ul><li>时间复杂度<br>O(n) 每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return [] &#125;</span><br><span class="line">        var treeList: [TreeNode] &#x3D; [root]</span><br><span class="line">        var ans: [[Int]] &#x3D; []</span><br><span class="line"></span><br><span class="line">        while !treeList.isEmpty &#123;</span><br><span class="line">            var valList: [Int] &#x3D; []</span><br><span class="line">            var tempList: [TreeNode] &#x3D; []</span><br><span class="line">            for tree in treeList &#123;</span><br><span class="line">                valList.append(tree.val)</span><br><span class="line">                if tree.left !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.left!)</span><br><span class="line">                &#125;</span><br><span class="line">                if tree.right !&#x3D; nil &#123;</span><br><span class="line">                    tempList.append(tree.right!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(valList)</span><br><span class="line">            treeList &#x3D; tempList</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102. 二叉树的层序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树 - 中等</title>
    <link href="http://example.com/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/02/24/2000-018-105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-24T10:12:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/zn7zcr.png"                      alt="105. 从前序与中序遍历序列构造二叉树"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是节点的个数，每个节点都访问一次</li><li>空间复杂度<br>O(n) 除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var inorderMap: [Int: Int] &#x3D; [:]</span><br><span class="line"></span><br><span class="line">    func buildTree(_ preorder: [Int], _ inorder: [Int]) -&gt; TreeNode? &#123;</span><br><span class="line">        let count &#x3D; preorder.count</span><br><span class="line">        &#x2F;&#x2F; 这一步是为了节省时间 但是增加了空间占用</span><br><span class="line">        for (index, val) in inorder.enumerated() &#123;</span><br><span class="line">            inorderMap[val] &#x3D; index</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, count - 1, 0, count - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func myBuildTree(_ preorder: [Int], _ inorder: [Int], _ preorderLeft: Int, _ preorderRight: Int, _ inorderLeft: Int, _ inorderRight: Int) -&gt; TreeNode? &#123;</span><br><span class="line">        if preorderLeft &gt; preorderRight &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 前序遍历的第一个节点就是根节点</span><br><span class="line">        let preorderRoot &#x3D; preorderLeft</span><br><span class="line">        &#x2F;&#x2F; 找出中序遍历的根节点位置</span><br><span class="line">        let inorderRoot &#x3D; inorderMap[preorder[preorderRoot]]!</span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        let root &#x3D; TreeNode(preorder[preorderRoot])</span><br><span class="line">        &#x2F;&#x2F; 左子树的节点数目</span><br><span class="line">        let leftTreeCount &#x3D; inorderRoot - inorderLeft</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderLeft + 1 开始的 leftTreeCount 个元素就是 当前 root 左子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderLeft 开始到 inorderRoot - 1]  就是当前 root 左子树的 所有节点</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorderLeft + 1, preorderLeft + leftTreeCount, inorderLeft, inorderRoot - 1)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        &#x2F;&#x2F; 前序遍历中从 [preorderRoot + 1(这个1是根节点的长度) + leftTreeCount 到 preorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        &#x2F;&#x2F; 中序遍历中从 [inorderRoot + 1 到 inorderRight] 是当前 root 右子树的所有节点</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorderRoot + 1 + leftTreeCount, preorderRight, inorderRoot + 1, inorderRight)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>226. 翻转二叉树 - 简单</title>
    <link href="http://example.com/2021/02/24/2000-017-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/02/24/2000-017-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-24T07:47:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/invert-binary-tree/" >226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/spum89.png"                      alt="226. 翻转二叉树"                ></p><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从根节点开始反转的</span><br><span class="line">    func invertTree2(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">        var treeRoot &#x3D; root</span><br><span class="line">        let ansRoot &#x3D; root</span><br><span class="line">        var list: [TreeNode] &#x3D; [treeRoot]</span><br><span class="line">        while !list.isEmpty &#123;</span><br><span class="line">            treeRoot &#x3D; list.popLast()!</span><br><span class="line">            let temp &#x3D; treeRoot.right</span><br><span class="line">            treeRoot.right &#x3D; treeRoot.left</span><br><span class="line">            treeRoot.left &#x3D; temp</span><br><span class="line">            if treeRoot.left !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.left!)</span><br><span class="line">            &#125;</span><br><span class="line">            if treeRoot.right !&#x3D; nil &#123;</span><br><span class="line">                list.append(treeRoot.right!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ansRoot</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 为节点个数，每个节点访问一次</li><li>空间复杂度<br>O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从叶子节点开始反转的</span><br><span class="line">    func invertTree(_ root: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        let left &#x3D; invertTree(root.left)</span><br><span class="line">        let right &#x3D; invertTree(root.right)</span><br><span class="line">        root.left &#x3D; right</span><br><span class="line">        root.right &#x3D; left</span><br><span class="line">        return root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;226-翻转二叉树&quot;&gt;&lt;a href=&quot;#226-翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;226. 翻转二叉树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/i</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>70. 爬楼梯 - 简单</title>
    <link href="http://example.com/2021/02/24/2000-016-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://example.com/2021/02/24/2000-016-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2021-02-24T07:09:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a class="link"   href="https://leetcode-cn.com/problems/climbing-stairs/" >70. 爬楼梯<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/kmucz8.png"                      alt="70. 爬楼梯"                ></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li>时间复杂度<br>O(n) n 是输入的，循环执行 n 次</li><li>空间复杂度<br>O(1) 只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; n ans</span><br><span class="line">&#x2F;&#x2F; 1  1</span><br><span class="line">&#x2F;&#x2F; 2  2</span><br><span class="line">&#x2F;&#x2F; 3  3</span><br><span class="line">&#x2F;&#x2F; 4  5</span><br><span class="line">&#x2F;&#x2F;( n 的 ans) &#x3D; (n-1 的 ans) + (n-2 的 ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func climbStairs(_ n: Int) -&gt; Int &#123;</span><br><span class="line">        var b1 &#x3D; 0</span><br><span class="line">        var b2 &#x3D; 1</span><br><span class="line">        var ans &#x3D; 0</span><br><span class="line"></span><br><span class="line">        for _ in 1 ... n &#123;</span><br><span class="line">            ans &#x3D; b1 + b2</span><br><span class="line">            b1 &#x3D; b2</span><br><span class="line">            b2 &#x3D; ans</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. 爬楼梯&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/climbing-s</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>236. 二叉树的最近公共祖先 - 中等</title>
    <link href="http://example.com/2021/02/24/2000-015-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://example.com/2021/02/24/2000-015-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2021-02-24T06:35:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" >236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/8s3kd1.png"                      alt="236. 二叉树的最近公共祖先"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) 其中 N 是二叉树的节点数，所有节点都会被访问一次。</li><li>空间复杂度<br>O(n) 其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var commTree: TreeNode?</span><br><span class="line"></span><br><span class="line">    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; TreeNode? &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return nil &#125;</span><br><span class="line">        _ &#x3D; dfs(root, p, q)</span><br><span class="line">        return commTree</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func dfs(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        &#x2F;&#x2F; 左子树是否包含 q 或 q</span><br><span class="line">        let lson &#x3D; dfs(root.left, p, q)</span><br><span class="line">        &#x2F;&#x2F; 右子树是否包含 q 或 q</span><br><span class="line">        let rson &#x3D; dfs(root.right, p, q)</span><br><span class="line">        &#x2F;&#x2F; 左右子树包含pq || (左子树或右子树包含 且 当前root.val &#x3D;&#x3D; p.val 或 q.val)</span><br><span class="line">        if (lson &amp;&amp; rson) || ((lson || rson) &amp;&amp; (root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val)) &#123;</span><br><span class="line">            commTree &#x3D; root</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果包含 p q, 会先命中 root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val</span><br><span class="line">        &#x2F;&#x2F; 这时返回的值是 true, 后面 会命中 lson || rson</span><br><span class="line">        return root.val &#x3D;&#x3D; p?.val || root.val &#x3D;&#x3D; q?.val || lson || rson</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;236. 二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>81. 搜索旋转排序数组 II - 中等</title>
    <link href="http://example.com/2021/02/24/2000-014-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"/>
    <id>http://example.com/2021/02/24/2000-014-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</id>
    <published>2021-02-24T03:08:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link"   href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" >81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/pwhsby.png"                      alt="81. 搜索旋转排序数组 II"                ></p><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul><li><p>时间复杂度<br>O(n) 大多情况下每次都减少一般的数据</p></li><li><p>空间复杂度<br>O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func search(_ nums: [Int], _ target: Int) -&gt; Bool &#123;</span><br><span class="line">      if nums.isEmpty &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      if nums.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">          return nums[0] &#x3D;&#x3D; target</span><br><span class="line">      &#125;</span><br><span class="line">      var left &#x3D; 0</span><br><span class="line">      var right &#x3D; nums.count - 1</span><br><span class="line">      &#x2F;&#x2F; [1, 2]</span><br><span class="line">      &#x2F;&#x2F; 必须是 &gt;&#x3D; 会存在 到最后左右指针相遇 才找到 目标值的情况</span><br><span class="line">      while right &gt;&#x3D; left &#123;</span><br><span class="line">          let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">          if nums[mid] &#x3D;&#x3D; target &#123;</span><br><span class="line">              return true</span><br><span class="line">          &#125;</span><br><span class="line">          if nums[mid] &lt; nums[right] &#123;</span><br><span class="line">              if nums[mid] &lt; target, target &lt;&#x3D; nums[right] &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else if nums[mid] &gt; nums[right] &#123;</span><br><span class="line">              if nums[left] &lt;&#x3D; target, target &lt; nums[mid] &#123;</span><br><span class="line">                  right &#x3D; mid - 1</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  left &#x3D; mid + 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              right -&#x3D; 1</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return false</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;81-搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#81-搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;81. 搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字 - 简单</title>
    <link href="http://example.com/2021/02/24/2000-013-%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2021/02/24/2000-013-%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2021-02-24T02:36:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a class="link"   href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" >剑指 Offer 11. 旋转数组的最小数字<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://ftp.bmp.ovh/imgs/2021/02/f8daa4e0fade64f3.png"                      alt="剑指 Offer 11. 旋转数组的最小数字"                ></p><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul><li>时间复杂度<br>O(log n) 在二分查找的过程中，大部分情况都会忽略一半的区间。</li><li>空间复杂度<br>O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            return numbers[0]</span><br><span class="line">        &#125;</span><br><span class="line">        var left &#x3D; 0</span><br><span class="line">        var right &#x3D; numbers.count - 1</span><br><span class="line">        while right &gt; left &#123;</span><br><span class="line">            let mid &#x3D; (right - left) &#x2F; 2 + left</span><br><span class="line">            if numbers[mid] &gt; numbers[right] &#123;</span><br><span class="line">                &#x2F;&#x2F; numbers[mid] &gt; numbers[right] mid 已经大于 right 所以 mid 不应该包含在区间内  所以 mid + 1</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            &#125; else if numbers[mid] &lt; numbers[right] &#123;</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;  mid 和 left right 相等的情况， 就让right -&#x3D;1</span><br><span class="line">                right -&#x3D; 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[left]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="一次遍历法"><a href="#一次遍历法" class="headerlink" title="一次遍历法"></a>一次遍历法</h1><ul><li>时间复杂度<br>O(n)</li><li>空间复杂度<br>O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func minArray(_ numbers: [Int]) -&gt; Int &#123;</span><br><span class="line">        if numbers.isEmpty &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">        var ans &#x3D; numbers[0]</span><br><span class="line">        for item in numbers &#123;</span><br><span class="line">            ans &#x3D; min(ans, item)</span><br><span class="line">        &#125;</span><br><span class="line">        return ans</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-11-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#剑指-Offer-11-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 11. 旋转数组的最小数字&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>112. 路径总和 - 简单</title>
    <link href="http://example.com/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://example.com/2021/02/23/2000-012-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2021-02-23T15:55:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a class="link"   href="https://leetcode-cn.com/problems/path-sum/" >112. 路径总和<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/lxqfb4.png"                      alt="112. 路径总和"                ></p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n),每个节点都要访问一次</li><li>空间复杂度<br>O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return false &#125;</span><br><span class="line">        if root.left &#x3D;&#x3D; nil, root.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">            return root.val &#x3D;&#x3D; targetSum</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 递归每次用当前的 sum - 当前 root.val</span><br><span class="line">        &#x2F;&#x2F; 一直 减减减 减到 叶子节点， 就判断当前的 sum 和 root.val 是否相等即可</span><br><span class="line">        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先解法"><a href="#广度优先解法" class="headerlink" title="广度优先解法"></a>广度优先解法</h1><ul><li>时间复杂度<br>O(n),每个节点都要访问一次</li><li>空间复杂度<br>O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -&gt; Bool &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; &#x2F;&#x2F; 如果 root &#x3D; nil 那么就一定不存在了</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var stackTree: [TreeNode] &#x3D; [root]</span><br><span class="line">        var treeVal: [Int] &#x3D; [root.val]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;           1</span><br><span class="line">        &#x2F;&#x2F;         &#x2F;   \</span><br><span class="line">        &#x2F;&#x2F;        2     3</span><br><span class="line">        &#x2F;&#x2F;       &#x2F; \    &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;      4   5   6  7</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 1 添加 2 3,同时 treeVal 移除 1.val 添加 1+2.val ，1+3.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 2 添加 4 5,同时 treeVal 移除 2.val 添加 2+4.val ，2+5.val</span><br><span class="line">        &#x2F;&#x2F; stackTree 移除 3 添加 6 7,同时 treeVal 移除 3.val 添加 3+6.val ，3+7.val</span><br><span class="line">        while !stackTree.isEmpty &#123;</span><br><span class="line">            let tree: TreeNode &#x3D; stackTree.popLast()!</span><br><span class="line">            let sum &#x3D; treeVal.popLast()</span><br><span class="line">            if tree.left &#x3D;&#x3D; nil, tree.right &#x3D;&#x3D; nil &#123;</span><br><span class="line">                if sum &#x3D;&#x3D; targetSum &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.left !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.left!)</span><br><span class="line">                treeVal.append(sum! + tree.left!.val)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if tree.right !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(tree.right!)</span><br><span class="line">                treeVal.append(sum! + tree.right!.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;112-路径总和&quot;&gt;&lt;a href=&quot;#112-路径总和&quot; class=&quot;headerlink&quot; title=&quot;112. 路径总和&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/path</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>155. 最小栈 - 简单</title>
    <link href="http://example.com/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://example.com/2021/02/23/2000-011-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2021-02-23T10:23:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a class="link"   href="https://leetcode-cn.com/problems/min-stack/" >155. 最小栈<i class="fas fa-external-link-alt"></i></a></h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://files.catbox.moe/g135og.png"                      alt="155. 最小栈"                ></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ul><li>时间复杂度<br>对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是<br>O(1)，我们定义的每个操作最多调用栈操作两次。</li><li>空间复杂度<br>其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    var list: [Int] &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;记录当前最小值</span><br><span class="line">    var minNum: Int?</span><br><span class="line">    &#x2F;&#x2F;只存最小值</span><br><span class="line">    var minNums: [Int] &#x3D; []</span><br><span class="line"></span><br><span class="line">    init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    func push(_ x: Int) &#123;</span><br><span class="line">        list.append(x)</span><br><span class="line">        minNum &#x3D; min(minNum ?? .max, x)</span><br><span class="line">        if minNum &#x3D;&#x3D; x &#123;</span><br><span class="line">            minNums.append(minNum!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func pop() &#123;</span><br><span class="line">        let p &#x3D; list.removeLast()</span><br><span class="line">        if minNum &#x3D;&#x3D; p &#123;</span><br><span class="line">            minNum &#x3D; list.min()</span><br><span class="line">            minNums.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func top() -&gt; Int &#123;</span><br><span class="line">        return list.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getMin() -&gt; Int &#123;</span><br><span class="line">        return minNums.last ?? 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;155-最小栈&quot;&gt;&lt;a href=&quot;#155-最小栈&quot; class=&quot;headerlink&quot; title=&quot;155. 最小栈&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/problems/min-sta</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是中间人攻击？如何防止攻击？</title>
    <link href="http://example.com/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/"/>
    <id>http://example.com/2021/02/23/1000-020%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%EF%BC%9F/</id>
    <published>2021-02-23T08:10:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h1><p>A &lt;—-&gt; B<br>A &lt;—-&gt; C &lt;—-&gt; B<br>正常是 A 和 B 通信，这时 C 截获了 A 发给 B 的消息，然后假装成 A 给 B 发送消息。</p><p>中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。<br>在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。<br>一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL 协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p><h1 id="如何防止中间人攻击？"><a href="#如何防止中间人攻击？" class="headerlink" title="如何防止中间人攻击？"></a>如何防止中间人攻击？</h1><p>使用由 CA (数字证书认证机构 Certificate Authority)签发或签名的数子证书 来提供认证和加密。证书必须放入服务器和客户端中。</p><p>要信任某个证书真实有效，该证书必须通过属于可信认证中心 (CA) 的根证书进行数字签名。操作系统和浏览器维护有可信 CA 根证书的列表，以便可以轻松验证 CA 签发和签名的证书。</p><blockquote><p>摘录于 <a class="link"   href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" >https://zh.wikipedia.org/wiki/中间人攻击<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN" >https://cloud.ibm.com/docs/mobilefoundation?topic=mobilefoundation-prevent_man_in_the_middle_attack&amp;locale=zh-CN<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是中间人攻击？&quot;&gt;&lt;a href=&quot;#什么是中间人攻击？&quot; class=&quot;headerlink&quot; title=&quot;什么是中间人攻击？&quot;&gt;&lt;/a&gt;什么是中间人攻击？&lt;/h1&gt;&lt;p&gt;A &amp;lt;—-&amp;gt; B&lt;br&gt;A &amp;lt;—-&amp;gt; C &amp;lt;—-&amp;gt</summary>
      
    
    
    
    <category term="网络协议" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>145. 二叉树的后序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-010-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T07:18:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" >145. 二叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树的后序遍历 左 右 根</p><p>当根节点的左右子树均为空的时候 add root.val</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        postorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func postorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        postorder(root.left, &amp;list)</span><br><span class="line">        postorder(root.right, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="真迭代解法"><a href="#真迭代解法" class="headerlink" title="真迭代解法"></a>真迭代解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal1(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 用来记录回退的根节点 在回退的时候 要判断这个是不是刚刚回退的节点 如果不加判断会死循环</span><br><span class="line">        var lastTree: TreeNode?</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; root.right &#x3D;&#x3D; nil 时做下列操作很容易理解</span><br><span class="line">            if root?.right &#x3D;&#x3D; nil || root?.right &#x3D;&#x3D;&#x3D; lastTree &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                &#x2F;&#x2F; 这个时候要回退了，所以先记录当前的这个节点</span><br><span class="line">                lastTree &#x3D; root</span><br><span class="line">                &#x2F;&#x2F; 要把 root 置 nil 进行回退， 否则又是死循环</span><br><span class="line">                root &#x3D; nil</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="假后序解法"><a href="#假后序解法" class="headerlink" title="假后序解法"></a>假后序解法</h1><ul><li>时间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。 一个 n 是所有节点的遍历，另一个是最后的反转</li><li>空间复杂度<br>O(n): O(2n) 因为 2 为常数级，所以是 O(n)。一个 n 是迭代栈的开销，一个是最后反转的开销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal2(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        &#x2F;&#x2F; 后序遍历的顺序是  左右根</span><br><span class="line">        &#x2F;&#x2F; 反转后是 根右左，和前序遍历的 根左右 很像</span><br><span class="line">        &#x2F;&#x2F; 所以来用前序遍历的变形写法，然后把得的数据反转就行了</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.right</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.reversed()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; title=&quot;145. 二叉树的后序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>144. 二叉树的前序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-009-144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T05:09:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" >144. 二叉树的前序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树的前序遍历 根 左 右</p><p>当根节点不为空时,直接把 root.val add list</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        preorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func preorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        preorder(root.left, &amp;list)</span><br><span class="line">        preorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度<br>O(n) n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度<br>O(n) 为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func preorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var stackTree: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line">        while root !&#x3D; nil || !stackTree.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                list.append(root!.val)</span><br><span class="line">                stackTree.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stackTree.popLast()</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. 二叉树的前序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>94. 二叉树的中序遍历 - 中等</title>
    <link href="http://example.com/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/02/23/2000-008-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-02-23T03:05:00.000Z</published>
    <updated>2021-03-12T16:36:58.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></h1><p><a class="link"   href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/" >二叉树遍历<i class="fas fa-external-link-alt"></i></a></p><p>二叉树中序遍历顺序为 左 根 右<br>当根节点的左子树为空时添加该根节点，即在 root.left = nil, 后 add root.val</p><h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><ul><li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度 O(n)<br>空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        inorder(root, &amp;list)</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func inorder(_ root: TreeNode?, _ list: inout [Int]) &#123;</span><br><span class="line">        guard let root &#x3D; root else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 中序遍历 左 中 右</span><br><span class="line">        &#x2F;&#x2F; 即中序遍历，左根右。当根结点的左子树为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即前序遍历，根左右。当根节点不为空时，那么 add root.val</span><br><span class="line">        &#x2F;&#x2F; 即后序遍历，左右根。当根节点的左右子树均为空时，那么 add root.val</span><br><span class="line">        inorder(root.left, &amp;list)</span><br><span class="line">        list.append(root.val)</span><br><span class="line">        inorder(root.right, &amp;list)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h1><ul><li>时间复杂度 O(n)<br>其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度 O(n)<br>空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func inorderTraversal(_ root: TreeNode?) -&gt; [Int] &#123;</span><br><span class="line">        var list: [Int] &#x3D; []</span><br><span class="line">        var tempList: [TreeNode] &#x3D; []</span><br><span class="line">        var root &#x3D; root</span><br><span class="line"></span><br><span class="line">        while root !&#x3D; nil || !tempList.isEmpty &#123;</span><br><span class="line">            while root !&#x3D; nil &#123;</span><br><span class="line">                tempList.append(root!)</span><br><span class="line">                root &#x3D; root?.left</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; tempList.popLast()</span><br><span class="line">            list.append(root!.val)</span><br><span class="line">            root &#x3D; root?.right</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
</feed>
